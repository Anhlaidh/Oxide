[{"content":"idea  ctrl+shift+v:替换变量名 ctrl+alt+v:抽取并赋值 ctrl+p:查看参数 ctrl+alt+o删除多余包 ctrl+F12 查看当前类中的包 ctrl+shift+enter 自动完成当前语句 ctrl+shift+backspace 返回到上次修改位置 alt+shift+F9 Debug  类转型\u0026amp;多态\u0026amp;契约设计  类转型：子类可以转父类，父类不可以转子类（除非父类对象本身就是子类） 多态：子类转型为父类后，调用普通方法，依旧是子类方法 契约设计：类不会直接使用另一个类，而是采用接口的形式，外部可以“空投”这个接口下的任意子类对象  static、final 和常量设计 static  static 变量：不管有多少个对象，内存中只有一份 static 方法：可以使用类名直接引用，无需 new 对象来引用   静态方法不可以调用动态变量 非静态方法可以调用静态方法 静态方法不可调用非静态方法  static 块：static 块只执行一次，并且 static 块\u0026gt;匿名块\u0026gt;构造函数  单例模式  设计模式：是经过验证的、用于某些特定场合的解决方案 GOF 提出 23 中设计模式；创建型、结构性和行为型 单例模式保证一个类在内存空间中只有一个对象   内部初始化一个单例 private 不可见，getInstance(static 方法)来取出单例对象  final  final 类：没有子类继承 final 方法：不能被子类改写（不能重写，可以重载） final 字段：基本类型被能修改值，对象类型不能修改指针（可以修改内容）  常量\u0026amp;常量池  java 中的常量：static 和 final notes.Java 接口中的变量都是常量 对象生成有两种：常量赋值（栈内存）和 new 创建（堆内存） 常见包装类  java 编译器会优化已经确定的变量 栈内存与堆内存运算会产生新的堆内存（存疑）  不可变对象  不可变对象提高读效率 不可变对象设计的方法 字符串 append 操作速度：StringBuilder\u0026gt;StringBuffer\u0026gt;String  notes.Java 访问权限 notes.Java 类库 数字类   根据数字特点选择合适的类\n  尽量使用类库自带的方法\n  整数   浮点数需要注意精度   BigInteger\n   支持无限大的整数运算   BigDecimal -支持无限大的小数运算   注意精度和截断   随机数  字符串类  String（不可变对象，只读） StringBuffer（字符串加减，同步，性能好） StringBuilder（字符串加减，不同步，性能更好）  时间类  当前多数程序还是使用 calendar 类处理时间  2. DateUtil，Instance 时间戳\n格式化类  NumberFormat  MessageFormat  DateFormat  DateFormatter   Exception 异常分类  异常：程序不正常的行为或状态 异常处理：  程序返回到安全状态 允许用户保存结果，并以适当方式关闭程序   异常分类  Throwable:所有错误的祖先 Error：系统内部错误或者资源耗尽 Exception：程序有关错误   又可分为unchecked异常和checked异常， 编译器会辅助检查checked异常  异常处理 try：正常逻辑代码 catch：当try发生异常，将执行catch代码，若无异常，绕之 finally：当try或者catch执行后，必须要执行finally\n  一个try只会进入一个catch，优先级从上而下   throws:抛出异常\n  一个方法被覆盖，覆盖他的方法必须抛出相同的异常，或者异常的子类 如果父类方法抛出多个异常，那么重写的子类方法必须抛出那些异常的子集，也就是不能抛出新的异常       自定义异常  自定义异常，需要继承Exception类或者其子类  继承自Exception就变成CheckedException 继承自RuntimeException，就变成Unchecked Exception   自定义重点在构造函数  调用父类Exception的message构造函数 可以自定义自己的成员变量   在程序中采用throw主动抛出异常  异常抛出测试     数组  数组是一种确定大小的储存同种数据的容器 初始化和遍历方法  JCF  容器框架的作用 JCF主要数据结构   列表 集合 映射  List  ArrayList ：for循环遍历最快，迭代器最慢 索引位置适中   遍历快  LinkedList ：for循环遍历最快，迭代器适中，索引位置极慢   插入快  Vector（同步）    和ArrayList类似，可变数组实现的列表\n  Vector同步，适合再 ==多线程== 下使用\n  迭代器\n     Set  确定性：对任意对象都能判定其是否属于某一集合 互异性：集合内每个元素都是不相同的，注意是内容互异 无序性：集合内的顺序无关  java中的集合接口Set   HashSet(基于散列函数的集合，无序，不支持同步)  无序，遍历for快于iterator    LinkedHashSet(基于散列函数和双向链表的集合，可排序的，不支持同步)  存储数据是插入的顺序序，for快于iterator    TreeSet(基于树结构的集合，可排序的，不支持同步)  不可有null，按着从小到大的顺序存储，for快于iterator     HashSet\u0026amp;\u0026amp;LinkedHashSet 的比较是通过hashcode比较的，若想要new的新对象根据自定义要求去重，重写hashcode方法\n 判定两个元素的hashCode是否相同，若不同，返回false 若两者hashCode相同，判定equals方法，若不同，返回false，否则返回true hashCode和equals方法是所有类都有的，因为Object类有 \u0026gt;\u0026gt;TreeSet判断重复利用compareTo方法，实体类需要继承Comparable接口，然后重写CompareTo方法   补充：Integer类重写了CompareTo方法 \u0026gt;    Map  Hashtable 同步，慢，数据量小 t是小写  HashMap 不支持同步，快，数据量大  遍历有iterator方法和KeySet方法（hashMap.get(key)）,KeySet方法速度更快   LinkedHashMap  基于双向链表的维持插入顺序的HashMap   TreeMap  基于红黑树的Map，可以根据key的自然排序，按照key的从大到小或者compareTo方法进行排序输出   Properties 同步，文件形式，数据量小   Util  Arrays\n 补充（fill(数组名，开始位数，结束位数，值)) Arrays.asList(str.split(\u0026ldquo;reg\u0026rdquo;)) 将字符串转化为list  String.join(\u0026ldquo;reg\u0026rdquo;,List) 将list转化为字符串     Collections\n-对象的比较\n  File   文件系统和java是并列的两套系统 File类是文件基本属性操作的主要类 java7提出了NIO包在某些功能上有重要的补充作用      javaIO  java文件处理类都在java.io包中 处理类分成：节点类、包装类（转化类、装饰类）  File   文件系统和java是并列的两套系统 File类是文件基本属性操作的主要类 java7提出了NIO包在某些功能上有重要的补充作用      文件读写 写入文件  写文件  先创建文件，写入数据，关闭文件 FileOutputStream,OutputStreamWriter,BufferWriter BufferWriter  write newLine   try-resource语句，自动关闭资源 关闭最外层的数据流，将会把其上所有的数据流关闭    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  public class testWrite { public static void main(String[] args) { method_1(); // method_2();  } public static void method_1() { FileOutputStream fileOutputStream = null;//节点类，负责写字节  OutputStreamWriter outputStreamWriter = null;//转化类，负责字符到字节的转化  BufferedWriter bufferedWriter = null;//装饰类，负责写字符到缓存区  //三者关系bufferedWriter(OutputStreamWriter(FIleOutputStream)))  try { fileOutputStream = new FileOutputStream(\u0026#34;./temp/abc.txt\u0026#34;); outputStreamWriter = new OutputStreamWriter(fileOutputStream, \u0026#34;UTF-8\u0026#34;); bufferedWriter = new BufferedWriter(outputStreamWriter); // bufferedReader = new BufferedReader(new OutputStreamWriter(new FileOutputStream(\u0026#34;./temp.abc\u0026#34;)));  //一句话的写法  outputStreamWriter.write(\u0026#34;我们是\u0026#34;);//TODO 存疑 javaIO可用outputStreamWrite来输出？  bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;method_1\u0026#34;); bufferedWriter.newLine(); } catch (Exception e) { e.printStackTrace(); }finally { try { bufferedWriter.close();//关闭最后一个，会将所有的底层流全部关闭  } catch (Exception ex) { ex.printStackTrace(); } } } public static void method_2() { //try-resource语句,自动关闭资源  try (BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\u0026#34;./temp/abc.txt\u0026#34;)))) { bufferedWriter.write(\u0026#34;我们是\u0026#34;); bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;method_2\u0026#34;); bufferedWriter.newLine(); } catch (Exception e) { e.printStackTrace(); } } }    读文件  先打开文件，逐行读入数据，关闭文件 FileInputStream,InputStream,BufferedReader BufferReader  readLine   try-resource语句，自动关闭资源 关闭最外层的数据流，将会把其上所有的数据流关闭    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public class testRead { public static void main(String[] args) { method_1(); System.out.println(\u0026#34;===============\u0026#34;); method_2(); } public static void method_1() { FileInputStream fileInputStream = null; InputStreamReader inputStreamReader = null; BufferedReader bufferedReader = null; String line = \u0026#34;\u0026#34;; try { fileInputStream = new FileInputStream(\u0026#34;./temp/abc.txt\u0026#34;); inputStreamReader = new InputStreamReader(fileInputStream, \u0026#34;UTF-8\u0026#34;); bufferedReader = new BufferedReader(inputStreamReader); // bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\u0026#34;./temp/abc.txt\u0026#34;)));  while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } catch (Exception e) { e.printStackTrace(); }finally { try { bufferedReader.close(); } catch (Exception e) { e.printStackTrace(); } } } public static void method_2() { try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\u0026#34;./temp/abc.txt\u0026#34;)))) { String line = \u0026#34;\u0026#34;; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } catch (Exception e) { e.printStackTrace(); } } }   尽量使用try-resource方法，自动关闭资源\n二进制文件读写 ####写入\n 写文件  先创建文件，写入数据，关闭文件 FileOutputStream,BufferedOutputStream,DataOutputStream DataOutputStream  flush write/writeBoolean/writeByte/writeChars/writeDouble/writeInt/writeUTF/\u0026hellip;   try-source 语句，自动关闭资源 关闭最外层数据流，将会把其上所有的数据流关闭    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public class testBinWrite { public static void main(String[] args) { method_1(); } public static void method_1() { FileOutputStream fileOutputStream = null; DataOutputStream dataOutputStream = null; BufferedOutputStream bufferedOutputStream = null; try { fileOutputStream = new FileOutputStream(\u0026#34;./temp/def.dat\u0026#34;); dataOutputStream = new DataOutputStream(fileOutputStream); bufferedOutputStream = new BufferedOutputStream(dataOutputStream); dataOutputStream.writeUTF(\u0026#34;a\u0026#34;); dataOutputStream.writeInt(222); dataOutputStream.writeUTF(\u0026#34;b\u0026#34;); } catch (Exception e) { e.printStackTrace(); }finally { try { bufferedOutputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } }    读文件  先打开文件，读入数据，关闭文件 FileInputStream,BufferedInputStream,DataInputStream DataInputStream read/readBoolean/readInt/readChar/readDouble/readFloat/readUTF/\u0026hellip; try-resource语句，自动关闭资源 关闭最外层的数据流，将会把其上所有的数据流关闭    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class testBinRead { public static void main(String[] args) { method_2(); } //try-resource  public static void method_2() { try (DataInputStream dataInputStream = new DataInputStream( new BufferedInputStream(new FileInputStream(\u0026#34;./temp/def.dat\u0026#34;)))) { String a = dataInputStream.readUTF(); int b = dataInputStream.readInt(); String c = dataInputStream.readUTF(); System.out.println(a); System.out.println(b); System.out.println(c); } catch (Exception ex) { ex.printStackTrace(); } } }   总结：\n 理解节点类，转换类，包装类的联合用法 读取需要根据写入的规则进行读取，避免错位 尽量使用try-resource语句，自动关闭资源  zip读入输出 zip\n","permalink":"http://blog.oxide.ink/posts/java/java%E7%AC%94%E8%AE%B001/","summary":"idea  ctrl+shift+v:替换变量名 ctrl+alt+v:抽取并赋值 ctrl+p:查看参数 ctrl+alt+o删除多余包 ctrl+F12 查看当前类中的包 ctrl+shift+enter 自动完成当前语句 ctrl+shift+backspace 返回到上次修改位置 alt+shift+F9 Debug  类转型\u0026amp;多态\u0026amp;契约设计  类转型：子类可以转父类，父类不可以转子类（除非父类对象本身就是子类） 多态：子类转型为父类后，调用普通方法，依旧是子类方法 契约设计：类不会直接使用另一个类，而是采用接口的形式，外部可以“空投”这个接口下的任意子类对象  static、final 和常量设计 static  static 变量：不管有多少个对象，内存中只有一份 static 方法：可以使用类名直接引用，无需 new 对象来引用   静态方法不可以调用动态变量 非静态方法可以调用静态方法 静态方法不可调用非静态方法  static 块：static 块只执行一次，并且 static 块\u0026gt;匿名块\u0026gt;构造函数  单例模式  设计模式：是经过验证的、用于某些特定场合的解决方案 GOF 提出 23 中设计模式；创建型、结构性和行为型 单例模式保证一个类在内存空间中只有一个对象   内部初始化一个单例 private 不可见，getInstance(static 方法)来取出单例对象  final  final 类：没有子类继承 final 方法：不能被子类改写（不能重写，可以重载） final 字段：基本类型被能修改值，对象类型不能修改指针（可以修改内容）  常量\u0026amp;常量池  java 中的常量：static 和 final notes.","title":"Java笔记01"},{"content":"Maven Junit 测试   单元测试：对软件中最小可测试单元进行检查和验证，通常是一个函数/方法（属于白盒测试）\n 集成测试： 将多个单元相互作用，形成一个整体，对整体协调性进行测试    白盒测试： 全面了解程序内部逻辑结构，对所有的逻辑路径都进行测试，一般由程序员完成\n 黑盒测试：又名功能测试，将程序看作不可打开的盒子，一般由独立使用者完成    自动测试：用程序批量、反复的测试程序，并可自动检查程序结果是否满足预定的要求\n 手动测试：手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求    回归测试：修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误\n  深入学习：软件测试-基于问题驱动模式 朱少民\n  Junit   import static 导入该包内的所有静态方法，使用时可不加类名\n  Triangle\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package JavaLearning_Advanced.Maven; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 13:42 */ public class Triangle { public boolean judgeEdges(int a, int b, int c) { boolean result = true; //边长非负性  if (a \u0026lt;= 0 || b \u0026lt;= 0 || c \u0026lt;= 0) { return false; } //两边和大于第三边  if (a+b\u0026lt;=c) { return false;} if (b+c\u0026lt;=a) { return false;} if (c+a\u0026lt;=b) { return false;} return true; } }    testTriangle  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import JavaLearning_Advanced.Maven.Triangle; import org.junit.Test; import static org.junit.Assert.*; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 13:44 */ public class testTriangle { @Test public void test() { assertEquals(false,new Triangle().judgeEdges(1,2,3)); } }    深入学习：Junit实战（第二版），PetarTahchiey  Java字符编码  尽可能使用UTF-8 读取写入编码保持一致  国际化   Locale 方法\n getAvailableLocales()获取所有可用的locale getDefault()返回默认的Locale    native2ascii.exe\n  ResourceBundle\n 根据Locale要求，加载语言文件 存储语言集合中的K-V对 getString(String key) 返回对应的value    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package JavaLearning_Advanced.International; import java.util.Locale; import java.util.ResourceBundle; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 14:34 */ public class HelloWorld { public static void main(String[] args) { //取得系统默认的国家/语言环境  Locale myLocale = Locale.getDefault(); System.out.println(myLocale);//zh_CN  //根据指定语言，国家环境，加载资源文件  ResourceBundle bundle = ResourceBundle.getBundle(\u0026#34;message\u0026#34;, myLocale); //从资源文件中获取信息  System.out.println(bundle.getString(\u0026#34;hello\u0026#34;)); } }   高级字符编码 正则表达式   学习正则表达式： 精通正则表达式（第三版） Jefferry E.F.Friedl\n  java.util.regex包\n Pattern 正则表达式的编译表示  compile编译一个正则表达式喂Pattern对象 matcher用Pattern对象匹配一个字符串，返回匹配结果   Matcher  IndexMethod(位置方法) //start(),start(int group),end(),end(group) StudyMethod(查找方法) //lookingAt(),find(),find(int start),matches() Replacement(替换方法) //replaceAll(String replacement)      Matcher\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package JavaLearning_Advanced.regex; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:21 */ public class MatcherDemo { private static final String REGEX = \u0026#34;\\\\bdog\\\\b\u0026#34;;//\\b表示边界  private static final String INPUT = \u0026#34;dog dog dog doggie dogg\u0026#34;; public static void main(String[] args) { //检查字符串里有多少个dog  Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); int count = 0; while (matcher.find()) { count++; System.out.println(\u0026#34;Match number\u0026#34; + count); System.out.println(\u0026#34;start()\u0026#34; + matcher.start()); System.out.println(\u0026#34;end()\u0026#34; + matcher.end()); // String f = \u0026#34;fooooooooooooo\u0026#34;; // matcher.lookingAt();//不完全匹配,匹配foo为true // matcher.find();//完全匹配，匹配foo为false  } } }   Replace\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package JavaLearning_Advanced.regex; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:39 */ public class ReplaceDemo { public static void Replace_1() { String REGEX = \u0026#34;a*b\u0026#34;;//*表示限定前面的a可以有0个或者多个  String INPUT = \u0026#34;aavfooabfooabafoobcdd\u0026#34;; String REPLACE = \u0026#34;-\u0026#34;; Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); StringBuffer stringBuffer = new StringBuffer(); // 全部替换  while (matcher.find()) { matcher.appendReplacement(stringBuffer, REPLACE); } //最后将尾巴字符串附加上  matcher.appendTail(stringBuffer); System.out.println(stringBuffer.toString()); } public static void Replace_2() { String REGEX = \u0026#34;dog\u0026#34;;//*表示限定前面的a可以有0个或者多个  String INPUT = \u0026#34;The dog says meow.All dogs say meow\u0026#34;; String REPLACE = \u0026#34;cat\u0026#34;; Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); INPUT = matcher.replaceAll(REPLACE); System.out.println(INPUT); } }    OJ  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package JavaLearning_Advanced.regex; import org.apache.commons.io.Charsets; import org.apache.commons.io.IOUtils; import java.io.InputStream; import java.nio.charset.Charset; import java.util.LinkedList; import java.util.List; import java.util.Scanner; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:55 */ public class String2inputStream { public static void main(String[] args) { //构造字符串列表  List\u0026lt;String\u0026gt; names = new LinkedList\u0026lt;\u0026gt;(); names.add(\u0026#34;xiaohong\u0026#34;); names.add(\u0026#34;xiaoming\u0026#34;); names.add(\u0026#34;Daming\u0026#34;); names.add(\u0026#34;xiaohei\u0026#34;); //合并为一个字符串，以逗号相连  String nameStr = String.join(\u0026#34;,\u0026#34;, names); //将字符串作为默认输入流  InputStream in = IOUtils.toInputStream(nameStr, Charsets.toCharset(\u0026#34;UTF-8\u0026#34;)); //重置系统的输入流  System.setIn(in); //模拟键盘输入，这也是OJ平台测试用例输入的原理  //此处也可以换成一个文件的输入流  Scanner scanner = new Scanner(System.in); scanner.useDelimiter(\u0026#34;,\u0026#34;); while (scanner.hasNext()) { System.out.println(scanner.next()); } } }   xml  常规语法  任何的起始标签都必须有一个结束标签 简化写法，例如，可以写为 大小写敏感，name和Name不一样 每个文件都要有一个根元素 标签必须按合适的顺序进行嵌套，不可错位 所有的特性都必须有值，且在值的周围加上引号 需要转义字符，如\u0026quot;\u0026lt;\u0026ldquo;需要用\u0026lt;代替      转义 符号 意思     \u0026amp;lt; \u0026lt; 小于   \u0026amp;gt; \u0026gt; 大于   \u0026amp;amp; \u0026amp; 和号   \u0026amp;apos; ' 单引号   \u0026amp;quot; \u0026quot; 双引号       注释：\u0026lt;!\u0026ndash; 内容 \u0026ndash;\u0026gt;    xml解析 未完成\nJSON  概念  JavaScript Object Notation ，JS对象表示法 是一种轻量级的数据交换格式 类似XML，更小、更快、更易解析 最早用于JavaScript中，容易解析，最后推广到全语言 尽管使用JavaScript语法，但是独立于编程语言   用途  JSON生成 JSON解析 JSON校验 和JavaBean对象进行互解析  具有一个无参的构造函数 可以包括多个属性，所有属性都是private 每个属性都有对应的Getter/Setter方法 JavaBean 用于封装数据，有可称为POJO(Plain Old notes.Java Object)      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  package JavaLearning_Advanced.Json; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.File; import java.io.IOException; import java.util.Arrays; import java.util.List; /** * @Description: * @author: Anhlaidh * @date: 2020/3/26 0026 21:42 */ public class testJackson { public static void main(String[] args) throws IOException { testJsonObject(); System.out.println(\u0026#34;分割线=====================================================\u0026#34;); testJsonFile(); } private static void testJsonFile() throws IOException { ObjectMapper objectMapper = new ObjectMapper(); //从json文件中加载，并重构为java对象  File json = new File(\u0026#34;temp/json/books.json\u0026#34;); List\u0026lt;Book\u0026gt; books = objectMapper.readValue(json, new TypeReference\u0026lt;List\u0026lt;Book\u0026gt;\u0026gt;() { }); for (Book book : books) { System.out.println(book.getAuthor()); System.out.println(book.getTitle()); } } private static void testJsonObject() throws IOException { ObjectMapper objectMapper = new ObjectMapper(); //构造对象  Person person = new Person(); person.setName(\u0026#34;TOM\u0026#34;); person.setAge(20); person.setScores(Arrays.asList(60, 70, 80)); //将对象解析为json字符串  String jsonStr = objectMapper.writeValueAsString(person); System.out.println(jsonStr); //json字符串重构对象  Person p2 = objectMapper.readValue(jsonStr, Person.class); System.out.println(p2.getName()); System.out.println(p2.getAge()); System.out.println(p2.getScores()); //从json字符串重构JsonNode对象  JsonNode node = objectMapper.readTree(jsonStr); System.out.println(node.get(\u0026#34;name\u0026#34;).asText()); System.out.println(node.get(\u0026#34;age\u0026#34;).asText()); System.out.println(node.get(\u0026#34;scores\u0026#34;)); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  [ { \u0026#34;category\u0026#34;: \u0026#34;COOKING\u0026#34;, \u0026#34;tools.title\u0026#34;: \u0026#34;Everyday Italian\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Giada De Laurentiis\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2005\u0026#34;, \u0026#34;price\u0026#34;: 30 }, { \u0026#34;category\u0026#34;: \u0026#34;CHILDREN\u0026#34;, \u0026#34;tools.title\u0026#34;: \u0026#34;Harry Potter\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;J K Rowling\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2005\u0026#34;, \u0026#34;price\u0026#34;: 29 }, { \u0026#34;category\u0026#34;: \u0026#34;WEB\u0026#34;, \u0026#34;tools.title\u0026#34;: \u0026#34;Learning XML\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Erik T.Ray\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2003\u0026#34;, \u0026#34;price\u0026#34;: 39 } ]    总结  JSON是一种独立于编程语言的、轻量的、数据交换格式 有多种第三方库辅助我们进行JSON生成和解析 JSON会丢失顺序性    图片 - imageIO\r- 验证码\r 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  package JavaLearning_Advanced.picture; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.Random; /** * @Description: * @author: Anhlaidh * @date: 2020/3/28 0028 19:56 */ public class ValidateCode { static char[] codeSequence= {\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;G\u0026#39;,\u0026#39;H\u0026#39;,\u0026#39;I\u0026#39;,\u0026#39;J\u0026#39;,\u0026#39;K\u0026#39;,\u0026#39;L\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;N\u0026#39;,\u0026#39;O\u0026#39;,\u0026#39;P\u0026#39;,\u0026#39;Q\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;S\u0026#39;,\u0026#39;T\u0026#39;,\u0026#39;U\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Z\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;}; static int charNum = codeSequence.length; public static void main(String[] args) throws IOException { generateCode(\u0026#34;./temp/validateCode/code.jpg\u0026#34;); } private static void generateCode(String filePath) throws IOException { //首先定义验证码图片库  int width = 140;//验证码图片的宽度  int height = 40;//验证码图片的高度  BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //定义图片上的图形和干扰线  Graphics2D graphics2D = bufferedImage.createGraphics(); graphics2D.setColor(Color.GRAY);//将图像填充为浅灰色  graphics2D.fillRect(0, 0, width, height); graphics2D.setColor(Color.BLACK);//画边框  graphics2D.drawRect(0, 0, width - 1, height - 1); //随机产生16条灰色干扰线  graphics2D.setColor(Color.darkGray); //创建一个随机数生成器类，用于随机产生干扰线  Random random = new Random(); for (int i = 0; i \u0026lt; 16; i++) { int x = random.nextInt(width); int y = random.nextInt(height); int x1 = random.nextInt(50); int y1 = random.nextInt(50); graphics2D.drawLine(x, y, x1, y1); } //计算字的位置坐标  int codeCount = 4;//字的个数  int fontHeight ;//字体高度  int codeX;//第一个字符的x坐标，因为后面的字符坐标依次递增，所以他们的x轴值是codeX+i的值  int codeY;//验证字符的y坐标，因为并排所以值一样  //width-4除去左右多余的位置，使验证码更加集中显示，减的越多越集中  //codeCount+1//等比分配显示的宽度，包括左右两边的空格  codeX = (width - 4) / (codeCount + 1);//第一个字母的起始位置  fontHeight = height - 10;//height-10高度中间区域显示验证码  codeY = height - 7; //创建字体，字体的大小应该根据图片的高度来定  Font font = new Font(\u0026#34;Fixedsys\u0026#34;, Font.PLAIN, fontHeight); graphics2D.setFont(font); //随机产生codeCount数字的验证码  for (int i = 0; i \u0026lt; codeCount; i++) { //每次随机拿一个字母，赋予随机的颜色  String strRand = String.valueOf(codeSequence[random.nextInt(charNum)]); int red = random.nextInt(255); int blue = random.nextInt(255); int green = random.nextInt(255); graphics2D.setColor(new Color(red, green, blue)); //把字放到图片上  graphics2D.drawString(strRand, (i + 1) * codeX, codeY); } ImageIO.write(bufferedImage, \u0026#34;jpg\u0026#34;, new File(filePath)); } }   多进程和多线程 概念 多进程  当前的操作系统都是多任务OS 每个独立执行的任务就是一个进程 OS将时间划分为多个时间片（时间很短） 每个时间片内将CPU分配给某一个任务，时间片结束，CPU自动回收，再分配给另外任务。从外部看，所有任务都是同时在执行。 但是在CPU上，任务是按照串行依次运行（单核CPU ）。如果多核，多个进程任务可以并行。但是单个核上，多进程只能串行执行 多进程的优点  可以同时运行多个任务 程序因IO堵塞时，可以释放CPU，让CPU为其他程序服务 当系统有多个CPU时，可以为多个程序同时服务  我们的CPU不再提高频率，而是提高核数 多核和并行程序才是提高程序性能的唯一办法     多进程的缺点  太笨重，不好管理 太笨重，不好切换    多线程  一个程序可以包括多个子任务，可串/并行 每个子任务可以称为一个线程 如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作，这样CPU还是保留在本程序中，而不是被调度到别的程序（进程）去， 这样，提高本程序获得CPU时间和利用率  启动  start方法，会自动以新进程调用run方法 直接调用run方法，会编程串行执行 同一个线程，多次start会报错，只执行第一次start方法 多个线程启动，其启动的先后顺序是随机的 线程无需关闭，只要其run方法执行结束后，自动关闭 main函数（线程）可能早于新线程结束，整个程序并不终止 整个程序终止是等所有的线程都终止（包括main函数线程）  ####多线程实现的对比\n Thread占据了父类名额，不如Runnable方便 Thread类实现Runnable Runnable启动时需要Thread类的支持 Runnable更容易实现多线程中资源共享  结论：建议实现Runnable接口来完成多线程\n规则 规则一： 1.调用run方法来启动run方法，将会是串行运行 2. 调用start方法，来启动run方法，将会是并行运行（多线程运行） 规则二：\n main线程可能早于子线程结束 main线程和子线程都结束了，整个程序才算终止 规则三： 1.实现Runnable的对象必须包装在Thread类里面，才可以启 不能直接对Runnable对象进行start方法 规则四： 一个线程对象不能多次start，多次start将报异常 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定  一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则一： * 1.调用run方法来启动run方法，将会是串行运行 * 2. 调用start方法，来启动run方法，将会是并行运行（多线程运行） * * @author: Anhlaidh * @date: 2020/3/28 0028 22:59 */ public class first { public static void main(String[] args) throws InterruptedException { new TestThread0().run(); while (true) { System.out.println(\u0026#34;main\u0026#34;); Thread.sleep(10); } } } class TestThread0 extends Thread{ @Override public void run() { while (true) { System.out.println(\u0026#34;testThread0\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }   二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则二： * 1. main线程可能早于子线程结束 * 2. main线程和子线程都结束了，整个程序才算终止 * @author: Anhlaidh * @date: 2020/3/28 0028 23:06 */ public class second { public static void main(String[] args) throws InterruptedException { new TestThread1().start(); // while (true) { // System.out.println(\u0026#34;main\u0026#34;); // Thread.sleep(10); // }  } } class TestThread1 extends Thread{ @Override public void run() { while (true) { System.out.println(\u0026#34;testThread1\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }   三:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则三： * 1.实现Runnable的对象必须包装在Thread类里面，才可以启动 * 2. 不能直接对Runnable对象进行start方法 * @author: Anhlaidh * @date: 2020/3/28 0028 23:33 */ public class third { public static void main(String[] args) throws InterruptedException { // new TestThread2().start();  //runnable对象必须放在一个Thread类中才能运行  TestThread2 tt = new TestThread2(); Thread thread = new Thread(tt); thread.start(); while (true) { System.out.println(\u0026#34;main\u0026#34;); Thread.sleep(1000); // }  } } } class TestThread2 implements Runnable { @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName()); //输出当前线程名  try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }   四：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则四： * 1. 一个线程对象不能多次start，多次start将报异常 * 2. 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定 * @author: Anhlaidh * @date: 2020/3/28 0028 23:39 */ public class Fourth { public static void main(String[] args) { TestThread4 t1 = new TestThread4(); t1.start(); // t1.start();  TestThread4 t2 = new TestThread4(); t2.start(); } } class TestThread4 extends Thread { @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName()+\u0026#34;is running\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }   多进程和多线程的对比  线程共享数据 线程通讯更高效 线程更轻量级，更容易切换 多个线程更容易管理  多线程信息共享  线程类  通过继承Thread或实现Runnable 通过start方法，调用run方法，run方法工作 线程run结束后，线程退出   粗粒度：子线程与子线程之间、和main线程之间缺乏交流 细粒度：线程之间有信息交流通讯  通过共享变量达到信息共享 Jdk原生库不支持发送消息   通过共享变量在多个线程中共享消息  static变量 同一个Runnable类的成员变量    test1:继承thread，static修饰的变量可以共享，但是会造成数据重复\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 20:23 */ public class ThreadDemo0 { public static void main(String[] args) { new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); } private static class TestThread0 extends Thread { // private int tickets = 100; 每个线程卖100张，没有共享  private static int tickets = 100; //static变量是共享的，所有的线程共享  @Override public void run() { while (tickets\u0026gt;0) { System.out.println(Thread.currentThread().getName() + \u0026#34; is selling tickets\u0026#34; + tickets); tickets = tickets - 1; } } } }    多线程信息共享问题  工作缓存副本 关键步骤缺乏加锁限制   i++，并非原子性操作  读取主存i（正本）到工作缓存（副本）中 每个CPU执行（副本）i+1操作 CPU将结果写入到缓存（副本）中 数据从工作缓存（副本）刷到主存（正本）中   变量副本问题的解决办法  采用volatile关键字修饰变量 保证不同线程对共享变量操作时的可见性    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 20:55 */ public class ThreadDemo2 { public static void main(String[] args) throws InterruptedException { TestTread3 testTread3 = new TestTread3(); testTread3.start(); Thread.sleep(1000); testTread3.flag = false; System.out.println(\u0026#34;main thread is exiting\u0026#34;); } private static class TestTread3 extends Thread { // boolean flag = true;//子线程不会停止  volatile boolean flag = true;//用volatile修饰的变量可以及时在各线程里面通知  @Override public void run() { int i = 0; while (flag) { i++; } System.out.println(\u0026#34;test thread is exiting\u0026#34;); } } }    关键步骤加锁限制  互斥：某一个线程运行一个代码段（关键区），其他线程不能同时运行这个代码段 同步：多个线程的运行，必须按照某一种规定的先后顺序来运行 互斥是同步的一种特例   互斥的关键字是synchronized  synchronized代码块/函数，只能一个线程进入 synchronized能加大性能负担，但是使用简便    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 21:16 */ public class ThreadDemo3 { public static void main(String[] args) { TestThread3 testThread3 = new TestThread3(); new Thread(testThread3).start(); new Thread(testThread3).start(); new Thread(testThread3).start(); new Thread(testThread3).start(); } private static class TestThread3 implements Runnable { private volatile int tickets = 100; @Override public void run() { while (tickets\u0026gt;0) { sale(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } private synchronized void sale() { System.out.println(Thread.currentThread().getName() + \u0026#34; sale \u0026#34; + tickets--); } } }   多线程管理   线程状态\n NEW 刚创建（new） RUNNABLE就绪态（start） RUNNING运行中（run） BLOCK阻塞（sleep） TERMINATED 结束    Thread的部分API已经废弃\n 暂停和恢复：suspend/resume 消亡：stop/destroy    线程阻塞/和唤醒\n sleep，时间一到，自己就会醒来 wait/notify/notifyAll，等待，需要别人来唤醒 join，等待另一个线程结束 interrupt，向另外一个线程发送中断信号，该线程收到信号，会触发 Interrupted Exception（可接触阻塞），并进入下一步处理    线程类\n  主动interrupt\n  被动interrupt\n  多线程死锁\n 每个线程相互持有别人需要的锁（哲学家吃面问题） 预防死锁，对资源进行等级排序    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  package JavaLearning_Advanced.thread.Interrupt; import java.util.concurrent.TimeUnit; /** * @Description: * @author: Anhlaidh * @date: 2020/4/7 0007 22:05 */ public class DeadLock { public static Integer r1 = 1; public static Integer r2 = 2; public static void main(String[] args) { Thread1 t1 = new Thread1(); t1.start(); Thread2 t2 = new Thread2(); t2.start(); } } class Thread1 extends Thread { @Override public void run() { //先要r1再要r2  synchronized (DeadLock.r1) { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (DeadLock.r2) { System.out.println(\u0026#34;Thread1 is running\u0026#34;); } } } } class Thread2 extends Thread { @Override public void run() { //先要r2再要r1  synchronized (DeadLock.r2) { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (DeadLock.r1) { System.out.println(\u0026#34;Thread2 is running\u0026#34;); } } } }    守护（后台）线程  普通线程的结束，是run方法运行结束 守护线程的结束，是run方法运行结束，或main函数结束 守护线程永远不要访问资源，如文件或数据库等    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  package JavaLearning_Advanced.thread.Interrupt; /** * @Description: * @author: Anhlaidh * @date: 2020/4/7 0007 22:19 */ public class protect { public static void main(String[] args) throws InterruptedException { Thread3 t = new Thread3(); t.setDaemon(true); t.start(); Thread.sleep(2000); System.out.println(\u0026#34;main thread is exiting\u0026#34;); } } class Thread3 extends Thread { @Override public void run() { while (true) { try { Thread.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;running\u0026#34;); } } }    线程查看工具jvisualvm  并发框架   业务：任务多，数据量大\n  串行 并行\n 串行编程简单，并行编程困难 单个计算核频率下降，计算核数增多，整体性能变高    并行困难（任务分配和执行过程高度耦合）\n 如何控制粒度，切割任务 如何分配任务给线程，监督线程执行过程    并行计算  并行模式  主从模式(Master-Slave) Worker模式(Worker-Worker)   Java并发编程  Thread/Runnable/Thread组管理 Executor(重点) Fork-Join框架    线程组管理  线程组ThreadGroup  线程的集合 树形结构,大线程可以包括小线程组 可以通过enumerate方法遍历组内的线程,执行操作 能够有效管理多个线程,但是管理效率低 任务分配和执行过程高度耦合 重复创建线程,关闭线程操作,无法重用线程    Executor*  从jdk5开始提供Executor FrameWork  分离任务的创建和执行者的创建 线程重复利用(new线程代价很大)   理解共享线程池的概念  预设好的多个Thread,可弹性增加 多次执行很多很小的任务 任务创建和执行过程解耦 程序员无需关心线程池执行任务过程    Main:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  package JavaLearning_Advanced.thread.Executor.example2; import java.util.ArrayList; import java.util.List; import java.util.concurrent.ExecutionException; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ThreadPoolExecutor; /** * @Description: * @author: Anhlaidh * @date: 2020-04-08 22:15 */ public class SumTest { public static void main(String[] args) { //执行线程池  ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(8); List\u0026lt;Future\u0026lt;Integer\u0026gt;\u0026gt; resultList = new ArrayList\u0026lt;\u0026gt;(); //统计1-1000总和,分成10个任务计算,提交任务  for (int i = 0; i \u0026lt; 10; i++) { SumTask calculator = new SumTask(i*100+1,(i+1)*100); Future\u0026lt;Integer\u0026gt; result = executor.submit(calculator); resultList.add(result); } //每隔50毫秒,轮询等待10个任务结束  do { System.out.printf(\u0026#34;Main:已经完成了多少个任务:%d\\n\u0026#34;, executor.getCompletedTaskCount()); for (int i = 0; i \u0026lt; resultList.size(); i++) { Future\u0026lt;Integer\u0026gt; result = resultList.get(i); System.out.printf(\u0026#34;Main Task %d:%s\\n\u0026#34;, i, result.isDone()); } try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (executor.getCompletedTaskCount() \u0026lt; resultList.size()); //所有任务都已经结束,综合计算结果  int total = 0; for (int i = 0; i \u0026lt; resultList.size(); i++) { Future\u0026lt;Integer\u0026gt; result = resultList.get(i); Integer sum = null; try { sum = result.get(); total = total + sum; } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } System.out.println(\u0026#34;1-1000的总和\u0026#34; + total); } }   SumTask:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package JavaLearning_Advanced.thread.Executor.example2; import java.util.Random; import java.util.concurrent.Callable; /** * @Description: * @author: Anhlaidh * @date: 2020-04-08 22:17 */ public class SumTask implements Callable { private int startNumber; private int endNumber; public SumTask(int startNumber, int endNumber) { this.startNumber = startNumber; this.endNumber = endNumber; } @Override public Integer call() throws Exception { int sum = 0; for (int i = startNumber; i \u0026lt;= endNumber; i++) { sum = sum + i; } Thread.sleep(new Random().nextInt(1000)); System.out.printf(\u0026#34;%s:%d\u0026#34;, Thread.currentThread().getName(), sum); return sum; } }   Fork-Join  关键类  ForkJoinPool 任务池 RecursiveAction RecursiveTask Main:    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package JavaLearning_Advanced.thread.Fork_Join; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; /** * @Description: * @author: Anhlaidh * @date: 2020-04-09 13:37 */ public class SumTest { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建执行线程池  ForkJoinPool pool = new ForkJoinPool(8); //创建任务  SumTask task = new SumTask(1,1000000); //提交任务  ForkJoinTask\u0026lt;Long\u0026gt; result = pool.submit(task); //等待结果  do { System.out.printf(\u0026#34;Main:Thread Count:%d\\n\u0026#34;, pool.getActiveThreadCount()); System.out.printf(\u0026#34;Main:Parallelism:%d\\n\u0026#34;, pool.getParallelism()); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (!task.isDone()); //输出结果  System.out.println(result.get().toString()); } }   SumTask\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package JavaLearning_Advanced.thread.Fork_Join; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; /** * @Description: * @author: Anhlaidh * @date: 2020-04-09 13:37 */ public class SumTest { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建执行线程池  ForkJoinPool pool = new ForkJoinPool(8); //创建任务  SumTask task = new SumTask(1,1000000); //提交任务  ForkJoinTask\u0026lt;Long\u0026gt; result = pool.submit(task); //等待结果  do { System.out.printf(\u0026#34;Main:Thread Count:%d\\n\u0026#34;, pool.getActiveThreadCount()); System.out.printf(\u0026#34;Main:Parallelism:%d\\n\u0026#34;, pool.getParallelism()); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (!task.isDone()); //输出结果  System.out.println(result.get().toString()); } }   主要类  ExecutorService,ThreadPoolExecutor,Future  Executors.newCachedThreadPool/newFixedThreadPool创建线程池 ExecutorService线程池服务 Callable 具体的逻辑对象(线程类) Future返回结果    并发数据结构  阻塞式集合:当集合为空或者满时,等待 非阻塞式集合:当集合为空或者满时,不等待,返回null或异常  -List\n Vector 同步安全,写多读少 ArrayList 不安全 Collections.synchronizedList(List list) 基于synchronized,效率差 CopyOnWriteArrayList 读多写少,基于复制机制,非阻塞 Set  HashSet不安全 Collections.synchronizedSet(Set set)基于synchronized,效率差 CopyOnWriteArraySet (基于CopyOnWriteArrayList实现),读多写少,非阻塞   Map  Hashtable 同步安全,写多读少 HashMap 不安全 Collections.synchronizedMap(Map map)基于synchronized,效率差 ConcurrentHashMap,读多写少,非阻塞   Queue\u0026amp;Deque  ConcurrentLinkedQueue非阻塞 ArrayBlockingQueue/LinkedBlockingQueue阻塞    并发协作与控制 Lock  买奶茶,读写锁,互斥锁\n  Lock也可以实现同步的效果  实现更复杂的临界区结构 tryLock方法可以预判锁是否空闲 允许分离读写的操作,多个读,一个写 性能更好   ReentrantLock 类,可重入的互斥锁 ReentrantReadWriteLock类,可重入的读写锁 lock和unlock函数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128  package notes.Java.JavaLearning_Advanced.thread.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.concurrent.locks.ReentrantReadWriteLock; /** * @Description: * @author: Anhlaidh * @date: 2020-05-07 16:41 */ public class LockExample { private static final ReentrantLock queueLock = new ReentrantLock();//可重入锁  private static final ReentrantReadWriteLock orderLock = new ReentrantReadWriteLock();//可读写锁  /** * 有家奶茶店,点单时需要排队 * 假设想买奶茶的人如果看到需要排队就等等 * 假设奶茶店又老板和多名员工,记单方式比较原始,只有一个订单本 * 老板负责写新订单,员工不断查看订单本得到信息来制作奶茶,在老板写订单时员工不可以看订单本 * 多个员工可同时看订单本,但此时老板不可写入订单本 * @param args args */ public static void main(String[] args) { // byMilkTea();  handleOrder(); } private static void byMilkTea() { LockExample lockExample = new LockExample(); int CUSTOMER_CNT = 10; Thread[] customers = new Thread[CUSTOMER_CNT]; for (int i = 0; i \u0026lt; CUSTOMER_CNT; i++) { customers[i] = new Thread(new Runnable() { @Override public void run() { try { long walkingTime = (long) (Math.random() * 1000); Thread.sleep(walkingTime); lockExample.tryToBuyMilkTea(); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } }); customers[i].start(); } } private void tryToBuyMilkTea() throws InterruptedException { boolean flag = true; while (flag) { if (queueLock.tryLock()) { // queueLock.lock();  long thinkingTime = (long) (Math.random() * 500); Thread.sleep(thinkingTime); System.out.println(Thread.currentThread().getName() + \u0026#34;:来一杯奶茶,不要珍珠\u0026#34;); flag = false; queueLock.unlock(); } else { System.out.println(Thread.currentThread().getName()+\u0026#34;:再等等\u0026#34;); } if (flag) { Thread.sleep(1000); } } } private static void handleOrder() { LockExample lockExample = new LockExample(); Thread boss = new Thread(new Runnable() { @Override public void run() { while (true) { try { lockExample.addOrder(); long waitingTime = (long) (Math.random() * 1000); Thread.sleep(waitingTime); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } } }); boss.start(); int WORKER_CNT = 3; Thread[] workers = new Thread[WORKER_CNT]; for (int i = 0; i \u0026lt; WORKER_CNT; i++) { workers[i] = new Thread(new Runnable() { @Override public void run() { while (true) { try { lockExample.viewOrder(); long workingTime = (long) (Math.random() * 5000); Thread.sleep(workingTime); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } } }); workers[i].start(); } } private void viewOrder() throws InterruptedException { orderLock.readLock().lock(); long readingTime = (long) (Math.random() * 500); Thread.sleep(readingTime); System.out.println(Thread.currentThread().getName()+\u0026#34;:查看订单\u0026#34;); orderLock.readLock().unlock(); } private void addOrder() throws InterruptedException { orderLock.writeLock().lock(); long writingTime = (long) (Math.random() * 1000); Thread.sleep(writingTime); System.out.println(\u0026#34;老板新加一笔订单\u0026#34;); orderLock.writeLock().unlock(); } }   Semaphore  抢车位,车位满了不可停车,其他等着\n  信号量:由1965年Dijkstra提出 信号量:本质上是一个计数器 计数器大于0,可以使用,等于0不能使用 可以设置多个并发量,例如限制10个访问 Semaphore  acquire获取 release释放   比lock更进一步,可以控制多个同时访问关键区  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  package notes.Java.JavaLearning_Advanced.thread.Semaphore; import java.util.concurrent.Semaphore; /** * @Description: * @author: Anhlaidh * @date: 2020-05-07 17:48 */ public class SemaphoreExample { private final Semaphore placeSemaphore = new Semaphore(5); public boolean parking() { if (placeSemaphore.tryAcquire()) { System.out.println(Thread.currentThread().getName() + \u0026#34;停车成功\u0026#34;); return true; } else { System.out.println(Thread.currentThread().getName() + \u0026#34;没有空位\u0026#34;); return false; } } public void leaving() { placeSemaphore.release(); System.out.println(Thread.currentThread().getName()+\u0026#34;:开走\u0026#34;); } /** * 一个车库,五个车位,十辆车需要停放,每次停放时,申请信号量 * @param args args * @throws InterruptedException exception */ public static void main(String[] args) throws InterruptedException { int tryToParkCnt = 10; SemaphoreExample semaphoreExample = new SemaphoreExample(); Thread[] parkers = new Thread[tryToParkCnt]; for (int i = 0; i \u0026lt; tryToParkCnt; i++) { parkers[i] = new Thread(new Runnable() { @Override public void run() { try { long randomTime = (long) (Math.random() * 1000); Thread.sleep(randomTime); if (semaphoreExample.parking()) { long parkingTime = (long) (Math.random() * 1000); Thread.sleep(parkingTime); semaphoreExample.leaving(); } } catch (InterruptedException e) { System.out.println(e.getMessage()); } } }); parkers[i].start(); } for (int i = 0; i \u0026lt; tryToParkCnt; i++) { parkers[i].join(); } } }   latch  百米赛跑,发令枪归零同时起跑(startSignal),运动员依次就位(doneSignal)\n  等待锁,是一个同步辅助类 用来同步执行任务的一个或者多个线程 不是用来保护临界区或者资源共享 CountDownLatch  countDown() 计数-1 await() 等待latch变成0    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package notes.Java.JavaLearning_Advanced.thread.CountDownLatch; import java.util.concurrent.CountDownLatch; /** * @Description: * @author: Anhlaidh * @date: 2020-05-08 10:58 */ public class CountDownLatchExample { /** * 设想百米赛跑比赛,发令枪发出信号后选手开始跑,全部选手跑到终点后比赛结束 * @param args args * @throws InterruptedException Interrupted Exception */ public static void main(String[] args) throws InterruptedException { int runnerCnt = 10; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(runnerCnt); for (int i = 0; i \u0026lt; runnerCnt; i++) {//create and start threads  new Thread(new Worker(startSignal,doneSignal)).start(); } System.out.println(\u0026#34;准备工作\u0026#34;); System.out.println(\u0026#34;准备工作就绪\u0026#34;); startSignal.countDown();//let all thread proceed  System.out.println(\u0026#34;比赛开始\u0026#34;); doneSignal.await();//wait for all to finish  } private static class Worker implements Runnable { private final CountDownLatch startSignal; private final CountDownLatch downSignal; public Worker(CountDownLatch startSignal, CountDownLatch downSignal) { this.startSignal = startSignal; this.downSignal = downSignal; } @Override public void run() { try { startSignal.await(); Thread.sleep((long)(Math.random()*500)); doWork(); downSignal.countDown(); } catch (InterruptedException e) { //return;  } } private void doWork() { System.out.println(Thread.currentThread().getName()+\u0026#34;:跑完全程\u0026#34;); } } }   Barrier  分步计算总和\n  集合点,也是一个同步辅助类 允许多个线程在某一个点上进行同步 CyclicBarrier  构造函数是需要同步的线程数量 await等待其他线程,达到数量后就放行    Phaser  允许执行并发多阶段任务,同步辅助类 在每一个阶段结束的位置对线程进行同步,当所有线程都到达这步,再进行下一步 Phaser  arrive() arriveAndAwaitAdvance()    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  package notes.Java.JavaLearning_Advanced.thread.Phaser; import java.util.concurrent.Phaser; /** * @Description: * @author: Anhlaidh * @date: 2020-05-08 19:46 */ public class PhaserExample { /** * 假设举行考试,总共三个答题,每次下发一道题目,等所有学生完成后再进行下一道 * @param args */ public static void main(String[] args) { int STUDENT_CNT = 5; Phaser phaser = new Phaser(STUDENT_CNT); for (int i = 0; i \u0026lt; STUDENT_CNT; i++) { new Thread(new Student(phaser)).start(); } } private static class Student implements Runnable { private final Phaser phaser; public Student(Phaser phaser) { this.phaser = phaser; } @Override public void run() { try { doTesting(1); phaser.arriveAndAwaitAdvance(); doTesting(2); phaser.arriveAndAwaitAdvance(); doTesting(3); phaser.arriveAndAwaitAdvance(); } catch (InterruptedException e) { e.printStackTrace(); } } private void doTesting(int i) throws InterruptedException { String name = Thread.currentThread().getName(); System.out.println(name + \u0026#34;开始第\u0026#34; + i + \u0026#34;题\u0026#34;); long thinkingTime = (long) (Math.random() * 1000); Thread.sleep(thinkingTime); System.out.printf(\u0026#34;%s第%d到题答题结束\\n\u0026#34;,name,i); } } }   Exchanger  双向交换数据\n  允许在并发线程中相互交换消息 允许在2个线程种定义同步点,当两个线程都达到同步点,他们交换数据结构 Exchanger  exchange(),线程双方互相交换数据 交换数据是双向的    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  package notes.Java.JavaLearning_Advanced.thread.Exchanger; import java.util.Scanner; import java.util.concurrent.Exchanger; /** * @Description: * @author: Anhlaidh * @date: 2020-05-10 17:16 */ public class ExchangerExample { /** * 通过Exchanger实现学生成绩查询,简单线程间的数据交换 * @param args */ public static void main(String[] args) throws InterruptedException { Exchanger\u0026lt;String\u0026gt; exchanger = new Exchanger\u0026lt;String\u0026gt;(); BackgroundWorker worker = new BackgroundWorker(exchanger); new Thread(worker).start(); Scanner reader = new Scanner(System.in); while (true) { System.out.println(\u0026#34;输出要查询的的属性学生姓名:\u0026#34;); String input = reader.nextLine().trim(); exchanger.exchange(input); String value = exchanger.exchange(null); if (\u0026#34;exit\u0026#34;.equals(value)) { break; } System.out.println(\u0026#34;查询结果\u0026#34; + value); } reader.close(); } private static class BackgroundWorker implements Runnable{ final Exchanger\u0026lt;String\u0026gt; exchanger; public BackgroundWorker(Exchanger\u0026lt;String\u0026gt; exchanger) { this.exchanger = exchanger; } @Override public void run() { while (true) { try { String item = exchanger.exchange(null); switch (item) { case \u0026#34;zhangsan\u0026#34;: exchanger.exchange(\u0026#34;90\u0026#34;); break; case \u0026#34;lisi\u0026#34;: exchanger.exchange(\u0026#34;80\u0026#34;); break; case \u0026#34;wangwu\u0026#34;: exchanger.exchange(\u0026#34;70\u0026#34;); break; case \u0026#34;exit\u0026#34;: exchanger.exchange(\u0026#34;exit\u0026#34;); default: exchanger.exchange(\u0026#34;none\u0026#34;); } } catch (InterruptedException e) { e.printStackTrace(); } } } } }   定时任务  简单定时机制  设置计划任务,也就是在指定的时间开始执行某一个任务 TimerTask封装任务 Timer类 定时器   Timer  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  package notes.Java.JavaLearning_Advanced.thread.Timer; import java.util.Calendar; import java.util.Date; import java.util.Timer; import java.util.TimerTask; /** * @Description: * @author: Anhlaidh * @date: 2020-05-10 17:42 */ public class TimerTest { public static void main(String[] args) throws InterruptedException { MyTask myTask = new MyTask(); Timer timer = new Timer(); System.out.println(\u0026#34;当前时间:\u0026#34; + new Date().toLocaleString()); //当前时间一秒后,每两秒执行一次  timer.schedule(myTask,1000,2000); Thread.sleep(10000); myTask.cancel();//取消当前任务  System.out.println(\u0026#34;==============\u0026#34;); Calendar now = Calendar.getInstance(); now.set(Calendar.SECOND, now.get(Calendar.SECOND) + 3); Date runDate = now.getTime(); MyTask2 myTask2 = new MyTask2(); timer.scheduleAtFixedRate(myTask2,runDate,3000); } private static class MyTask extends TimerTask { @Override public void run() { System.out.println(\u0026#34;运行了!时间为:\u0026#34;+new Date()); } } private static class MyTask2 extends TimerTask{ @Override public void run() { System.out.println(\u0026#34;运行了!时间为:\u0026#34;+new Date()); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } } }    Executor+定时器机制 ScheduledExecutorService  定时任务 周期任务   Quartz  Quartz是一个较为完善的任务调度框架 解决程序中Timer零散管理的问题 功能更加强大  Timer执行周期任务,如果中间有一次有一场,整个任务终止执行 Quartz执行周期任务,如果中间某一次有异常,不影响下次任务执行      ​\nJava网络编程 网络基础知识   网络是当前信息技术的第一推动力\n  每个计算设备上都有若干个网卡\n  每个网卡上有（全球唯一）单独的硬件地址，MAC地址\n  ip地址\n IPV4 192.169.0.1每段0-255 IPV6 128bit长，8段，每段4个16进制数 ipconfig ifconfig    port:端口 0~65535\n 0~1023OS已经占用了，80是web，23是telnet 1024~65535，一般程序可使用（谨防冲突）    两台机器通讯就是在IP+port上进行的\n netstat -an    保留ip：127.0.0.1 本机\n  公网（万维网/互联网）和内网（局域网）\n 网络上分层的 最外层的是外网/互联网 底下每层都是内网 ip地址可以在每个层次的网重用 tracert 看当前及其和目标机器的访问中继    通讯协议TCP UDP\n TCP(Transmission Control Protocol)  传输控制协议，面向连接的协议 两台机器的可靠无差错的数据传输 双向字节流传递   UDP(User Datagram Protocol) \u0026ndash;\u0026gt;QQ(多次UDP模仿TCP) 用户数据报协议，面向无连接协议 不保证可靠的数据传输 速度快，也可以在较差的网络下使用    UDP  计算机通讯：数据从一个IP的port出发（发送方），运输到另外一个IP的port（接收方） UDP：无连接无状态的通讯协议  发送方发送消息，如果接收方刚好在目的地，则可以接受，如果不在 那这个消息就丢失了 发送方也无法得知是否发送成功 UDP的好处就是简单节省，经济    实例  DatagramSocket:通讯的数据管道  send和receive方法 （可选，多网卡）绑定一个IP和Port   DatagramPacket  集装箱：封装数据 地址标签：目的地IP+Port Receive:    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package JavaLearning_Advanced.UDP; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; /** * @Description: receive * @author: Anhlaidh * @date: 2020/3/29 0029 0:23 */ public class UdpRecv { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(3000); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf,buf.length); System.out.println(\u0026#34;UdpRecv：等待信息\u0026#34;); socket.receive(packet); System.out.println(\u0026#34;UdpRecv:已接受信息\u0026#34;); String strRecv = new String(packet.getData(), 0, packet.getLength()) + \u0026#34;from\u0026#34; + packet.getAddress().getHostAddress() + \u0026#34;:\u0026#34; + packet.getPort(); System.out.println(strRecv); String str = \u0026#34;nice to meet you!!\u0026#34;; DatagramPacket packet1 = new DatagramPacket(str.getBytes(), str.length(), packet.getAddress(), packet.getPort()); System.out.println(\u0026#34;UdpRecv:即将发送信息！\u0026#34;); socket.send(packet1); System.out.println(\u0026#34;UdpRecv:已发送\u0026#34;); } }   send:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package JavaLearning_Advanced.UDP; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; /** * @Description: send * @author: Anhlaidh * @date: 2020/3/29 0029 0:24 */ public class UdpSend { public static void main(String[] args) throws Exception{ DatagramSocket socket = new DatagramSocket(); String str = \u0026#34;hi ,im a mini robot\u0026#34;; DatagramPacket packet = new DatagramPacket(str.getBytes(), str.length(), InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;), 3000); System.out.println(\u0026#34;UdpSend:我要发送信息了\u0026#34;); socket.send(packet); System.out.println(\u0026#34;UdpSend: 发送完毕\u0026#34;); Thread.sleep(1000); byte[] buf = new byte[1024]; DatagramPacket packet1 = new DatagramPacket(buf, 1024); System.out.println(\u0026#34;UdpSend：我在等待信息\u0026#34;); socket.receive(packet1); System.out.println(\u0026#34;UdpSend：已收到信息\u0026#34;); String str2 = new String(packet1.getData(), 0, packet1.getLength())+\u0026#34;from\u0026#34;+packet1.getAddress().getHostAddress() +\u0026#34;:\u0026#34;+packet1.getPort(); System.out.println(str2); } }   TCP   TCP协议：有链接、保证可靠的无误差通讯\n 服务器：创建一个ServerSocket，等待连接 客户机：创建一个Socket，连接到服务器 服务器：ServerSocket接收到连接，创建一个Socket和客户的Socket建立专线连接，后续服务器和客户机的对话 （这一对Socket）会在一个单独的线程（服务器端）上运行 服务器的ServerSocket继续等待连接，返回 i.    软件服务器有两要求：\n 它能够实现一定的功能 它必须在一个公开地址上对外提供服务    ServerSocket：服务码头\n 需要绑定Port 如果有多块网卡，需要绑定一个IP地址    Socket：运输通道\n 客户端需要绑定服务器的地址和Port 客户端往Socket输入流写入数据，送到服务端 客户端从Socket输出流取服务端过来的数据 服务器反之亦然    过程：\n 服务端等待响应时，处于阻塞状态 服务端可以同时响应多个客户端 服务端每接受一个客户端，就启动一个独立的线程与其对应 客户端或者服务端都可以选择关闭这条Socket通道 实例  服务端先启动，且一直保留 客户端后启动，可以先退出      Server:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package JavaLearning_Advanced.TCP; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 13:16 */ public class TCPServer2 { public static void main(String[] args) { try { ServerSocket serverSocket = new ServerSocket(8001); while (true) { Socket socket = serverSocket.accept(); System.out.println(\u0026#34;来了一个client\u0026#34;); new Thread(new Worker(socket)).start(); } } catch (Exception e) { e.printStackTrace(); } } private static class Worker implements Runnable{ private Socket socket; public Worker(Socket socket) { this.socket = socket; } @Override public void run() { try { System.out.println(\u0026#34;服务人员已启动\u0026#34;); InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); DataOutputStream dos = new DataOutputStream(outputStream); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); while (true) { String strWord = bufferedReader.readLine(); System.out.println(\u0026#34;client said:\u0026#34; + strWord + \u0026#34;:\u0026#34; + strWord.length()); if (strWord.equalsIgnoreCase(\u0026#34;quit\u0026#34;)) { break; } String strEcho = strWord + \u0026#34;666\u0026#34;; System.out.println(\u0026#34;server said:\u0026#34; + strWord + \u0026#34;---------\u0026gt;\u0026#34; + strEcho); dos.writeBytes(strWord + \u0026#34;---------\u0026gt;\u0026#34; +strEcho+ System.getProperty(\u0026#34;line.separator\u0026#34;)); } bufferedReader.close(); dos.close(); } catch (Exception e) { e.printStackTrace(); } } } }   Client:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  package JavaLearning_Advanced.TCP; import java.io.*; import java.net.InetAddress; import java.net.Socket; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 11:47 */ public class TcpClient { public static void main(String[] args) { try { Socket socket = new Socket(InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;), 8001); // 同一个通道，服务端输出流就是客户端的输入流，服务端的输入流，就是客户端的输出流  InputStream inputStream = socket.getInputStream();//开启通道的输入流  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); OutputStream outputStream = socket.getOutputStream();//开启通道的输出流  DataOutputStream dataOutputStream = new DataOutputStream(outputStream); BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in)); while (true) { String strWord = brKey.readLine(); if (strWord.equalsIgnoreCase(\u0026#34;quit\u0026#34;)) { break; } else { System.out.println(\u0026#34;i want to sent \u0026#34;+strWord); // outputStream.write(strWord.getBytes(), 0, strWord.length());//可以这么写  dataOutputStream.writeBytes(strWord+System.getProperty(\u0026#34;line.separator\u0026#34;)); System.out.println(\u0026#34;server said\u0026#34;+bufferedReader.readLine()); } } dataOutputStream.close(); bufferedReader.close(); } catch (Exception e) { e.printStackTrace(); } } }   HTTP  在浏览器输入URL地址 浏览器将连接到远程服务器（IP=Port(80)） 请求下载一个HTML文件下来，放到本地临时文件夹中 在浏览器显示出来  实例  URLConnection  获取资源的连接器 根据URL的openConnection()方法获得URLConnection connect方法，建立和资源的联系通道 getInputStream方法，获取资源的内容    get:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  package JavaLearning_Advanced.HTTP; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.URL; import java.net.URLConnection; import java.util.List; import java.util.Map; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 14:14 */ public class URLConnectionGet { public static void main(String[] args) { try { String urlName = \u0026#34;http://www.baidu.com\u0026#34;; URL url = new URL(urlName); URLConnection connection = url.openConnection(); connection.connect(); //打印Http的头部信息  Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; headers = connection.getHeaderFields(); for (Map.Entry\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; entry : headers.entrySet()) { String key = entry.getKey(); for (String value : entry.getValue()) { System.out.println(key + \u0026#34;:\u0026#34; + value); } } //输出将要收到的内容属性信息  System.out.println(\u0026#34;-------------------\u0026#34;); System.out.println(\u0026#34;getContentType\u0026#34; + connection.getContentType()); System.out.println(\u0026#34;getContentLength\u0026#34; + connection.getContentLength()); System.out.println(\u0026#34;getContentEncoding\u0026#34; + connection.getContentEncoding()); System.out.println(\u0026#34;getDate\u0026#34; + connection.getDate()); System.out.println(\u0026#34;getExpiration\u0026#34; + connection.getExpiration()); System.out.println(\u0026#34;getLastModified\u0026#34; + connection.getLastModified()); System.out.println(\u0026#34;-------------------\u0026#34;); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(),\u0026#34;UTF-8\u0026#34;)); //输出收到的内容  String line = \u0026#34;\u0026#34;; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } }   Post:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  package JavaLearning_Advanced.HTTP; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.net.*; import java.util.HashMap; import java.util.Map; import java.util.Scanner; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 14:42 */ public class URLConnectionPost { public static void main(String[] args) throws IOException { String url = \u0026#34;https://www.usps.com/go/ZipLookupAction.action\u0026#34;; Object userAgent = \u0026#34;Httpie/0.9.2\u0026#34;; Object redirects = \u0026#34;1\u0026#34;; CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL)); Map\u0026lt;String, String\u0026gt; params = new HashMap\u0026lt;String, String\u0026gt;(); params.put(\u0026#34;tAddress\u0026#34;, \u0026#34;1 Market Street\u0026#34;); params.put(\u0026#34;tCity\u0026#34;, \u0026#34;San Francisco\u0026#34;); params.put(\u0026#34;sState\u0026#34;, \u0026#34;CA\u0026#34;); String result = doPost(new URL(url), params, userAgent == null ? null : userAgent.toString(), redirects == null ? -1 : Integer.parseInt(redirects.toString())); System.out.println(result); } private static String doPost(URL url, Map\u0026lt;String, String\u0026gt; nameValueParis, String userAgent, int redirects) throws IOException { HttpURLConnection connection = (HttpURLConnection) url.openConnection(); if (userAgent != null) { connection.setRequestProperty(\u0026#34;User-Agent\u0026#34;, userAgent); } if (redirects \u0026gt;= 0) { connection.setInstanceFollowRedirects(false); connection.setDoOutput(true); } //输出请求的参数  try (PrintWriter out = new PrintWriter(connection.getOutputStream())) { boolean first = true; for (Map.Entry\u0026lt;String, String\u0026gt; pair : nameValueParis.entrySet()) { //参数必须这样拼接a=1\u0026amp;b=2\u0026amp;c=3  if (first) { first = false; } else { out.println(\u0026#39;\u0026amp;\u0026#39;); } String name = pair.getKey(); String value = pair.getValue(); out.print(name); out.print(\u0026#39;=\u0026#39;); out.print(URLEncoder.encode(value, \u0026#34;UTF-8\u0026#34;)); } String encoding = connection.getContentEncoding(); if (encoding == null) { encoding = \u0026#34;UTF-8\u0026#34;; } if (redirects \u0026gt; 0) { int responseCode = connection.getResponseCode(); System.out.println(\u0026#34;responseCode:\u0026#34; + responseCode); if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) { String location = connection.getHeaderField(\u0026#34;Location\u0026#34;); if (location != null) { URL base = connection.getURL(); connection.disconnect(); return doPost(new URL(base, location), nameValueParis, userAgent, redirects - 1); } } } else if (redirects == 0) { throw new IOException(\u0026#34;too many redirects\u0026#34;); } //获取html内容  StringBuilder response = new StringBuilder(); try (Scanner in = new Scanner(connection.getInputStream(), encoding)) { while (in.hasNextLine()) { response.append(in.nextLine()); response.append(\u0026#34;\\n\u0026#34;); } } catch (IOException e) { InputStream err = connection.getErrorStream(); if (err == null) { throw e; } try (Scanner in = new Scanner(err)) { response.append(in.nextLine()); response.append(\u0026#34;\\n\u0026#34;); } } return response.toString(); } } }   JDK HttpClient (JDK9新增，JDK10更新，JDK11正式发布)  java.net.http包 取代URLConnection 支持HTTP/1.1和HTTP/2 实现大部分HTTP方法 主要类  HttpClient HttpRequest HttpResponse    Get:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package JavaLearning_Advanced.HTTP.HttpClient; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 15:38 */ public class JDKHttpClientGet { public static void main(String[] args) { doGet(); } private static void doGet() { try { HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder(URI.create(\u0026#34;http://www.baidu.com\u0026#34;)).build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); } catch (Exception e) { e.printStackTrace(); } } }   Post:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package JavaLearning_Advanced.HTTP.HttpClient; import java.net.URI; import java.net.URLEncoder; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 15:43 */ public class JDKHttpClientPost { public static void main(String[] args) { doPost(); } private static void doPost() { try { HttpClient client = HttpClient.newBuilder().build(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(\u0026#34;https://zh-tools.usps.com/zip-code-lookup.htm?byaddress\u0026#34;)) .header(\u0026#34;User-Agent\u0026#34;, \u0026#34;HTTPie/0.9.2\u0026#34;) .header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded;charset=utf-8\u0026#34;) .POST(HttpRequest.BodyPublishers.ofString( \u0026#34;tAdress=\u0026#34; + URLEncoder.encode(\u0026#34;1 Market Street\u0026#34;, \u0026#34;UTF-8\u0026#34;) + \u0026#34;tCity=\u0026#34;+ URLEncoder.encode(\u0026#34;San Francisco\u0026#34;, \u0026#34;UTF-8\u0026#34;) + \u0026#34;sState=\u0026#34;+ \u0026#34;CA\u0026#34;) ).build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.statusCode()); System.out.println(response.headers()); System.out.println(response.body().toString()); } catch (Exception e) { e.printStackTrace(); } } }   HttpComponent Get:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package JavaLearning_Advanced.HTTP.HttpComponet; import org.apache.http.HttpResponse; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 16:53 */ public class HttpComponentsGet { public static void main(String[] args) { CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(5000)//设置超时时间  .setConnectionRequestTimeout(5000)//设置请求超时时间  .setSocketTimeout(5000) .setRedirectsEnabled(true)//默认允许自动重定向  .build(); HttpGet httpGet = new HttpGet(\u0026#34;http://www.baidu.com\u0026#34;); httpGet.setConfig(requestConfig); String strResult = \u0026#34;\u0026#34;; try { HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) { strResult = EntityUtils.toString(httpResponse.getEntity(),\u0026#34;UTF-8\u0026#34;);//获得返回结果  System.out.println(strResult); } } catch (Exception e) { e.printStackTrace(); } } }   Post;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  package JavaLearning_Advanced.HTTP.HttpComponet; import org.apache.http.HttpResponse; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpPost; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.impl.client.LaxRedirectStrategy; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.ArrayList; import java.util.List; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 17:03 */ public class HttpComponentsPost { public static void main(String[] args) throws UnsupportedEncodingException { //获取可关闭的httpClient  //CloseableHttpClient  CloseableHttpClient httpClient = HttpClientBuilder.create().setRedirectStrategy(new LaxRedirectStrategy()).build(); //配置超时时间  RequestConfig requestConfig = RequestConfig.custom() .setSocketTimeout(10000) .setConnectTimeout(10000) .setConnectionRequestTimeout(10000) .setRedirectsEnabled(false).build(); HttpPost httpPost = new HttpPost(\u0026#34;https://zh-tools.usps.com/zip-code-lookup.htm?byaddress\u0026#34;); //配置post参数  List\u0026lt;BasicNameValuePair\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new BasicNameValuePair(\u0026#34;tAdress\u0026#34;, URLEncoder.encode(\u0026#34;1 Market Street\u0026#34;, \u0026#34;UTF-8\u0026#34;)));//请求参数  list.add(new BasicNameValuePair(\u0026#34;tCity\u0026#34;, URLEncoder.encode(\u0026#34;San Francisco\u0026#34;, \u0026#34;UTF-8\u0026#34;)));//请求参数  list.add(new BasicNameValuePair(\u0026#34;sState\u0026#34;, \u0026#34;CA\u0026#34;));//请求参数  try { UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, \u0026#34;UTF-8\u0026#34;); // 设置post请求参数  httpPost.setEntity(entity); httpPost.setHeader(\u0026#34;User-Agent\u0026#34;, \u0026#34;HTTPie/0.9.2\u0026#34;); HttpResponse httpResponse = httpClient.execute(httpPost); String result = \u0026#34;\u0026#34;; if (httpResponse != null) { int statusCode = httpResponse.getStatusLine().getStatusCode(); System.out.println(statusCode); if (statusCode == 200) { result = EntityUtils.toString(httpResponse.getEntity()); } else { result = \u0026#34;ERROR Response\u0026#34; + httpResponse.getStatusLine().toString(); } } else { } System.out.println(result); } catch (Exception e) { e.printStackTrace(); }finally { try { if (httpClient != null) { httpClient.close(); } } catch (Exception e) { e.printStackTrace(); } } } }   Java调用其他语言 Python  解释性脚本语言 目前版本3 Jython  将Python源码编译成JVM字节码,由JVM执行对应的字节码,可以很好的与JVM继承 不是Java与Python的连接器    ","permalink":"http://blog.oxide.ink/posts/java/java%E7%AC%94%E8%AE%B002/","summary":"Maven Junit 测试   单元测试：对软件中最小可测试单元进行检查和验证，通常是一个函数/方法（属于白盒测试）\n 集成测试： 将多个单元相互作用，形成一个整体，对整体协调性进行测试    白盒测试： 全面了解程序内部逻辑结构，对所有的逻辑路径都进行测试，一般由程序员完成\n 黑盒测试：又名功能测试，将程序看作不可打开的盒子，一般由独立使用者完成    自动测试：用程序批量、反复的测试程序，并可自动检查程序结果是否满足预定的要求\n 手动测试：手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求    回归测试：修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误\n  深入学习：软件测试-基于问题驱动模式 朱少民\n  Junit   import static 导入该包内的所有静态方法，使用时可不加类名\n  Triangle\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package JavaLearning_Advanced.","title":"Java笔记02"},{"content":"语法糖 Syntactic sugar jdk版本  编译级别 兼容级别  编译后高版本可以运行低版本字节码 反之不行    for/for-each  for  for(int i=0;i\u0026lt;nums.leng;i++) 可以删除元素   for-each  for(String i:hs) 5.0开始存在 语法简洁 不能删除元素 只能正向遍历 不能同时遍历两个集合    enum类型  java5 推出 enum有多少个值就有几个实例对象 可以添加属性/构造函数/方法 构造函数只能是package-private(default)或者private,内部调用 enum类型  所有enum类型都是Enum的子类,也继承了相应方法 ordinal()返回枚举所在的索引位置,从0开始 compareTo()比较两个枚举值的索引位置大小 toString()返回枚举值的字符串标识 valueOf()将字符串初始化为枚举对象 values() 返回所有的枚举值    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package notes.Java.Java_Final.suger; /** * @Description: * @author: Anhlaidh * @date: 2020-07-05 21:31 */ public class testEnum { public static void main(String[] args) { Fruit a1 = Fruit.APPLE; System.out.println(\u0026#34;Price is\u0026#34; + a1.price); System.out.println(\u0026#34;====================\u0026#34;); Day d1 = Day.MONDAY; Day d2 = Enum.valueOf(Day.class, \u0026#34;MONDAY\u0026#34;); System.out.println(d1 == d2); Day d3 = Enum.valueOf(Day.class, \u0026#34;TUESDAY\u0026#34;); System.out.println(d1.compareTo(d3)); //遍历  for (Day item : Day.values()) { //输出索引值  System.out.println(item.toString() + \u0026#34;,\u0026#34; + item.ordinal()); } } enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } enum Fruit { APPLE(10), ORANGE(8); private int price; Fruit(int price) { this.price = price; } public int getPrice() { return price; } } }   不定项参数  JDK5提供了不定参数(可变参数)功能  类型后面加3个点,入int\u0026hellip;/double\u0026hellip;/String\u0026hellip; 可变参数,本质上是一个数组 一个方法只能由一个不定项参数,且位于参数列表的最后 重载的优先级规则1:固定参数的方法,比可变参数优先级更高 重载的优先级规则2:调用语句,同时与两个带可变参数的方法匹配,则报错    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package notes.Java.Java_Final.suger; /** * @Description: 可变参数 * @author: Anhlaidh * @date: 2020-07-05 21:46 */ public class testVariableArgument { public static void main(String[] args) { print(); print(\u0026#34;aaa\u0026#34;); print(\u0026#34;aaa\u0026#34;,\u0026#34;bbb\u0026#34;); print(\u0026#34;aaa\u0026#34;,\u0026#34;bbb\u0026#34;,\u0026#34;ccc\u0026#34;); } private static void print(String... args) { System.out.println(args.length); for (String arg : args) { System.out.println(arg); } } //当只有一个参数时,本方法优先级更高  private static void print(String s) { System.out.println(\u0026#34;优先级高的方法\u0026#34;); } //错误:一个方法不可以有多个可变参数 // public static void print(String... args, int... irgs) { // // }  //调用语句,同时与两个带可变参数的方法匹配,则报错 // private static void print(String s1, String... args) { // // } }   静态导入  import static 导入类中的静态方法  使用时可以直接写方法名,不写类名   少用* 如果重名需要补充类名  自动装箱和拆箱  JDK5开始引入,简化基本类型和对象转化的写法 Integer\u0026ndash;int\u0026hellip; 编译器的工作,不是jvm的工作 ==:基本类型是内容相同,对象是指针是否相同 基本类型没有空值,对象有null 基础数据类型与封装类型进行 ==,+,-,*,/操作运算,会将封装类进行拆箱,对基础数据类型进行运算 谨慎使用多个非同类的数值类进行运算  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package notes.Java.Java_Final.suger; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 15:31 */ public class testNumber { public static void main(String[] args) { Integer a1 = 1000; int a2 = 1000; Integer a3 = 2000; Long a4 = 2000L; long a5 = 2000L; System.out.println(a1 == a2);//拆箱再进行数值比较  System.out.println(a3 == (a1 + a2));//拆箱再进行数值比较  System.out.println(a4 == (a1 + a2));//拆箱再进行数值比较  System.out.println(a5 == (a1 + a2));//拆箱再进行数值比较  System.out.println(a3.equals(a1 + a2));//equals要求同类且内容相同  System.out.println(a4.equals(a1 + a2));//equals要求同类且内容相同  System.out.println(a4.equals((long)(a1 + a2)));//equals要求同类,且值相同 // System.out.println(a3 == a4);//不同类型不能比较  } }   多异常并列  多个异常用 | 隔开 多个异常之间不能有直接/简介继承关系  数字增强  数字可以二进制赋值  避免二进制计算 byte/short/int/long   数值字面量中可以使用下划线  增加数字的可读性和纠错功能 short/int/long/float/double 下划线只能出现在数字中间    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  package notes.Java.Java_Final.suger; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 15:40 */ public class testNumber2 { public static void main(String[] args) { test1(); test2(); } private static void test2() { long a1 = 9999999999L; long a2 = 9_999_999_999L; int a3 = 0b0111_1011_0001;//二进制0b开头  int a4 = 02_014;//8进制,0开头  int a5 = 123__45;//可以多个下划线  int a6 = 0x7_B_1;//十六进制  float a7 = 3.56_78f;//float  double a8 = 1.3_45_67;//double  // int b1 = 0b_123_4; _必须在数字之间 // int b2 = 0123_4_;不能在末尾 // int b3 = _123;不能在开头 // int b4 = 0_ x_123;不能拆开0x // int b5 = 0x_51;_必须在数字之间 // long b6 = 1000_L;_必须在数字之间 // float b7 = 1.34f _;_不能在末尾  } private static void test1() { byte a1 = (byte) 0b00100001; short a2 = (short) 0b001010100; int a3 = 0b0010101010; int a4 = 0b101; int a5 = 0B101;//B可以大小写  long a6 = 0b1010101010010010010101010L; final int[] s1 = {0b101010, 0b101101, 0b1101111, 0b1111}; System.out.println(a5); System.out.println(Integer.toBinaryString(a5)); } }   接口方法   java8 接口默认方法/静态方法(都带具体实现)\n  默认方法\n 规则  以default关键字标注,其他定义和普通函数一样 规则1:默认方法 不能重写 Object中的方法 规则2:实现类可以继承/重写父接口默认方法 规则3:接口可以继承/重写父接口的默认方法 规则4:当父类和父接口都有(同名同参数) 默认方法,子类继承父类的默认方法,这样可以兼容JDK7及以前的代码 规则5:子类实现了两个接口(均有同名同参数的默认方法),那么编译失败,必须在子类中重写这个default方法      静态方法\n 属于本接口,不属于子类/子接口 子类(子接口)没有继承该静态方法,只能通过所在的接口名来调用 -java9 私有方法 解决多个默认方法/静态方法的内容重复问题 私有方法属于本接口,只在本接口内使用,不属于子类/子接口 子类(子接口)没有继承该私有方法,也无法调用 静态私有方法可以被静态/默认方法调用,非静态私有方法被默认方法调用    接口,抽象类\n 相同点  都是抽象的,都不能被实例化,即不能被new 都可以有实现方法 都可以不需要继承者实现所有方法   不同点(java12之前)  抽象类最多只能继承一个,接口可以实现多个 接口的变量默认是public static final,且必须有初值,子类不能修改,而抽象类的变量默认是default,子类可以继承修改 接口没有构造函数,抽象类有构造函数 接口没有main函数,抽象类可以有main函数 接口有public/default/private的方法,抽象类只有public/private/protected/不写关键字的(default)的方法      try-with-resource  jdk7提供try-with-resource  资源要求定义在try中,若已经定义在外面,则需要一个本地变量   jdk9不在要求定义临时变量,可以直接使用外部资源变量 原理  资源对象必须实现AutoCloseable接口,即close方法,jdk自带    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package notes.Java.Java_Final.suger.testTryWithResource; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 16:58 */ public class test { public static void main(String[] args) { try (MyConnection connection = new MyConnection()) { connection.sendData(); } catch (Exception e) { e.printStackTrace(); } } } class MyConnection implements AutoCloseable { public void sendData() throws Exception { System.out.println(\u0026#34;Send Data...\u0026#34;); } @Override public void close() throws Exception { System.out.println(\u0026#34;Close...\u0026#34;); } }   ResourceBundle文件加载  JDK9及以后,ResourceBundle默认以UTF-8方式加载  var类型  java10推出var  避免信息冗余 对齐了变量名 更容易阅读 本质上还是强类型语言,编译器负责推断类型,并写入字节码文件,因此推断后不能更改   var的限制  可以用在局部变量中,非类成员变量 可以在for/for-each中 声明时必须初始化 不能用在方法(形式)参数和返回类型 大面积滥用会使代码整体阅读性变差 var 只在编译时起作用,没有在字节码中引入新的内容,也没有专门的jvm指令处理var    switch  支持的类型:byte/Byte,short/Short,int/Integer,char/Character,String(7.0),Enum(5.0) 仍不支持long/float/double 多分支合并  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package notes.Java.Java_Final.suger; import java.util.Scanner; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 17:16 */ public class testSwitch { public static void main(String[] args) { // test1();  test2(); } private static void test2() { Scanner scanner = new Scanner(System.in); int num= scanner.nextInt(); int days = switch (num){ case 1,3,5,7,8,10,12 -\u0026gt; 31; case 4,6,9,11 -\u0026gt; 30; default -\u0026gt; 28; }; System.out.println(days); } private static void test1() { Scanner scanner = new Scanner(System.in); String month = scanner.next(); int result=-1; switch (month) { case \u0026#34;Jan\u0026#34;,\u0026#34;Mar\u0026#34;,\u0026#34;May\u0026#34;,\u0026#34;July\u0026#34;,\u0026#34;Aug\u0026#34;,\u0026#34;Oct\u0026#34;,\u0026#34;Dec\u0026#34; -\u0026gt; result = 31; case \u0026#34;Apr\u0026#34;,\u0026#34;June\u0026#34;,\u0026#34;Sep\u0026#34;,\u0026#34;Nov\u0026#34; -\u0026gt; result = 30; case \u0026#34;Feb\u0026#34; -\u0026gt; result = 28; default -\u0026gt; result = -1; } System.out.println(result); } }   反射 reflection  定义  程序可以访问,检测和修改它本身状态或行为的能力,即自描述和自控制 可以在运行时加载,探知,和使用编译期间完全未知的类 给java插上动态语言特性的翅膀,弥补强类型语言的不足 java.lan.reflect包,在java2存在,java5完善   功能  在运行中分析类的能力 在运行中查看和操作对象  基于反射自由创建对象 反射构建出无法直接访问的类 set或者get到无法访问的成员变量 调用不可访问的方法   实现通用的数组操作代码 类似函数指针的功能   创建对象  静态编码\u0026amp;编译(new) 克隆(clone()),继承Cloneable,速度快 序列化serialization,反序列化deserialization继承Serializable接口    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package notes.Java.Java_Final.Reflect; import java.io.*; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 18:05 */ public class testSerialization { public static void main(String[] args) throws IOException, ClassNotFoundException { A obj1 = new A(); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;data.obj\u0026#34;)); out.writeObject(obj1); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;data.obj\u0026#34;)); A obj2 = (A) in.readObject(); in.close(); obj2.hello(); } } class A implements Serializable { private static final long serialVersionUID = 1L; public void hello() { System.out.println(\u0026#34;hello from A\u0026#34;); } } ```     反射 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package notes.Java.Java_Final.Reflect; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 19:32 */ public class testNewInstance { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException { Object obj1 = Class.forName(\u0026#34;notes.Java.Java_Final.Reflect.A\u0026#34;).newInstance(); Method m = Class.forName(\u0026#34;notes.Java.Java_Final.Reflect.A\u0026#34;).getMethod(\u0026#34;hello\u0026#34;); m.invoke(obj1);//获取方法  A obj2 = (A) Class.forName(\u0026#34;notes.Java.Java_Final.Reflect.A\u0026#34;).newInstance(); Constructor\u0026lt;A\u0026gt; constructor = A.class.getConstructor();//构造函数  A obj3 = constructor.newInstance(); obj3.hello(); } }      内容  Class:类型标识   JVM为每个对象都保留其类型标识信息(Runtime Type Identification) 成员变量,方法,构造函数,修饰符,包,父类,父接口\u0026hellip; 成员变量Field 方法Method 构造函数Constructor    编译器API  对 .java文件即时编译 对字符串即时编译 监听在编译过程中产生的警告和错误 在代码中运行编译器(并非:Runtime命令调用javac命令)  JavaCompiler   1.6推出\n  可用在程序文件中的Java编译器接口(代替javac.exe)\n  在程序中编译java文件,产生class文件\n  run方法(继承自java.tools.Tools):较简单,可以编译java源文件,生成class文件,但不能指定输出 路径,监控错误信息,调用后就在源码所在目录生成class文件\n  getTask方法:更强大的功能,可以编译java源文件,包括在内存中的java文件(字符串),生成class文件\n  编译文件:\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  package notes.Java.Java_Final.JavaCompiler; import javax.tools.JavaCompiler; import javax.tools.ToolProvider; import java.io.ByteArrayOutputStream; import java.nio.charset.Charset; /** * @Description: * @author: Anhlaidh * @date: 2020-08-04 14:30 */ public class SimpleJavaCompiler { public static void main(String[] args) { // successCompile();  failCompile(); } private static void failCompile() { ByteArrayOutputStream err = new ByteArrayOutputStream(); JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, err, \u0026#34;./aaa.java\u0026#34;); if (0 == result) { System.out.println(\u0026#34;Success\u0026#34;); } else { System.out.println(\u0026#34;Fail\u0026#34;); System.out.println(new String(err.toByteArray(), Charset.defaultCharset()) ); } } private static void successCompile() { JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); /** * 第一个参数:输入流,null表示默认使用system.in * 第二个参数:输出流,null标识默认使用system.out * 第三个参数:错误流,null标识默认使用system.err * 第四个参数:String...需要编译的文件名 * 返回值:0表示成功,其他错误 */ int result = compiler.run(null, null, null, \u0026#34;G:\\\\Coding\\\\src\\\\main\\\\java\\\\notes.Java\\\\Java_Final\\\\API\\\\hello1.java\u0026#34;,\u0026#34;G:\\\\Coding\\\\src\\\\main\\\\java\\\\notes.Java\\\\Java_Final\\\\API\\\\hello2.java\u0026#34;); System.out.println(0 == result ? \u0026#34;Success\u0026#34; : \u0026#34;Fail\u0026#34;); } }    编译字符串  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  package notes.Java.Java_Final.JavaCompiler; import javax.tools.*; import java.io.File; import java.lang.reflect.Method; import java.net.URISyntaxException; import java.net.URL; import java.nio.charset.Charset; import java.util.Arrays; /** * @Description: * @author: Anhlaidh * @date: 2020-08-04 14:46 */ public class JavaCompilerTask { public static void main(String[] args) { compilerJavaFromString(); // System.out.println(\u0026#34;hello world\u0026#34;);  } private static void compilerJavaFromString() { StringBuffer stringBuffer = new StringBuffer(); String className = \u0026#34;Hello\u0026#34;; stringBuffer.append(\u0026#34;public class \u0026#34; + className + \u0026#34;{\u0026#34;); stringBuffer.append(\u0026#34; public static void main(String[] args) {\u0026#34;); stringBuffer.append(\u0026#34; System.out.println(\\\u0026#34;hello world\\\u0026#34;);\\n\u0026#34;); stringBuffer.append(\u0026#34;}\\n\u0026#34;); stringBuffer.append(\u0026#34;}\\n\u0026#34;); Class\u0026lt;?\u0026gt; c = compiler(className, stringBuffer.toString()); try { //生成对象  Object obj = c.newInstance(); Method m = c.getMethod(\u0026#34;main\u0026#34;, String[].class); m.invoke(obj, new Object[]{new String[]{}}); } catch (Exception e) { e.printStackTrace(); } } private static Class\u0026lt;?\u0026gt; compiler(String className, String javaCode) { JavaSourceFromString srcObject = new JavaSourceFromString(className, javaCode); System.out.println(srcObject.getCode()); Iterable\u0026lt;? extends JavaFileObject\u0026gt; fileObjects = Arrays.asList(srcObject); JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, Charset.defaultCharset()); DiagnosticCollector\u0026lt;JavaFileObject\u0026gt; diagnosticCollector = new DiagnosticCollector\u0026lt;\u0026gt;(); //设置编译的输出目录,并包装在options中  String flag = \u0026#34;-d\u0026#34;; String outDir = \u0026#34;\u0026#34;; try { URL resource = Thread.currentThread().getContextClassLoader().getResource(\u0026#34;\u0026#34;); File classpath = new File(resource.toURI()); outDir = classpath.getAbsolutePath() + File.separator; System.out.println(outDir); } catch (URISyntaxException e) { e.printStackTrace(); } Iterable\u0026lt;String\u0026gt; options = Arrays.asList(flag, outDir); /** * JavaCompiler.getTask方法:以future的任务形式(多线程)来执行编译任务 * 第一个参数:额外输出流,null表示默认使用System.err * 第二个参数:文件管理器,null表示编译器默认方法来报告诊断信息 * 第三个参数:诊断监听器,null表示使用编译器默认方法来报告诊断信息 * 第四个参数:编译器参数,null表示无参数 * 第五个参数:需要经过annotation处理的类名,null表示没有类需要annotation * 第六个参数,待编译的类 */ JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnosticCollector, options, null, fileObjects); //等待编译结束  boolean result = task.call(); if (result == true) { try { return Class.forName(className); } catch (ClassNotFoundException e) { e.printStackTrace(); } } else { for (Diagnostic diagnostic : diagnosticCollector.getDiagnostics()) { System.out.println(\u0026#34;Error on line:\u0026#34; + diagnostic.getLineNumber() + \u0026#34;;URI\u0026#34; + diagnostic.getSource().toString()); } } return null; } }    其中的JavaSourceFromString 类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package notes.Java.Java_Final.JavaCompiler; import javax.tools.SimpleJavaFileObject; import java.io.IOException; import java.net.URI; /** * @Description: A file object used to represent source coming from a string * @author: Anhlaidh * @date: 2020-08-04 14:57 */ public class JavaSourceFromString extends SimpleJavaFileObject { private String code; public JavaSourceFromString(String name, String code) { super(URI.create(\u0026#34;string:///\u0026#34; + name.replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;) + Kind.SOURCE.extension),Kind.SOURCE); this.code = code; } @Override public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException { return code; } public String getCode() { return code; } }    notes.Java EE 的Jsp编译 在线编程观景 在线程序评判系统(OJ) 自动化的构建和测试工具  代理(Proxy):代替处理  代理模式  外界不用直接访问目标对象,而是访问代理对象,由代理对象再调用目标对象 代理对象中可以添加监控和审查处理 静态代理  代理对象持有目标对象的句柄 所有调用目标对象的方法,都调用代理对象的方法 对每个方法,需要静态编码(理解简单,但代码繁琐)   动态代理  对目标对象的方法每次被调用,进行动态拦截 方法重名会用第一个接口的方法     Main  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package notes.Java.Java_Final.Proxy.test; import java.lang.reflect.*; import java.util.Arrays; /** * @Description: * @author: Anhlaidh * @date: 2020-08-04 18:06 */ public class MultipleInterfacesProxyTest { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Cook cook = new CookImpl(); ClassLoader cl = MultipleInterfacesProxyTest.class.getClassLoader(); ProxyHandler handler = new ProxyHandler(cook); //生成代理类型  Class\u0026lt;?\u0026gt; proxyClass = Proxy.getProxyClass(cl, new Class\u0026lt;?\u0026gt;[]{Cook.class, Driver.class}); //生成代理对象  Object proxy = proxyClass.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{handler}); System.out.println(Proxy.isProxyClass(proxyClass)); Proxy p = (Proxy) proxy; System.out.println(Proxy.getInvocationHandler(proxy).getClass().getName()); System.out.println(\u0026#34;proxy类型\u0026#34; + proxyClass.getName()); //代理对象都继承于java.lang.reflect.Proxy,但是获取父类是Object而不是Proxy  Class father = proxyClass.getSuperclass(); System.out.println(\u0026#34;proxy的父类类型:\u0026#34; + father.getName()); Class[] cs = proxy.getClass().getInterfaces(); for (Class c : cs) { System.out.println(\u0026#34;proxy的父接口类型\u0026#34; + c.getName()); } System.out.println(\u0026#34;===============\u0026#34;); Method[] ms = proxy.getClass().getMethods(); for (Method m : ms) { System.out.println(\u0026#34;调用方法\u0026#34; + m.getName() + \u0026#34;参数为\u0026#34; + Arrays.deepToString(m.getParameters())); } System.out.println(\u0026#34;===============\u0026#34;); Cook c = (Cook) proxy; c.doWork(); Driver d = (Driver) proxy; d.doWork(); } }    Handler  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package notes.Java.Java_Final.Proxy.test; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Arrays; /** * @Description: * @author: Anhlaidh * @date: 2020-08-04 18:03 */ public class ProxyHandler implements InvocationHandler { private Cook cook; public ProxyHandler(Cook cook) { this.cook = cook; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;proxy类型\u0026#34; + proxy.getClass().getName()); System.out.println(\u0026#34;调用方法\u0026#34; + method + \u0026#34;;参数为\u0026#34; + Arrays.deepToString(args)); Object result = method.invoke(cook, args); return result; } }   AOP(Aspect Oriented Programming)  面向对象: 将需求功能划分为不同的,独立,分装良好的类,并让他们通过继承和多态实现相同和不同行为 面向切面: 将通用需求功能从众多类中分离出来,使得很多类共享一个行为,一旦发生变化,不必修改很多类,而只修改这个行为即可  面向切面编程  一个概念/规范,没有限定语言 不是取代OOP编程,而是OOP的补充,和数据库的触发器有点相似 主要内容  Aspect:配置文件,包括一些Pointcut和响应的Advice JointPoint:在程序中明确定义的点,如方法调用,对类成员访问等 PointCut: 一组JointPoint,可以哦通过逻辑关系/通配符/正则等组合起来,定义了响应advice将要发生的地方 Advice:定义了在pointcut处要发生的动作,通过before/after/around来关联 weaving:advice代码在具体jointPoint的关联方式    注解Annotation  JDK1.5引入 位于源码中(代码/注释/注解),使用其他工具进行处理的标签 注解用来修饰程序的元素,但不会对修饰的对象有直接的影响 只有通过某种配套的工具才会对注解信息进行访问和处理 主要用途  提供信息给编译器/IDE工具 可用于其他工具来产生额外的代码/配置文件等 有一些注解可在程序运行时访问,增加程序动态性   @SuppressWarning  不同jdk 不同,javac -X可查看    自定义注解  注解可以包括的类型  8种基本类型 String Class enum 注解类型 由前面类型组成的数组    1 2 3 4 5 6 7 8 9 10 11 12 13 14  package notes.Java.Java_Final.Annotation; public @interface BugReport { enum Status {UNCONFIRMED,CONFIRMED,FIXED, NOTABUG}; boolean showStopper() default true; String assignedTo() default \u0026#34;[notes]\u0026#34;; Status status() default Status.UNCONFIRMED; String[] reportedBy(); }    注解使用的位置(@Target) @Retention(RetentionPolicy.RUNTIME) 编译时也存在 自定义注解及其使用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package notes.Java.Java_Final.Annotation.Single; import java.lang.reflect.Method; /** * @Description: * @author: Anhlaidh * @date: 2020-08-05 17:18 */ public class Main { public static void main(String[] args) throws ClassNotFoundException { int passed = 0, failed = 0; String className = \u0026#34;notes.Java.Java_Final.Annotation.Single.Foo\u0026#34;; for (Method m : Class.forName(className).getMethods()) { if (m.isAnnotationPresent(SingleTest.class)) { System.out.println(m.getName()); SingleTest st = m.getAnnotation(SingleTest.class); try { m.invoke(null, st.value()); passed++; } catch (Throwable throwable) { System.out.printf(\u0026#34;Test %s failed %s %n\u0026#34;, m, throwable.getCause().getMessage()); failed++; } } } System.out.printf(\u0026#34;Success: %d ,Failed: %d %n\u0026#34;, passed, failed); } }   元注解   修饰注解的注解\n  @Target 设置目标范围\n 限定目标注解作用于什么位置@Target({ElementType.METHOD}) ElementType.ANNOTATION_TYPE(注:修饰注解) ElementType.CONSTRUCTOR ElementType.FIELD ElementType.LOCAL_VARIABLE ElementType.METHOD ElementType.PACKAGE ElementType.PARAMETER ElementType.TYPE(注:任何类型,即上面的类型都可以修饰)    @Retention 设置保持性\n 修饰其他注解的存在范围 Retention.SOURCE 注解仅存在源码,不在class文件 Retention.CLASS(默认的注解保留策略) 注解存在于.class文件,不能被JVM加载 Retention.RUNTIME这种策略下,注解可以被JVM运行时访问到,通常情况下,可以结合反射来做一些事情    @Inherited 注解继承\n 让一个类和他的子类都包含某个注解 普通的注解没有继承功能    @Repeatable 此注解可以重复修饰\n 自jdk1.8引入 表示被修饰的注解可以重复应用标注 需要定义注解和容器注解    @Document 文档\n 指明这个注解可以被javadoc工具解析,形成帮助文档    RUNTIME注解调用路线\n Java为注解产生一个代理类 这个代理类包括一个AnnotationInvocationHandler成员变量 AnnotationInvocationHandler有个Map的成员变量,用来存储所有的注解的属性赋值 在程序中,调用注解接口的方法,将会被代理类接管,然后根据方法名字,到Map里拿到对应的Value并返回    嵌套类 Nested classes  静态嵌套类: Static nested classes,即前面有static修饰符  层级和包围类(enclosing class)的成员变量/方法一样 静态嵌套类可以定义静态和非静态成员 第三方需要通过外部包围类才可以访问到静态嵌套类  Outer.Inner obj = new Outer.Inner();     非静态嵌套类: Non-static nested classes ,又名内部类,Inner classes  普通内部类(成员内部类)  非static的类,定义在某个类的成员变量位置 定义后在类里面均可以使用 在第三方类中,需要先创建外部包围类实例,才能创建内部类的实例,不允许单独的普通内部类对象存在  Outer.Inner obj = Outer.new Inner();     局部内部类(Local classes)  定义在代码块中的非静态的类,如方法,for循环,if语句等 定义后,即可创建对象使用 只能活在这个代码块中,代码块结束后,外界无法使用该类   匿名内部类(Anonymous class)  没有类名的内部类,必须继承一个父类/实现一个父接口 在实例化以后,迅速转型为父类/父接口 这种类型的对象,只能new一个对象,之后以对象名字操作 可在普通语句和成员变量赋值时使用内部类     为什么需要嵌套类  不同的访问权限要求,更细粒度的访问控制 简介,避免过多的类定义 语言设计过于复杂,较难学习和使用      位置 名字(编译后的class文件) 作用范围 基本信息 嵌套类内部的内容 可访问的外部包围类的内容 和外部类的关系     匿名内部类 成员变量或者成员方法内 外部类名+$+数字编号 跟随被复制变量的作用范围,外界无法访问 没有类名,没有构造函数没有static,private/default/protected/public修饰 不能带静态成员 访问外部的所有成员 在外部类对象内部   局部内部类 成员方法内 外部类名+$+序号+内部类名 所在的方法内外界无法访问 有类名,有构造函数没有static,private/default/protected/public修饰 不能带静态成员,除了常量 访问外部的所有成员 在外部类的对象内部   普通内部类 成员变量 外部类名+$+内部类名 包围类内可以访问,外界可以访问 有类名,有构造函数没有static,private/default/protected/public修饰 不能带静态成员,除了常量 访问外部的所有成员 外界可以new,但是必须依附于一个外部包围类对象   静态嵌套类 成员变量 外部类名+$+内部类名 包围类内部可以访问,外界可以访问 有类名,有构造函数有static,private/default/protected/public修饰 可以定义静态成员变量和方法 访问外部的所有静态成员 可以new,可独立进行工作     变量遮蔽:Shadowing  嵌套类变量和外部包围类的变量重名  以离得近作为优先原则 优先级高的变量回遮蔽优先级低的变量 外部包围类.this.变量名,可以访问到外部包围类的成员变量 静态嵌套类不能访问非静态变量 Java7及以前,匿名内部类和局部内部类只能访问外部包围类的final成员变量 Java8及以后,匿名内部类和局部内部类可以访问外部包围类的final成员变量和 事实意义上的final变量(effectively final,一个变量定值后,再也没有改过值)      Lambda表达式  参数,箭头,一个表达式 参数,箭头,{多个语句} 类似于匿名方法,一个没有名字的方法 参数,箭头,表达式语句 可以忽略写参数类型 坚决不声明返回值类型 没有public/protected/private/static/final等修饰符 单句表达式,将直接返回值,不用大括号 带return语句,算多句,必须用大括号  函数式接口  是一个接口,符合Java接口的定义 只包含一个抽象方法的接口 可以包含其他的default方法,static方法,private方法 由于只有一个未实现的方法,所以Lambda表达式可以自动填上这个尚未实现的方法 采用Lambda表达式,可以自动创建出一个(伪)嵌套类的对象(没有实际嵌套类class文件产生),然后使用, 比真正嵌套类更加轻量,更加简洁高效  1 2 3 4 5 6 7  package notes.Java.Java_Final.Lambda; @FunctionalInterface //标记为函数式接口 public interface StringChecker { public boolean test(String s); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package notes.Java.Java_Final.Lambda; /** * @Description: * @author: Anhlaidh * @date: 2020-08-06 21:38 */ public class Main { public static void main(String[] args) { String[] s = new String[]{\u0026#34;aaa\u0026#34;, \u0026#34;bbbb\u0026#34;, \u0026#34;cccccc\u0026#34;}; StringChecker eventLength = s1 -\u0026gt; { if (s1.length() % 2 == 0) { return true; } return false; }; for (String p : s) { if (eventLength.test(p)) { System.out.println(p); } } } }   系统自带的函数式接口    接口 参数 返回值 实例     Predicate T Boolean 接收一个参数,返回一个boolean   Consumer T void 接受一个参数,无返回   Function\u0026lt;T,R\u0026gt; T R 接受一个参数,返回一个值   Supplier None T 数据工厂    方法引用  Class::staticMethod  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package notes.Java.Java_Final.Lambda; /** * @Description: * @author: Anhlaidh * @date: 2020-08-06 22:26 */ public class method { public static void main(String[] args) { double a = -3.5; double b = worker(Math::abs, a); System.out.println(b); double c = worker(Math::floor, a); System.out.println(c); double d = worker((num -\u0026gt; (num % 10)), a); System.out.println(d); } public static double worker(NumFunction nf, double num) { return nf.calculate(num); } }    Class::instanceMethod  第一个参数将变成方法的执行体 String::compareToIgnoreCase等价于(x,y)-\u0026gt;x.compareToIgnoreCase(y)  1 2 3  String[] planets = new String[]{\u0026#34;DDD\u0026#34;,\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;}; Arrays.sort(planets, String::compareToIgnoreCase); System.out.println(Arrays.toString(planets));      object::instanceMethod  支持this::instanceMethod 支持super::instanceMethod   Class::new,调用某类构造函数,支持单个对象构建 Class[]::new,调用某类构造函数,支持数组对象构建 应用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package notes.Java.Java_Final.Lambda; import java.util.ArrayList; import java.util.Arrays; /** * @Description: * @author: Anhlaidh * @date: 2020-08-07 15:06 */ public class testIterable { public static void main(String[] args) { String[] p = new String[]{\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;}; ArrayList\u0026lt;String\u0026gt; pList = new ArrayList\u0026lt;String\u0026gt;(Arrays.asList(p)); for (String s : pList) { System.out.println(s); } pList.forEach(System.out::println); } }   流 stream  sequence of elements:一个流对外提供一个接口,可以访问到一串特定的数据,流不存储元素,但是可以根据需要进行计算转化 source:数据来源,如数据结构,数组,文件等 aggregate operation:聚合操作,流支持像SQL操作或者其他函数式语言的操作 如filter/map/reduce/find/match/sorted等 Stream流  pipelining:很多流操作也是返回一个流 Internal Iteration:流操作进行迭代,用户感知不到循环遍历    流的工作流程  流的创建   Collection接口的stream方法 Arrays.stream(数组) Stream.of()     empty() 空流      流的转换,将流转换为其他流的中间操作,可包括多个步骤(惰性操作) 流的计算结果,这个操作会强制执行之前的惰性操作,这个步骤以后,流就再也不用了  ","permalink":"http://blog.oxide.ink/posts/java/java%E7%AC%94%E8%AE%B003/","summary":"语法糖 Syntactic sugar jdk版本  编译级别 兼容级别  编译后高版本可以运行低版本字节码 反之不行    for/for-each  for  for(int i=0;i\u0026lt;nums.leng;i++) 可以删除元素   for-each  for(String i:hs) 5.0开始存在 语法简洁 不能删除元素 只能正向遍历 不能同时遍历两个集合    enum类型  java5 推出 enum有多少个值就有几个实例对象 可以添加属性/构造函数/方法 构造函数只能是package-private(default)或者private,内部调用 enum类型  所有enum类型都是Enum的子类,也继承了相应方法 ordinal()返回枚举所在的索引位置,从0开始 compareTo()比较两个枚举值的索引位置大小 toString()返回枚举值的字符串标识 valueOf()将字符串初始化为枚举对象 values() 返回所有的枚举值    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package notes.","title":"Java笔记03"},{"content":"哔哩哔哩视频   https://yyqx.online/posts/hugo博客latex渲染/)\n Mermaid sequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-John: Hello John, how are you?\rloop Healthcheck\rJohn-John: Fight against hypochondria\rend\rNote right of John: Rational thoughts prevail...\rJohn--Alice: Great!\rJohn-Bob: How about you?\rBob--John: Jolly good!\r\r Latex 行内样式：$x=2$\n代码块： $$ f(x)=\\int_{-\\infty}^\\infty\\widehat f\\xi,e^{2\\pi i\\xi x},d\\xi $$\n网易云音乐 单曲：  歌单：  图片: ","permalink":"http://blog.oxide.ink/posts/hugo-extend/","summary":"哔哩哔哩视频   https://yyqx.online/posts/hugo博客latex渲染/)\n Mermaid sequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-John: Hello John, how are you?\rloop Healthcheck\rJohn-John: Fight against hypochondria\rend\rNote right of John: Rational thoughts prevail...\rJohn--Alice: Great!\rJohn-Bob: How about you?\rBob--John: Jolly good!\r\r Latex 行内样式：$x=2$\n代码块： $$ f(x)=\\int_{-\\infty}^\\infty\\widehat f\\xi,e^{2\\pi i\\xi x},d\\xi $$\n网易云音乐 单曲：  歌单：  图片: ","title":"Markdown Extend"},{"content":"萝卜博客 https://radish.cloud\n","permalink":"http://blog.oxide.ink/links/","summary":"萝卜博客 https://radish.cloud","title":""},{"content":"概述  ES不等于搜索引擎 分布式的搜索,存储,数据分析引擎 优点:  面向开发者友好,屏蔽了Luncene的复杂特性,集群自动发现 自动维护数据在多个节点上的建立 帮我们做搜索请求的负载均衡 自动维护冗余副本,保证了部分节点宕机的情况下仍然不会有任何数据丢失 ES基于Lucene提供了很多高级功能:符合查询,聚合分析,基于地理位置 对于大公司,可以构建几百台服务器的大型分布式集群,处理PB级别数据 相遇传统数据库,提供了全文见检索,同义词处理,相关度排名,聚合分析以及海量数据的近实时(NTR)处理,这些传统数据库完全做不到   应用领域  搜索引擎 各大网站的用户行为日志(点击,浏览,收藏,评论) BI 数据分析 Github ELK (Elasticseach(数据存储) Logstash(日志采集) Kibana(可视化))    核心概念和原理  搜索  SQL 用了%不能用索引 -\u0026gt;性能差  like % 搜索时间复杂度O(n)   不能分词   倒排索引  分词 生成相关度 * 排序 空间换时间   数据结构  document List 关键词在每个doc中出现的次数 TF term frequency 词频 IDF inverse doc frequency 关键词在当前doc出现的次数 每个doc的长度 越长相关度越低 包含这个关键词的所有doc的平均长度     核心概念  集群:每个集群至少包含两个节点 Node:集群中的节点 一个节点不代表是一台机器 Filed: 一个数据字段,与index和type可以定位一个doc Document:ES最小的数据单元 Json Type:逻辑上的数据分类 Index:一类相同或者相似的doc 分片shard  一个index包含多个shard,默认5p,默认每个p分配一个r,p的数量在创建索引的时候设置,如果想修改,需要重建索引 每个shard都是一个lucene实例,有完整的创建索引的处理请求能力 ES会自动在nodes尚未我们zuoshard均衡 一个doc不可能同时存在于多个PShard,但是可以同时多个Rshard p和对应的r不能同时存在于同一个节点,所以最低的可用配置是两台节点,互为主备   横向扩容 Parimary Shared Replica Shard     容错  两台机子p0,p1,p2 r0,r1,r2 p挂掉之后r顶上 容错机制  master选举  findMaster  脑裂 可能会产生多个master节点   判断自己是否为master 广播/findMaster   replica容错 重启故障机 数据恢复  只拷贝新增数据 不是全量拷贝        使用  健康值检查  CRUD  Query String search 类似于Url挂参数搜索 Query DSL Query and filter  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  GET /_cat/health?v PUT /test_index?pretty GET _cat/indices DELETE /test_index?pretty PUT /product/_doc/1 { \u0026#34;name\u0026#34;:\u0026#34;xiaomi erji\u0026#34;, \u0026#34;desc\u0026#34;:\u0026#34;erji zhong de huangmenji\u0026#34;, \u0026#34;price\u0026#34;:1999, \u0026#34;tags\u0026#34;:[\u0026#34;low\u0026#34;,\u0026#34;bufangshui\u0026#34;,\u0026#34;yinzhicha\u0026#34;] } PUT /product/_doc/2 { \u0026#34;name\u0026#34;:\u0026#34;xiaomi shouji\u0026#34;, \u0026#34;desc\u0026#34;:\u0026#34;erji zhong de huangmenji\u0026#34;, \u0026#34;price\u0026#34;:2999, \u0026#34;tags\u0026#34;:[\u0026#34;low\u0026#34;,\u0026#34;bufangshui\u0026#34;,\u0026#34;yinzhicha\u0026#34;] } PUT /product/_doc/3 { \u0026#34;name\u0026#34;:\u0026#34;xiaomi nfc shouji\u0026#34;, \u0026#34;desc\u0026#34;:\u0026#34;erji zhong de huangmenji\u0026#34;, \u0026#34;price\u0026#34;:3999, \u0026#34;tags\u0026#34;:[\u0026#34;low\u0026#34;,\u0026#34;bufangshui\u0026#34;,\u0026#34;yinzhicha\u0026#34;] } PUT /product/_doc/4 { \u0026#34;name\u0026#34;:\u0026#34;xiaomi yinxiang\u0026#34;, \u0026#34;desc\u0026#34;:\u0026#34;erji zhong de huangmenji\u0026#34;, \u0026#34;price\u0026#34;:4999, \u0026#34;tags\u0026#34;:[\u0026#34;low\u0026#34;,\u0026#34;bufangshui\u0026#34;,\u0026#34;yinzhicha\u0026#34;] } GET /product/_doc/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;shouji xiaomi\u0026#34; } }, \u0026#34;sort\u0026#34;:[ {\u0026#34;price\u0026#34;:\u0026#34;desc\u0026#34;}] } POST /product/_doc/1/update { \u0026#34;doc\u0026#34;:[] } DELETE /product/_doc/1   ES分布式文档系统  实现高可用  ES在分配单个索引的分片时会将每个分片尽可能分配到更多的节点上  但是实际情况取决于集群拥有的分片和索引以及他们的大小,不一定总是能均匀的分布   ES不允许Primary与Replica放在同一个节点中,并且同一个节点不接受完全相同的两个Replica 同一个节点允许多个索引的分片同时存在   容错  向下兼容 自行恢复的能力   ESNode  默认配置 node.master=true node,data=true  Master:主节点,每个集群只有一个 专注于集群的管理 协调节点-\u0026gt;转发  尽量避免node.data = true   voting:投票节点  master宕机了投票选举master 数量等于数据节点 设置了Node.voting_only=true 即使node.master=true 也不会参选 voting_only仍然可以做数据节点(node.data=true)   coordinating:协调节点    node.master node.data node.voting_only 节点详情     true 尽量false false master节点 /候选节点,参选为master   false true true 投票节点,不仅投票,还存数据   false false true 不存数据的投票节点 -\u0026gt; 协调节点   false true false 数据节点,主要负责数据的查询以及增删改       投票选举master  集群节点数量一般是奇数个 投票节点与与数据节点数量相同  如果是偶数个,默认投票节点减少一个   步骤  寻找clusterStateVersion比自己高的节点,想起发送选票 如果clusterStateVersion一样,则在候选节点(包含当前节点)中选id最小的一个节点,向该节点发送选举投票 如果一个节点收到足够多的投票并且也向自己投票了,那么该节点成为master开始发布集群状态     脑裂问题  discovery.zen.minimum_master_nodes=N/2+1 小于等于两台机子的集群会产生脑裂    ES 查询语法   search\n timeout true/false(默认)  超过指定时间,停止查询,查到多少条返回多少条      Query String\n Url  GET /product/_search?from=0\u0026amp;size=2\u0026amp;sort=price:asc  取前两个 排序  加了排序之后没有相关度分数  因为加了排序之后score就没有意义了 score是null            QueryDSL 重点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171  GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } # get GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;nfc\u0026#34; } } } # sort GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;xiaomi\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;FIELD\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ] } # multi match 多字段查询一个关键词 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;nfc\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;name\u0026#34;,\u0026#34;desc\u0026#34;] } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34; } ] } # _source 指定返回字段 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;nfc\u0026#34; } }, \u0026#34;_source\u0026#34;: [\u0026#34;name\u0026#34;,\u0026#34;price\u0026#34;] } #分页 from size GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34; } ], \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 1 } # 全文检索 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;nfc\u0026#34; } } } # 分词器 GET /_analyze { \u0026#34;analyzer\u0026#34;:\u0026#34;standard\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;xiaomi nfc phone\u0026#34; } #短语搜索 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_phrase\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;xiaomi\u0026#34; } , \u0026#34;bool\u0026#34;: { } } } #query and filter GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ {\u0026#34;match\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;xiaomi\u0026#34;}}, {\u0026#34;match\u0026#34;: {\u0026#34;desc\u0026#34; \u0026#34;shouji\u0026#34;}}], \u0026#34;filter\u0026#34;: [ {\u0026#34;match_phrase\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;xiaomi\u0026#34;}}, {\u0026#34;range\u0026#34;:{\u0026#34;price\u0026#34;:{ \u0026#34;gte\u0026#34;:10,\u0026#34;lte\u0026#34;:20}}} ], \u0026#34;should\u0026#34;: [ {\u0026#34;range\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;gte\u0026#34;: 10, \u0026#34;lte\u0026#34;: 20 } }} ], \u0026#34;minimum_should_match\u0026#34;: 1 } } } # 高亮 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_phrase\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;nfc\u0026#34; } }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: {} } } } #scroll search GET /product/_search?scroll=1m { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ] } GET /_search/scroll { \u0026#34;scroll_id\u0026#34; : \u0026#34;FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFjhiSmpqSkhqU1FlR1pfbXJYaTZ2ZVEAAAAAAABoRBZJOWhLcFBtUVJfMlg4SU4wQldrV2VR\u0026#34; }     关键词\n \u0026quot;term:{}\u0026quot; query-term完全匹配 不会分词 \u0026quot;match\u0026quot;:{} 匹配 模糊匹配 先对输入进行分词,对分词后的结果进行查询 \u0026quot;match_parse\u0026quot;:{} \u0026quot;match_All\u0026quot;:{} 匹配所有 \u0026quot;multi_match\u0026quot;:{}:根据多个字段查询一个关键词 \u0026quot;_source:{}\u0026quot;元数据,想要查询多个字段  \u0026quot;from\u0026quot;:0,\u0026quot;size\u0026quot;:2deep-paging 分页 \u0026quot;range\u0026quot;:{} \u0026quot;gte\u0026quot;: NUM \u0026quot;lte\u0026quot;:NUM 取范围    全文检索  term  不会被分词    短语搜索  match_phrase  Query and filter 查询和过滤  bool   must\n  filter 过滤器,不计算相关度分数,cache\n 缓存功能  filter并不是每次执行都会进行cache,而是当执行一定次数的时候才会进行cache一个二进制数组,1表示匹配,0表示不匹配,这个次数不是固定的 filter会优先过滤掉稀疏的数据,保留匹配的cache数组 filter cache保存的是匹配的结果,不需要再从倒排索引中去查找比对,大大提高查询速度 filter一般会在query之前执行,过滤掉一部分数据,从而提高query速度 filter不计算相关度分数,在执行效率上较query高 党员数据发生改变时,cache也会更新      should 可能满足 or\n 多个条件,满足minimum_should_match 默认是0    must_not 不计算相关度分数\n    Deep paging  深度分页 返回结果不要超过1000个 解决办法  避免深查询 scroll search    scroll search  先查询一部分,给查询的加一个标识,下次继续查询后面的 GET /product/_search?scroll=1m 1m是有效期,1s 1ms  \u0026quot;scroll\u0026quot;:\u0026quot;1m\u0026quot; 延期    Mapping  mapping 就是es数据字段field的type元数据,es在创建索引的时候,dynamic mapping会自动为不同的数据指定相应的mapping mapping中包含了字段的类型,搜索方式(exact value或者full text),分词器等 查看mapping GET /product/_mappings 搜索方式  exact value 精确匹配:在倒排索引过程中,分词器会将field作为一个整体创建到索引中 full text 全文检索,分词,近义词,混淆词,大小写,词性,过滤,时态转换等(normalization)   Mapping Parameter  index 是否对当前字段创建索引,默认为true,如果不创建索引,该字段不会通过索引被搜索到,但仍会在source元数据中展示 analyzer 指定分析器(character filter,tokenizer,Token filters) boost 对当前字段相关度的评分权重,默认是1 coerce 是否允许强制类型转换 copy_to    ","permalink":"http://blog.oxide.ink/posts/db/elasticsearch/","summary":"概述  ES不等于搜索引擎 分布式的搜索,存储,数据分析引擎 优点:  面向开发者友好,屏蔽了Luncene的复杂特性,集群自动发现 自动维护数据在多个节点上的建立 帮我们做搜索请求的负载均衡 自动维护冗余副本,保证了部分节点宕机的情况下仍然不会有任何数据丢失 ES基于Lucene提供了很多高级功能:符合查询,聚合分析,基于地理位置 对于大公司,可以构建几百台服务器的大型分布式集群,处理PB级别数据 相遇传统数据库,提供了全文见检索,同义词处理,相关度排名,聚合分析以及海量数据的近实时(NTR)处理,这些传统数据库完全做不到   应用领域  搜索引擎 各大网站的用户行为日志(点击,浏览,收藏,评论) BI 数据分析 Github ELK (Elasticseach(数据存储) Logstash(日志采集) Kibana(可视化))    核心概念和原理  搜索  SQL 用了%不能用索引 -\u0026gt;性能差  like % 搜索时间复杂度O(n)   不能分词   倒排索引  分词 生成相关度 * 排序 空间换时间   数据结构  document List 关键词在每个doc中出现的次数 TF term frequency 词频 IDF inverse doc frequency 关键词在当前doc出现的次数 每个doc的长度 越长相关度越低 包含这个关键词的所有doc的平均长度     核心概念  集群:每个集群至少包含两个节点 Node:集群中的节点 一个节点不代表是一台机器 Filed: 一个数据字段,与index和type可以定位一个doc Document:ES最小的数据单元 Json Type:逻辑上的数据分类 Index:一类相同或者相似的doc 分片shard  一个index包含多个shard,默认5p,默认每个p分配一个r,p的数量在创建索引的时候设置,如果想修改,需要重建索引 每个shard都是一个lucene实例,有完整的创建索引的处理请求能力 ES会自动在nodes尚未我们zuoshard均衡 一个doc不可能同时存在于多个PShard,但是可以同时多个Rshard p和对应的r不能同时存在于同一个节点,所以最低的可用配置是两台节点,互为主备   横向扩容 Parimary Shared Replica Shard     容错  两台机子p0,p1,p2 r0,r1,r2 p挂掉之后r顶上 容错机制  master选举  findMaster  脑裂 可能会产生多个master节点   判断自己是否为master 广播/findMaster   replica容错 重启故障机 数据恢复  只拷贝新增数据 不是全量拷贝        使用  健康值检查  CRUD  Query String search 类似于Url挂参数搜索 Query DSL Query and filter  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  GET /_cat/health?","title":"ElasticSearch"},{"content":"基本概念 进程 线程 纤程(quasar)  Java线程,详见Java笔记  补充,可以有lambda表达式写法 三种启动线程方式  Thread Runnable Executors.newCachedThread(本质也是调用上两个)   sleep ,睡眠多少秒,其他线程可以运行 yield,加入等待队列,有可能立马还是自己 join , 调用另一个线程,保证顺序 interrupt , 抛出异常,处理catch   生命周期   新建：就是刚使用new方法，new出来的线程；\n  就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;\n  运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;\n  阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;\n  销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;\n    锁 常见锁 synchronized  可重入锁 synchronized(this) - \u0026gt; synchronized void m() ,static synchronized锁的是T.class -保证原子性和可见性 底层实现  锁升级  偏向锁 标记线程 自旋锁 自旋十次 消耗cpu,用户态 重量级锁 - OS,os等待队列,不占cpu,但要跟os交互,内核态   执行时间长,线程数多用系统锁 执行时间段(加锁代码),线程数少,用自旋锁     不能阻止指令重排序 异常会释放锁  Lock volatile(可变的)   保证线程可见性\n MESI 缓存一致性协议    禁止指令重排序\n DCL单例 Double Check Lock Mgr06.java loadfence原语指令 storefence原语指令    不能保证原子性\n  dirty read\n 锁写不锁读    优化,粗化,细化\n  AtomicXXX  CAS(无锁优化 自选) compare and set/swap (乐观锁)  cas(V,Expected,NewValue)  if V==E\nV=New otherwise try again or fail\n  cpu原语支持 ABA问题  基础类型无所谓 引用类型,女朋友符合,中间经历了别的\u0026hellip;   不管 加版本号,检查版本号   Unsafe类=c c++指针  直接操作内存  allocateMemory putXXX freeMemory pageSize   直接生成实例  allocateInstance   直接操作类或者实例变量  objectFiledOffset getInt getObject   CAS相关操作  weakCompareAndSetObject int Long        LongAdder  分段锁(CAS操作) 分段式锁  各种JUC同步锁 synchronized  锁进程调用锁进程 notify() 不释放锁  ReentrantLock lock 新型锁  cas 手动上锁解锁 try lock  lock.tryLock(5,TimeUnit.SECONDS)   lock.lockInterruptibly()  通过打断来加锁   公平锁  new ReentrantLock(true) 尽可能公平 进入等待队列之前会检查队列里有没有人   可以有各种等待队列  CountDownLatch 新型锁  cas 计数,到了,放开wait await() CountDown()  CyclicBarrier  人满发车 限流  Phaser  过滤 重写onAdvance(int phase,int registeredParties) 栅栏推到自动调用  phase为阶段数 registerParties 推到栅栏需要的数量   phaser.arriveAndAwaitAdvance() 到达并执行 phaser.arriveAndDeregister() 到达不执行  ReadWriteLock -StampedLock  共享锁 排他锁 ReadLock read = new ReentrantLock().ReadLock() WriteLock Write = new ReentrantLock().WriteLock()  Semaphore  允许几个线程同时进行 类似红绿灯 new Semaphore(1) s.acquire(),获得锁,将数量减一,归零则停住 s.release() 归还 限流,最多允许多少线程在运行  Exchanger 交换器 LockSupport  LockSupport.park(),当前线程阻塞 (与锁定线程同时执行)LockSupport.unpark(线程对象名) 相当于在wait()前面调用notify()  面试题  实现一个容器,提供两个方法,add,size,写两个线程,线程1添加10个元素到容器钟,线程2实现监控元素的个数,当个数等于5个时,线程2给出提示并结束  加volatile ,有问题,得加延时,不然观察不到(即使使用Collection.SynchronizedList(new ArrayList()))  解释:在sleep的时候,有观察的动作   wait notify  synchronized: 观察线程wait,notify添加线程,添加线程到了5,notify观察线程,观察线程运行完,notify添加线程   countDownLatch: CountDownLatch(1),到了5,countDown 但是添加线程太快,可能顺序不符合预想  解决,两个门闩   LockSupport  类似countDownLatch的思路     写一个固定容量的同步容器,拥有put和get方法,以及getCount方法,能够支持2个生产者线程和10个消费者线程的的阻塞调用  synchronized,必须会写  wait() notifyALl() 为什么用while而不是if  另一个线程++之后,自己线程没有再检查一遍,所以需要while     ReentrantLock 的Condition  多个等待队列      AQS源码分析(以上除了LockSupport全是基于AQS) 源码阅读原则  跑不起来不读 解决问题就好-目的性 一条线索到底 无关细节略过 一般不读静态 一般动态读法  AQS 核心  CAS操作替代了锁整条链表的操作 CAS操作来操作tail  VarHandle  指向某个变量的引用 原子性操作 native cpu原语 比反射效率高很多 直接操纵二进制码  ThreadLocal  set  Thread.currentThread.map(ThreadLocal,person)   用途  声明式事务,保证同一个Connection    java引用  强软弱虚 强引用  普通一般用的引用 特点  不会被垃圾回收器回收     软引用  内存不够用的时候会回收 做缓存用 full gc   弱引用  只要遭遇到gc就会回收 作用  一般用在容器里 另一个强引用指向引用对象,引用断掉之后可以立即回收这个对象   ThreadLocal  ThreadLocalMap的key弱引用ThreadLocal,然后声明的变量强引用指向ThreadLocal 如果强引用,则内存泄漏 无比remove掉,不然还是会内存泄漏,(key值为null,value还存在(map还存在))     虚引用(给写jvm的人用的)  管理堆外内存 gc就被回收 回收之后可以从QUEUE中观测 值get不到 NIO中有个DirectByteBuffer,指向堆外内存,用虚引用的QUEUE来查看堆外内存哪里需要回收    容器 Collection  三大类\n List Set Queue    Vector  方法加了synchronized   Queue  ConcurrentQueue  CAS操作      Map  Hashtable  整个方法全加synchronized   HashSet  全不加   SynchronizedHashMap  效率没有比Hashtable高多少 加synchronized,但粒度比hashtable细   TreeMap  红黑树    Concurrent容器  ConcurrentHashMap  CAS操作 插入效率未必比其他的高 读取效率非常高   没有ConcurrentTreeMap  CAS操作树结构十分复杂   ConcurrentSkipListMap 跳表Map  高并发且排序   CopyOnWriteList 写时复制  加元素的时候复制出来 读的时候不加锁,写的时候加锁copy一个,然后把元素放上去,老指针指向新容器 读多写少的情况下用    Queue  相比于vector,添加了对线程友好的API  offer 添加,返回是否成功,add则是失败抛异常 peek 取,不会remove poll 取,并且remove    BlockingQueue  put 添加 ,满了的话,线程阻塞住 take 取,空了的话,线程阻塞住  LockSupport的park   生产者消费者模型 LinkedBlockingQueue  链表实现的BlockingQueue 有最大数量,Integer.MAX_VALUE    PriorityQueue 优先级队列  内部是二叉树 继承自AbstractQueue  内部进行排序  重写compareTo      DelayQueue  任务类需要继承Delay接口 按时间进行任务调度  new Task(\u0026ldquo;t\u0026rdquo;,System.currentTimeMillis()+500)  五秒后运行      SynchronusQueue  容量为0,给另外线程下达任务的,任务调度 本质上概念类似于Exchanger 只put  永远阻塞,等待消费(take)   不可以用add  会提示Queue已经满了,即使有take等待    TransferQueue  transfer(entry)  装完,阻塞,等待被取走,取走之后再取消阻塞   类似于接单,有反馈的模型  PipedStream Executor Callable  一个Task 类似于Runnable call(),有返回值 返回值存放在Future  Future  存储执行的将来才会产生的结果(所以叫Future) submit(Task) 提交任务,异步运行,非阻塞 get()方法取结果,阻塞方法  FutureTask  继承于Future和Runnable 把返回值存在自身  CompletableFuture  底层用的Fork-Join Pool 各种任务的管理类  AbstractExecutor ExecutorService  线程池大小调整  线程数过多,将浪费大量时间在上下文切换上 线程数过少,则cpu一些核则无法充分利用 N_Thread = N_CPU * U_CPU * (1+W/C)  N_CPU是处理器核的数目 U_CPU是期望CPU的利用率 W/C是等待时间预计算时间的比率     Executors   线程池工厂\n  Executors.newSingleThreadExecutor() 单例线程池\n 可以保证任务顺序执行 存在意义:  任务队列 生命周期管理      CachedPool\n 0个coreThread,Integer.MAX_VALUE个最大线程数 队列用的SynchronusQueue 来了马上使用    FixedThreadPool\n 固定线程数的线程池    Scheduled定时器线程池\n 队列是delayQueue Qutarz    面试题\n 加入提供了一个闹钟服务,订阅这个服务的人特别多,10亿,七点钟有10亿并发量  大的结构上，采用分而治之的思想，主服务器把这些任务同步到边缘服务器上，然后再每一台服务器上，通过线程池+任务队列。首先可以负载均衡分发到多台服务器去执行。然后对于每一台服务器，肯定有一个队列嘛，存着这些任务，然后一个个线程去消费。所以也是要用到线程池的。      concurrent vs parallel\n 并发是指任务提交 并行指任务执行 并行是并发的子集      ThreadPoolExecutor  维护着线程的集合和任务的集合 七个参数  corePoolSize 核心线程数 maximumPoolSize 最大线程数  算上核心线程数   keepAliveTime 生存时间  线程空闲时间过长,要回收给OS 核心线程一直都要活着   生存时间的单位(TimeUnit.Seconds) 任务队列(new ArrayBlockingQueue())  可以放各种各样的BlockingQueue 存任务用的   线程工厂(Executors.defaultThreadFactory) 拒绝策略  任务队列满,且线程也都用着,需要拒绝新来的线程 jdk默认提供四种  AbortPolicy:抛异常 DiscardPolicy:扔掉,不抛异常 DiscardOldestPolicy:扔掉排队时间最长的 CallerRunsPolicy:调用者处理任务       源码分析  Worker类(类似一个单独的线程类)  Runnable AQS 记录哪个Thread正在执行这个worker,所以需要AQS(还有加锁)   submit方法 execute  核心线程数不满,启核心 满了,加队列 两个都满了,非核心线程   addWorker  count++ addwork start      ForkJoinPool  分解汇总的任务 用很少的线程可以执行很多的任务(子任务)TPE做不到先执行子任务 CPU密集型 Work  继承RecursiveAction  不带返回值   继承RecursiveTask  带返回值      workStealingPool  每一个线程都有自己单独的队列 某一个线程执行完自己任务后,去别的线程上拿未完成的任务 底层是ForkJoinPool  ParallelStreamAPI 并行流  任务并行处理 底层实ForkJoinPool  JMH  Java Microbenchmark harness  java 微基准测试   量化性能 注解  Benchmark 测试哪一段代码 Warmup 预热  iterations 迭代,运行几次 time 等待几秒   Fork  用多少个线程来执行   BenchmarkMode 模式  Mode.Throughtput 吞吐量 每秒执行多少次   Measurement  iteration调用多少次 time 时间      Disruptor  分裂,瓦解 一个线程每秒处理600万个订单 速度最快的MQ 性能极高,无锁cas,单机支持高并发 环形buffer 实现了ConcurrentArrayQueue 维护sequence 写到的位置  position = num\u0026amp;(size-1) \u0026ndash;\u0026gt; 取余 12%8 = 12\u0026amp;(8-1)   队列满\u0026ndash;\u0026gt;等待策略  开发步骤  定义Event,队列中需要处理的元素 定义Event工厂,用于填充队列  牵扯到效率问题:disruptor初始化的时候,会调用Event工厂,对ringBuffer进行内存的提前分配 gc产生频率会降低,只有最开始分配的时候new   定义EventHandler(消费者) ,处理容器中的元素  ProducerType生产者线程模式  Producer.MULTI Producer.SINGLE 默认是MULTI,表示在多线程下生产sequence 如果确认是单线程生产者,那么可以指定SINGLE,效率会提升  等待策略  (常用)BlockingWaitStrategy:通过线程阻塞的方式,等待生产者唤醒,被唤醒后,再循环检查以来的sequence是否已经消费 BusySpinWaitStrategy:线程一直自选等待,可能比较耗cpu LiteBlockingWaitStrategy:线程阻塞等待生产者唤醒,与BlockingWaitStrategy相比,区别在SignalNeeded.getAndSet,如果两个线程同时访问一个 waitfor,一个访问signalAll时,可以减少lock加锁次数 LiteTimeoutBlockingWaitStrategy PhasedBackoffWaitStrategy TimeoutBlockingWaitStrategy (常用)YieldingWaitStrategy:尝试100次,然后Thread.yield()让出cpu (常用)SleepingWaitStrategy:Sleep  消费者异常处理  disruptor.handleException  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  disruptor.handleExceptionsFor(longEventHandler).with(new ExceptionHandler\u0026lt;LongEvent\u0026gt;() { @Override public void handleEventException(Throwable ex, long sequence, LongEvent event) { } @Override public void handleOnStartException(Throwable ex) { } @Override public void handleOnShutdownException(Throwable ex) { } });   ","permalink":"http://blog.oxide.ink/posts/java/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","summary":"基本概念 进程 线程 纤程(quasar)  Java线程,详见Java笔记  补充,可以有lambda表达式写法 三种启动线程方式  Thread Runnable Executors.newCachedThread(本质也是调用上两个)   sleep ,睡眠多少秒,其他线程可以运行 yield,加入等待队列,有可能立马还是自己 join , 调用另一个线程,保证顺序 interrupt , 抛出异常,处理catch   生命周期   新建：就是刚使用new方法，new出来的线程；\n  就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;\n  运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;\n  阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;\n  销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;\n    锁 常见锁 synchronized  可重入锁 synchronized(this) - \u0026gt; synchronized void m() ,static synchronized锁的是T.class -保证原子性和可见性 底层实现  锁升级  偏向锁 标记线程 自旋锁 自旋十次 消耗cpu,用户态 重量级锁 - OS,os等待队列,不占cpu,但要跟os交互,内核态   执行时间长,线程数多用系统锁 执行时间段(加锁代码),线程数少,用自旋锁     不能阻止指令重排序 异常会释放锁  Lock volatile(可变的)   保证线程可见性","title":"Java并发编程"},{"content":"学术名词  TLAB (Thread Local Allocation Buffer)  垃圾回收器  分代  CMS +ParNew Serial+Serial Old Parallel Scavenge+Parallel Old   分区  G1 ZGC Shenandoah    调优  什么是调优  根据需求进行JVM规划和调优 优化运行JVM环境(慢,卡顿) 解决JVM运行过程中出现的各种问题(OOM) out of memery   Java参数  标准参数 非标准参数 -X 调优 -XX    参数  -Xms200M 最小内存200M -Xmx200M 最大内存200M  设置成一样,防止内存抖动   -XX:+PrintGC 打印出来 -XX:+HeapDumpOnOutOfMemoryError  命令  java -Xms2M -Xmx2M -XX:+PrintGC problem jps 查看正在运行的编号 jinfo 编号查看进程信息 jstack jmap jstatus *arthas  dashboard 仪表盘 jvm 类似jinfo thread 类似jstack  thread -b 找死锁 heapdump 导出stack jad 即时反编译 redifine 重新替换class      ","permalink":"http://blog.oxide.ink/posts/jvm/jvm-1/","summary":"学术名词  TLAB (Thread Local Allocation Buffer)  垃圾回收器  分代  CMS +ParNew Serial+Serial Old Parallel Scavenge+Parallel Old   分区  G1 ZGC Shenandoah    调优  什么是调优  根据需求进行JVM规划和调优 优化运行JVM环境(慢,卡顿) 解决JVM运行过程中出现的各种问题(OOM) out of memery   Java参数  标准参数 非标准参数 -X 调优 -XX    参数  -Xms200M 最小内存200M -Xmx200M 最大内存200M  设置成一样,防止内存抖动   -XX:+PrintGC 打印出来 -XX:+HeapDumpOnOutOfMemoryError  命令  java -Xms2M -Xmx2M -XX:+PrintGC problem jps 查看正在运行的编号 jinfo 编号查看进程信息 jstack jmap jstatus *arthas  dashboard 仪表盘 jvm 类似jinfo thread 类似jstack  thread -b 找死锁 heapdump 导出stack jad 即时反编译 redifine 重新替换class      ","title":"JVM-01"},{"content":"概念  jvm跟java无关  任何语言-\u0026gt;class-\u0026gt;JVM   jvm是一种规范 虚构出来的计算机  字节码指令集(汇编语言) 内存管理:栈 堆 方法区等   常见的JVM实现  Hotspot  Oracle官方,做实验用的jvm   Jrockit  BEA,最快jvm 被Oracle收购,合并于hotspot   TaoBaoVM  hotspot深度定制版   LiquidVM  直接针对硬件   azul zing  垃圾回收的业界标杆   J9 -IBM Microsoft VM   JDK JRE JVM  JDK = jre + development kit JRE = jvm + core lib JVM    Class File Format   二进制字节流\n  数据类型 u1 u2 u4 u8 和_info\n  前八个16进制-\u0026gt;magic version\n  然后八个16进制-\u0026gt;minor version\n  然后四个16进制(2个字节)-\u0026gt; constant_pool_count\n 常量池    紧接constant_pool *\n 长度为constant_pool_count-1的表,从1开始,保留0    access_flags 定义类的那一排所代表的,例如public,final,implement,annotation\n  this_class\n 当前class文件    super_class\n  interfaces_count\n  interfaces\n  fields_count\n  fields\n  methods_count\n  methods\n access_flags name_index u2 descriptor_index u2 attributes_count attributes    attributes_count -u2\n  attributes\n code    Class Loading Linking Initializing loading  加载过程   Loading Linking  verification preparation  静态变量设初值,不是赋值   resolution   initializing   class在内存中的位置  根据虚拟机来不同考虑  应该是metaspace     类加载器  JVM是按需动态加载,采用双亲委派机制 为了安全  java.lang.String被自定义loader,打包后发给客户,用户输密码,密码发回来   父加载器  父加载器不是\u0026quot;类加载器的加载器\u0026quot;类加载器都是bootstrap加载器加载的   双亲委派是一个孩子向父亲方向,然后父亲向孩子方向的双亲委派过程 层次  bootStrap  加载lib/rt.jar charset.jar核心类,c++实现   Extension  加载扩展jar包,jre/lib/ext/*.jar,或由-Djava.ext.dirs指定   App  加载classpath指定内容   CustomClassLoader  自定义ClassLoader     自底向上检查该类是否已经加载parent方向 如何打破双亲委派  如何打破:重写loadClass()  tomcat是重写loadClass为先自己加载,没有则找父加载器 -\u0026gt;热加载 每次都重新new   何时打破过  jdk1.2之前,自定义ClassLoader都必须重写loadClass ThreadContextClassLoader可以实现基础类调用实现类代码,通过thread.setContextClassLoader指定 热启动,热部署  tomcat都有自己的模块指定classloader         class加载生成两部分  二进制存入内存(在meta space中,指的是method area,1.8之前叫PermanentGeneration) 生成一个class,指向二进制内存,来读取解析二进制,反射   ClassLoader源码  findClass 自己找 loadClass 方法过程  cache里面找 parent.loadClass 父类找,递归找 findClass 自己的findclass   如果是AppClassLoader首先会执行URLClassLoader的findClass方法 模板模式,留钩子函数,findClass    lazy loading   严格来说应该叫lazyInitializing\n  JVM规范并没有规定何时加载\n  但是严格规定了什么时候必须初始化\n new getstatic putstatic invokestatic指令,访问final变量除外 java.lan.reflect对类进行反射调用时 初始化子类的时候,父类首先初始化 虚拟机启动时,被执行的主类必须初始化 动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时 该类必须初始化    读取final 值不加载类\n  编译  混合模式 -Xmixed  解释器 JIT(Just in Time compiler) 混合使用解释器+热点代码编译 起始阶段采用解释执行 热点代码检测  多次调用的方法(方法计数器:检测方法执行频率) 多次调用的循环(循环计数器:检测循环执行频率) 进行编译     -Xmixed 默认混合模式开始解释执行,启动速度较快,对热点代码实行检测和编译 -Xint Xint 使用解释模式,启动很快执行稍慢 -Xcomp Xcomp使用纯编译模式,执行很快,启动很慢  exe,elf    Linking  Verification  验证文件是否符合jvm规定   Preparation  静态成员变量赋默认值   Resolution  将类,方法,属性等引用解析为直接引用 常量池中的各种符号引用解析为指针,偏移量等内存地址的直接引用     总结  load-默认值-初始值 new-申请内存-默认值-初始值    initializing JMM java memory model  内存一致性  硬件层一致性   busLock 总线锁 -\u0026gt;老cpu\n  MESI 等各种各样的一致性协议(MSI,MESI,MOSI,Synapse,Firefly Dragon)\n 缓存锁 有些无法被缓存的数据或者跨越多个缓存行的数据依然必须使用总线锁 缓存行(cache line) 缓存的单位,一般为64字节 512位  伪共享  位于同一缓存行的两个不同数据,被两个cpu锁定,产生互相影响的伪共享问题 -\u0026gt;JUC/falseSharing   缓存行对齐 -\u0026gt; 能够提高效率  甚至disruptor中就有相关操作  在cursor前后各填充了七个long来对其缓存行来提高效率          MESI -\u0026gt;缓存锁\n Modified 修改加标记,m Exclusive 独享标记,e shared 同时在读 ,s Invalid 被别人改过了 i    目前数据一致性是缓存锁+总线锁\n     指令排序  cpu类似内部多线程,查看没有依赖关系会乱序执行 乱序读合并写 JUC/029_WriteCombining -\u0026gt;四个超快缓存 ,四个字节 乱序执行JUC/jmm/Disorder   保证不乱序  cpu级别内存屏障  intel 硬件内存屏障,实实在在存在的  sfence : 在sfence指令前的写操作当必须在sfence指令后的写操作前完成 lfence : 在lfence指令前的读操作当必须在lfence指令后的读操作前完成 mfence : 在mfence指令前的读写操作必须在mfence指令后的读写操作前完成 原子指令:例如x86上的\u0026quot;lock\u0026quot;,指令是一个Full Barrier,执行时会锁住内存子系统来确保执行顺序,甚至跨越 多个CPU,Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保存程序顺序   JVM级别(JSR133),依赖于硬件内存屏障 规范  LoadLoad屏障 StoreStore屏障 LoadStore屏障 StoreLoad屏障       volatile  java-\u0026gt;class  标记ACCESS_FLAG volatile   jvm  写操作  StoreStoreBarrier volatile StoreLoadBarrier   读操作  LoadLoadBarrier volatile LoadStoreBarrier     os  hsdis -hotspot dis assembler Windows lock指令实现     synchronized  java-\u0026gt;class  ACC_SYNCHRONIZED -代码块  monitor enter 代码块 monitor exit monitor exit   可能出异常,所以一个enter对应两个exit     jvm  c和c++调用了系统提供的同步机制   os  lock cmpchg/xx      面试题  关于对象    解释一下对象的创建过程\n class loading:类加载 class linking(verification preparation resolution)  verification:校验文件是否为class preparation: 静态变量设默认值 resolution :解析   class initialization: 初始化,执行静态语句块 申请对象内存 成员变量赋默认值 调用构造方法 成员变量顺序赋初始值 执行构造方法语句  super        对象在内存中的存储布局\n 观察虚拟机配置  java -XX:+PrintCommandLineFlags -version   普通对象  对象头: markword 8 ClassPointer指针: -XX:+UseCompressedClassPointers为四个字节,不开启为8字节 实例数据  引用类型: -XX:+UseCompressOops为四字节,不开启为8字节 Oops Ordinary Object Pointers 成员变量的指针   padding对齐,8的倍数   数组对象  对象头:markword 8 ClassPointer 指针同上 数组长度:4字节 数组数据 对齐8的倍数   ObjectSizeAgent HotSpot开启内存压缩的规则(64位)  4g以下直接砍掉高32位 4g-32g,默认开启内存压缩ClassPointer Oops 32G,压缩无效,使用64位,内存不是越大越好      对象头具体包括什么\n 偏向锁 锁 HashCode  31位hashcode-\u0026gt;System.identityHashCode(\u0026hellip;) \u0026ndash;\u0026gt;64位机子,32位的25位 按原始内容机选hashcode,重写过的hashcode方法计算的结果不会存在这里   分代年龄-\u0026gt;4bit,最大15       对象怎么定位\n 句柄池 -\u0026gt; gc算法方便(三色算法)  两个指针  数据类型指针 T.class 实例数据指针     直接指针 -\u0026gt;hotspot  一个指针  指向实例数据 实例数据指向数据类型        对象怎么分配\n GC相关内容    Object o = new Object 在内存中占用多少字节\n  JVM Runtime Data Area \u0026amp;\u0026amp; JVM Instructions JVM Runtime Data Area  PC program count 线程私有  存放指令位置 虚拟机的运行,类似于这样的循环 1 2 3 4 5 6  while(not end) { 取PC中的位置,找到对应位置指令 执行指令 PC++ }      Heap Stack  JVM stack *** 线程私有  Frame - 每个方法对应一个栈帧  Local Variables 局部变量表 Operand Stack 操作数栈  对于long的处理(store and load),多数虚拟机的实现都是原子的jls17.7,没必要volatile   dynamic linking 动态链接  jvms 2.6.3 a()调用了b(),去constant_pool找b()的链接-\u0026gt;动态链接   return address  a()调用b(),返回值放的位置以及继续的地址       native method stack 线程私有   method area *** 逻辑概念  具体实现  perm Space (\u0026lt;1.8)   字符串常量位于PermSpace FGC不会清理  1  for(;;) I i =C::n //Method Area -\u0026gt;OOM,1.8之后不会OOM    大小启动时指定,不能变  meta space(\u0026gt;=1.8)   字符串常量位于堆 会触发FGC清理 不设定的话最大就是物理内存     Direct Memory  JVM直接访问内存空间的内存,不用再复制到jvm nio,提高效率,实现zero copy    JVM Instructions  store load pop add mul \u0026hellip; invoke  invokeStatic  调用静态方法   invokeVirtual  自带多态 final方法   invokeInterface invokeSpecial  可以直接定位的  private 方法,init     invokeDynamic  JVM最难指令 lambda表达式 反射 其他动态语言,scala,kotlin,CGLib ASM动态产生的class会用到的指令      Garbage Collector \u0026amp;\u0026amp; GC tuning  垃圾 -\u0026gt; 孤儿  how to find a garbage  reference count 引用计数 python  循环引用不能解决   root Searching 根可达算法 java  根对象  线程栈变量 静态变量 常量池 JNI指针 -\u0026gt;native      GC Algorithms  Mark-Sweep(标记清除)  算法相对简单 存活对象比较多的情况下效率较高 两遍扫描,效率偏低 容易产生碎片   Copying(拷贝)  适用于存活对象较少的情况,只扫描一次,效率高,没有碎片 空间浪费 移动复制对象,需要调整对象引用   Mark-Compact(标记压缩) ![](.JVM-2_images/ Mark-Compact.png)  不会产生碎片,方便对象分配 不会产生内存减半 扫描两次 需要移动对象,效率偏低    堆内存逻辑分区(不适用部分带垃圾收集器)  部分垃圾回收器使用的模型  除了Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型 G1是逻辑分代,物理不分代 除此之外,不仅逻辑分代,而且物理分代    内存分配  方法区,永久区,元空间\u0026hellip; 30:00   栈上分配  线程私有对象 无逃逸 支持标量替换 无需调整   线程本地分配TLAB(Thread Local Allocation Buffer)  占用eden,默认1% 多线程的时候不用竞争eden就可以申请空间,提高效率 小对象 无需调整   老年代  大对象   eden   对象何时进入老年代  超过 XX:MaxTenuringThreshold 指定次数(YGC)  Parallel Scavenge 15 CMS 6 G1 15 git config \u0026ndash;global http.proxy \u0026lsquo;socks5://127.0.0.1:1080\u0026rsquo; git config \u0026ndash;global https.proxy \u0026lsquo;socks5://127.0.0.1:1080\u0026rsquo;   动态年龄  s1 -\u0026gt;s2超过50% 把年龄最大的放入O      分配担保  YGC期间 survivor区空间不够了 空间担保直接进入老年代    垃圾回收器  Serial  stw mark-sweep-compact ? safe point 完成必要的事情 老gc,处理空间小,大了则stw时间特别长   SerialOld 老年代  stw mark-sweep-compact 标记压缩 single GC thread   Parallel Scavenge  stw copying multiple GC   Parallel old  stw compacting multiple GC   Parallel new  stw copying multiple gc 加强版PS,配合CMS用的变种  PN:响应时间优先 PS:吞吐量优先     G1(10ms)  算法:三色标记+SATB   ZGC(1ms) PK C++  算法:ColoredPointers+写屏障   Shenandoah  算法:ColoredPointer+读屏障   Epsilon 默认回收器,PS+Parallel Old  CMS  concurrent mark sweep 老年代垃圾回收器 phases  initial mark concurrent mark remark concurrent sweep    问题  MemoryFragmentation 内存碎片化  搬出Serial Old来慢慢压缩空间 -XX:CMSFUllGCsBeforeCompaction   Floating Garbage  PromotionFailed Concurrent Mode Failure -XX:CMSInitiatingOccupancyFraction 92%  降低这个值,让cms保持老年代足够空间   SeriaOld     垃圾收集器跟内存大小的关系  Serial 几十m PS 上百m到几个g CMS 几个g到十几个g g1 上百g ZGC 4T    三色扫描算法 GC 调优  吞吐量: 用户代码时间/(用户代码执行时间+垃圾回收时间) 干正事的比例 响应时间 : STW越短,响应时间越好 所谓调优: 首先确定追求什么,吞吐量优先还是响应时间优先还是在满足一定响应时间的情况下,要求达到多少吞吐量  命令 Log   java -X ms5M -Xmx5M -XX:+PrintCommandLineFlags -XX:+PrintGCDetails com.mashibing.jvm.c5_gc.T01_HelloGC\n           total= eden+1个survivor\n  ","permalink":"http://blog.oxide.ink/posts/jvm/jvm-2/","summary":"概念  jvm跟java无关  任何语言-\u0026gt;class-\u0026gt;JVM   jvm是一种规范 虚构出来的计算机  字节码指令集(汇编语言) 内存管理:栈 堆 方法区等   常见的JVM实现  Hotspot  Oracle官方,做实验用的jvm   Jrockit  BEA,最快jvm 被Oracle收购,合并于hotspot   TaoBaoVM  hotspot深度定制版   LiquidVM  直接针对硬件   azul zing  垃圾回收的业界标杆   J9 -IBM Microsoft VM   JDK JRE JVM  JDK = jre + development kit JRE = jvm + core lib JVM    Class File Format   二进制字节流","title":"JVM-2"},{"content":"介绍 数据是什么 如何存储 数据库引擎   innodb\n  myisam\n  memory\n  区别\n innodb存储引擎数据跟索引文件放在一个文件中,myisam分为不同文件 innodb支持事务,myisam不支持事务 innodb支持表锁和行锁,myisam支持表锁 innodb有外键,myisam没有外键    索引的分类  主键索引  主键索引是一种唯一性索引,但它必须指定为primary key,每个表只能有一个主见   唯一索引  索引的列所有值都只能出现一次,即必须唯一,值可以为空   普通索引  基本的索引类型,值可以为空,没有唯一性限制   全文索引  全文索引类型为FULLTEXT,全文索引可以在varchar,char,text类型的列上创建   组合索引  多列值组成一个索引,专门用于组合搜索    回表 最左匹配原则 索引覆盖 索引下推 select * from t1 where age=? and gender=? 先根据age字段从存储引擎层将数据拉取回server层,然后在server层进行gender筛选,再从存储引擎层拉去数据的 时候,就会直接根据age,gender一起筛选 ##准备\n数据库   云数据库\n RDS,PolarDB,TDSQL    NewSQL\n TiDB    生产线\n 厂家  Oracle 官方 MariaDB Percona      5.6\n 5.6.36,5.6.38,5.6.40,5.6.46    5.7\n 5.7.20 22 24\u0026hellip;.    8.0\n 8.0.11,8.0.17,8.0.18    C:社区版\n  E:企业版\n  linux环境 mysql指令  数据初始化  mysqld --initialize-insecure --user=xxx --basedir=/app/database/mysql --datadir=/data/3306/ 有-insecure  初始化完成后,有12位临时密码,必须在使用mysql之前重置这个密码 密码管理使用严格模式: 3种密码复杂度,8位以上       SQL概述  Structured Query Language  用来跟数据库打交道,完成和数据库的通信,90%以上的SQL语句是通用的   数据库(notes.DB)  notes.DB: 通常是一个或一组文件,保存了一些符合特定规格的数据 DBMS:DataBase Management System 数据库管理系统 MySql,Oracle,执行SQL,操作数据库    连接数据库  mysql -uxxxxx -pxxxxx  1  msyql -uroot -p123456   概念  table  一种结构化的文件,用来存储特定类型的数据   SQL的分类  数据查询语言(DQL-Data Query Language)  select   数据操纵语言(DML-Data Manipulation Language)  insert,delete,update   数据定义语言(DDL-Data Definition Language)  create,drop,alter   事务控制语言(TCL-Transactional Control Language)  commit,rollback   数据控制语言(DCL-Data Control Language)  grant,revoke      常用命令  select version();查看版本 select database();查看当前数据库 desc \u0026lt;database\u0026gt;; 查看详细信息 show create table \u0026lt;tablename\u0026gt;;查看建表语句  Base 简单查询   查询\n select \u0026lt;volumes\u0026gt; from \u0026lt;table\u0026gt;; 查询某个字段的信息(无视大小写)  可以加数学表达式  select empno,ename,sal*12 from emp;   重命名   select empno,ename,sal*12 as years from emp; 加as,可空格不写as select empno,ename,sal*12 as years from emp;        条件查询\n select \u0026lt;volumes\u0026gt; from \u0026lt;table\u0026gt; where \u0026lt;条件\u0026gt;; 条件      运算符 说明     = 等于   \u0026lt;\u0026gt;或!= 不等于   \u0026lt; 小于   \u0026gt; 大于   \u0026gt;= 大于等于   between \u0026hellip;and\u0026hellip; 两只之间,等同于\u0026gt;= and \u0026lt;=,左闭右开   is null 为null(is not null 不为空)   and 并且 ,优先级高于\u0026rsquo;or'   or 或者   in 包含   not 取非,主要用在is 或 in中   like 模糊查询,支持%或下划线匹配,%匹配任意个字符,下划线,一个下划线匹配一个字符          排序\n order by \u0026lt;volume\u0026gt; 默认升序,volume可为数字,代表第几个属性  asc 升序 desc 降序      数据处理函数/单行处理函数\n     运算符 说明 示例     Lower 转换小写 lower(ename)   upper 转换大写 upper(ename)   substr 子串 substr(ename,1,2)   length 取长度 length(ename)   trim 去空格 trim(ename)   str_to_date 将字符串换成日期 str_to_date(\u0026lsquo;字符串\u0026rsquo;,\u0026lsquo;时间格式\u0026rsquo;)   date_format 格式化日期 date_format(日期类型数据,\u0026lsquo;日期格式\u0026rsquo;)   format 设置千分位    round 四舍五入 round(comm,0)第二个参数为取得为数,可为负数   rand() 生成随机数 与java Math.Random()类似   ifnull 将null转换为具体值 ifnull(comm,0)如果comm为null,则转换为0        日期\n 关于MySQL中的日期处理  每一个数据库处理日期的时候,采用的机制都是不同的,日期处理都有自己的一套机制,所以在实际开发中 表中的字段定义为DATE类型,这种情况很少,因为一旦使用日期类型,那么java程序将不能够通用,在实际开发中 一般使用\u0026quot;日期字符串\u0026quot;来表示日期      MySQL数据库管理系统中对日期的处理提供了两个重要函数\n str_to_date date_format    str_to_date\n 该函数的作用是:将日期字符串转换成日期类型 varchar\u0026ndash;\u0026gt;date 该函数的执行结果是DATE类型 该函数的使用格式  str_to_date(\u0026lsquo;日期字符串\u0026rsquo;,\u0026lsquo;日期格式\u0026rsquo;)      1  selectename,hiredatefromempwherehiredate=str_to_date(\u0026#39;12-17-1980\u0026#39;,\u0026#39;%m-%d-%Y\u0026#39;);   date_format  该函数的作用是:将日期类型date转换成剧有特定格式的日期字符串varchar date\u0026ndash;\u0026gt;varchar 该函数的运算结果是:varchar类型(具备特定格式) 该函数的语法格式:  date_format(日期类型数据,\u0026lsquo;日期格式\u0026rsquo;)      1  selectename,date_format(hiredate,\u0026#39;%m-%d-%Y\u0026#39;)ashiredatefromemp;    日期格式\n     notes.Java MySQL 说明     yyyy %Y 年   MM %m 月   dd %d 日   HH %H 时   mm %i 分   ss %s 秒   SSS  毫秒        分组函数/聚合函数/多行处理函数 (忽略空值)\n     函数 说明     count 取得记录值   sum 求和   avg 取平均   max 取最大值   min 取最小     分组函数不能直接用在where函数中    distinct 去重复\n 前面不能有字段    1  selectdistinctjobfromemp;  分组查询  分组查询涉及的两个子句:  group by 分组,优先执行(先分组,再where,再select再having) having 分组之后过滤   group by  若一条DQL语句中有group by子句,那么select关键字后面只能跟参与分组的字段和分组函数 求不同job的最大sal    1  selectmax(sal)fromempgroupbyjob;  求不同job的最大sal也显示job\n1  selectjob,max(sal)fromempgroupbyjob;  两个字段联合划分分组\n1  selectdeptno,job,max(sal)fromempgroupbyjob,deptno;  select: 分组前筛选 having: 分组后筛选\n1 2  selectjob,avg(sal)fromempgroupbyjobhavingavg(sal)\u0026gt;1500;   原则:  尽量在where中过滤,无法过滤的数据,通常需要先分组之后再过滤,这个时候可以选择用having.效率问题    总结 1 2 3 4 5 6 7 8 9 10 11 12 13  select...from...where...groupby...having...orderby...   顺序不能变 执行顺序  from 从某张表中查询出来 where 经过某条件进行过滤 group by 然后分组 having 分组之后不满意再过滤 select 查询出来 order by 排序输出    连接查询   什么是连接查询\n 查询的时候只从一张表检索数据,称为单表查询 在实际开发中,数据并不是存储在一张表中,是同时存储在多张表中,这些表和表之箭存在关系,我们在检索的时候通常是 需要将多张表联合起来取得有效数据,这种多表查询被称为连接查询或者叫做跨表查询    链接查询根据出现年代分类\n SQL92[1992] SQL00[1999:更新的语法,主要掌握这种]    连接查询根据连接方式可分为\n 内连接 :A表和B表能够完全匹配的记录查询出来,被称为内连接(inner可以省略)   等值连接\n SQL92语法:等值连接  1  selecte.ename,d.dnamefromempe,deptdwheree.deptno=d.deptno;  -SQL99语法:等值连接 join on - 表独立出来了,结构更清晰,对表连接不满意的话可以追加where过滤\n1  selecte.ename,d.dnamefromempejoindeptdone.deptno=d.deptno;    非等值连接\n SQL99: 1  selecte.ename,s.gradefromempe,salgradeswheree.salbetweens.losalandhisal;   SQL99: 1  selecte.ename,s.gradefromempejoinsalgradesone.salbetweens.losalandhisal;      自连接\n SQL99: 1  selecte.ename,m.enamefromempe,empmwherem.empno=e.mgr;   SQL99: 1  selecte.ename,m.enamefromempejoinempmonm.empno=e.mgr;       外连接 : (outer可以省略)   A表和B表能够完全匹配的记录查询出来之外,将其中一张表的记录无条件的完全查询出来. 对方没有匹配的记录,会自动模拟出null与之匹配,这种查询被称为外连接\n  外连接的查询结果条数\u0026gt;=内连接的查询结果条数\n  左外连接\n SQL99: 1  selecte.ename,d.dnamefromdeptdleftjoinempeone.deptno=d.deptno;      右外连接\n SQL99: 1  selecte.ename,d.dnamefromemperightjoindeptdone.deptno=d.deptno;      任何一个右外连接都可以写成左外连接,反之亦可\n   全连接     若两张表进行连接查询的时候没有任何条件限制,最终的查询结果总数是两张表记录的条数的乘积,这种现象被称为 笛卡尔积现象,为了避免笛卡尔积现象的发生,必须在进行表连接的时候添加限制条件  1  selecte.ename,d.dnamefromempe,deptd;   多张表连接的语法格式  1 2 3 4 5 6 7 8 9 10 11 12 13  selectxxxfromajoinbon条件joincon条件;  原理:a和b进行表连接之后,a再和c进行表连接\n 案例:找出每一个员工对应的部门名称,以及该员工的工资等级:  1  selecte.ename,d.dname,s.gradefromempejoindeptdone.deptno=d.deptnojoinsalgradesone.salbetweenlosalandhisal;  子查询:\n1  selecte.ename,e.dname,s.gradefrom(selecte.ename,e.sal,d.dnamefromempeleftjoindeptdone.deptno=d.deptno)eleftjoinsalgradesone.salbetweens.losalandhisal;  子查询  什么是子查询  select语句嵌套select语句   子查询可以出现在哪儿  select\u0026hellip;(select) from\u0026hellip;.(select) where\u0026hellip;.(select)    select后select\n1  selecte.ename,(selectd.dnamefromdeptdwheree.deptno=d.deptno)asdnamefromempe;   找出每个部门的平均薪水,并且要求显示平均薪水的薪水等级 from 后select  1  selectd.dname,s.gradefrom(selectd.dname,e.salfrom(selectdeptno,avg(sal)assalfromempgroupbydeptno)ejoindeptdond.deptno=e.deptno)djoinsalgradesond.salbetweenlosalandhisal;  union  连接两个表一同输出  1 2 3  selectxxxxxunionselectxxxxx  字段个数相同,(Oracle中数据类型也要相同)\nlimit  获取一张表中的某部分数据 只在MySQL数据库中存在,不通用,是MySQL数据库的特色  1  selectename,salfromemplimit5;  limit 5 代表,从表中记录下标0开始,取五条等同于下面的sql语句\n1  selectename,salfromemplimit0,5;  limit的语法: limit 起始下标,长度 - 起始坐标没有指定,默认从0开始,0表示表中的第一条ji\u0026rsquo;lu\n 找出公司中工资排名在前五的员工  1  selectename,salfromemporderbysaldesclimit5;  表  DDL  ","permalink":"http://blog.oxide.ink/posts/db/mysql/","summary":"介绍 数据是什么 如何存储 数据库引擎   innodb\n  myisam\n  memory\n  区别\n innodb存储引擎数据跟索引文件放在一个文件中,myisam分为不同文件 innodb支持事务,myisam不支持事务 innodb支持表锁和行锁,myisam支持表锁 innodb有外键,myisam没有外键    索引的分类  主键索引  主键索引是一种唯一性索引,但它必须指定为primary key,每个表只能有一个主见   唯一索引  索引的列所有值都只能出现一次,即必须唯一,值可以为空   普通索引  基本的索引类型,值可以为空,没有唯一性限制   全文索引  全文索引类型为FULLTEXT,全文索引可以在varchar,char,text类型的列上创建   组合索引  多列值组成一个索引,专门用于组合搜索    回表 最左匹配原则 索引覆盖 索引下推 select * from t1 where age=? and gender=? 先根据age字段从存储引擎层将数据拉取回server层,然后在server层进行gender筛选,再从存储引擎层拉去数据的 时候,就会直接根据age,gender一起筛选 ##准备\n数据库   云数据库","title":"MySQL"},{"content":"安装\u0026amp;启动 server  redis_6379 redis-server /etc/redis/6379.conf --loadmoudle  client 入门  无数据类型 默认16个库(分为16个独立的区域) redis-cli -p xxxx -n [指定库] 方法与类型绑定  type 获取值的类型   二进制安全  字节流 字符流   redis-cli \u0026ndash;raw 格式化 help keys * flushall flushdb  数据类型 help @String\n String  encoding-str  set  生存时间 nx - 不存在的时候赋值 xx - 存在的时候才能更新   get mset - 多个存 mget - 多个取 append - 追加 getrange [start] [end]  正反向索引   setrange 修改 strlen -\u0026gt; length msetnx 原子性多操作,一个失败就取消操作   encoding-int(省去之后计算的判断,本质还是字节流)  incr +1 incrby [value] n decr [value] 减1 incrbyfloat [value] n 加浮点数   bitmap  bitset 设置字节中的bit offset是指bit bitpos 第一个1 offset是指字节 bitcount offset是指字节 bitop     List  Lpush Rpush Lpop Rpop lrange Lindex Rindex Lrem Rrem llen blpop  阻塞队列,单播队列 先进先出   Ltrim   Hash map(k-v)  hset hget hgetall hincrby hincrybyfloat keys sean*   set  sadd scard 交集并集差集  sinter(store) sunion sdiff   sismember smembers srandmember spop   sorted_set  zadd zrange # zrevrange # zrangebyscore zscore zrank zincrby 实时维护 交集并集差集  zunionstore weights 聚合指令   zremovebyscore zremovebyrank  滑动窗口      进阶 管道  echo -n \u0026quot;set k1 99\\n incr k1 \\n get k1\u0026quot; | nc xxxx 6379  建立tcp通信就能跟redis对话    发布/订阅 事务  transaction  multi 开启事务 exec 执行事务 discard 取消事务 watch  乐观锁 cas  A  watch k1 multi get k1 keys *   B  muti keys * set k1 xxxxx exec Aexec  数据被b修改过 不执行事务           缓存穿透  module redisbloom  bloom过滤器 布谷鸟过滤器 counting bloom   查找没有的东西   缓存和数据库的区别 config  内存  回收策略  noeviction 不丢,做数据库用 lfu 碰了多少次 lru 多久没碰 random ttl       有效期  ttl 按存活时间来  ttl + key 存活时间 key的有效期,访问延长?no 发生写,会剔除过期时间(没设置新的时间?) expire 设置时间(多少秒)  expireat 指定时间(倒计时,且不能延长)     被动/主动    ","permalink":"http://blog.oxide.ink/posts/db/redis/","summary":"安装\u0026amp;启动 server  redis_6379 redis-server /etc/redis/6379.conf --loadmoudle  client 入门  无数据类型 默认16个库(分为16个独立的区域) redis-cli -p xxxx -n [指定库] 方法与类型绑定  type 获取值的类型   二进制安全  字节流 字符流   redis-cli \u0026ndash;raw 格式化 help keys * flushall flushdb  数据类型 help @String\n String  encoding-str  set  生存时间 nx - 不存在的时候赋值 xx - 存在的时候才能更新   get mset - 多个存 mget - 多个取 append - 追加 getrange [start] [end]  正反向索引   setrange 修改 strlen -\u0026gt; length msetnx 原子性多操作,一个失败就取消操作   encoding-int(省去之后计算的判断,本质还是字节流)  incr +1 incrby [value] n decr [value] 减1 incrbyfloat [value] n 加浮点数   bitmap  bitset 设置字节中的bit offset是指bit bitpos 第一个1 offset是指字节 bitcount offset是指字节 bitop     List  Lpush Rpush Lpop Rpop lrange Lindex Rindex Lrem Rrem llen blpop  阻塞队列,单播队列 先进先出   Ltrim   Hash map(k-v)  hset hget hgetall hincrby hincrybyfloat keys sean*   set  sadd scard 交集并集差集  sinter(store) sunion sdiff   sismember smembers srandmember spop   sorted_set  zadd zrange # zrevrange # zrangebyscore zscore zrank zincrby 实时维护 交集并集差集  zunionstore weights 聚合指令   zremovebyscore zremovebyrank  滑动窗口      进阶 管道  echo -n \u0026quot;set k1 99\\n incr k1 \\n get k1\u0026quot; | nc xxxx 6379  建立tcp通信就能跟redis对话    发布/订阅 事务  transaction  multi 开启事务 exec 执行事务 discard 取消事务 watch  乐观锁 cas  A  watch k1 multi get k1 keys *   B  muti keys * set k1 xxxxx exec Aexec  数据被b修改过 不执行事务           缓存穿透  module redisbloom  bloom过滤器 布谷鸟过滤器 counting bloom   查找没有的东西   缓存和数据库的区别 config  内存  回收策略  noeviction 不丢,做数据库用 lfu 碰了多少次 lru 多久没碰 random ttl       有效期  ttl 按存活时间来  ttl + key 存活时间 key的有效期,访问延长?","title":"Redis"},{"content":"基础 工具   对数器\n 一个想要测的方法a 实现复杂度不好但是容易实现的方法b 实现一个随机样本产生器 方法a和方法b相同的随机样本,看看得到的结果是否一样 如果一个随机样本使得比对结果不一致,打印样本进行人工干预,改对方法a和方法b 当样本数量很多时对比测试依然正确,可以确定方法a已经正确    比较器\n 比较器的实质是重载比较运算符 比较器可以很好的应用在特殊标准的排序上 比较器可以很好的应用在根据特殊标准排序的结构上  PriorityQueue 小根堆转大根堆   写代码变得异常容易,还用于泛型编程    运算  异或运算,二进制无进位相加  性质:0^N=N,N^N=0 满足交换律和结合律(同一批数异或答案一样,无论顺序) ab互换  a = a^b b = a^b a = a^b   ab必须指向不同内存   提取最右侧1  N\u0026amp;((~N)+1) N与((N取反)+1)      排序  桶排序  数据状况强相关 -计数排序  设数组,累加   基数排序  非负十进制 添0,入桶出桶 权重逆着     排序算法的稳定性  稳定性是指同样大小的样本再排序之后不会改变相对次序 对基础类型来说,稳定性毫无意义 对非基础类型来说,稳定性有重要意义 有些算法可以实现成稳定的,而有些排序算法无论如何都实现不成稳定的 有稳定性: -处理相等情况时的策略  冒泡排序 插入排序 归并排序 桶排序 十分稳定  基数排序 计数排序     无稳定性:  选择排序 快排  partition过程必破坏稳定性   堆排     序算法总结   不基于比较的排序,对样本数据有严格的要求,不易改写 基于比较的排序,只要规定好两个样本怎么比大小就可以直接复用 基于比较的排序,时间复杂度的极限是O(NlogN) 时间复杂度O(NlogN),额外空间复杂度低于O(N),且稳定的基于比较的排序是不存在的 为了绝对的速度选快排,为了省空间选堆排,为了稳定选归并 小规模用常数项小的排序,例如插入排序,大规模用调度优秀的排序,如快排   常见的坑  归并排序的额外空间复杂度可以变成O(1),\u0026ldquo;归并排序 内部缓存法\u0026rdquo;,但是将变得不再稳定 -\u0026gt;直接堆排 \u0026ldquo;原地归并排序\u0026quot;是垃圾帖,会让时间复杂度变成O(N^2) -\u0026gt;插入排序 快排稳定性改进,\u0026ldquo;01 stable sort\u0026rdquo;,但是会对样本数据要求更多 -\u0026gt;桶排序 在整数数组中,请把奇数放在数组左边,偶数放在数组右边,要求所有奇数之间,偶数之间的原始相对次序不变 时间复杂度做到O(N).空间复杂度做到O(1)       排序方法 时间复杂度(平均) 时间复杂度(最坏) 时间复杂度(最好) 空间复杂度 稳定性 复杂性     直接插入排序 O(n2) O(n2) O(n) O(1) 稳定 简单   希尔排序 O(nlog2n) O(n2) O(n1.3) O(1) 不稳定 较复杂   直接选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 简单   堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 较复杂   冒泡排序 O(n2) O(n2) O(n) O(1) 稳定 简单   快速排序 O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 不稳定 较复杂   归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 较复杂   基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(n+r) 稳定 较复杂    数据结构 链表  反转链表,定义pre,next避免循环链表 笔试 ,不用太在乎空间复杂度,一切为了时间复杂度 面试,时间复杂度依然第一位,但一定要找到空间最省的方法  快慢指针 1.输入链表头节点,奇数长度返回中点,偶数长度返回上中点 2.输入链表头节点,奇数长度返回中点,偶数长度返回下中点 3.输入链表头节点,奇数长度返回中点前一个,偶数长度返回上中点前一个 4.输入链表头节点,奇数长度返回中点前一个,偶数长度返回下中点前一个\n 边界问题 笔试直接arraylist  判断回文链表  笔试 -\u0026gt;压栈 快慢指针  找中点,后半部分压栈,直到栈空,与前面节点顺序比较   不用容器  中点指向空,后半链表反着指,从两端往中间遍历,直到null 最后要调回来     将单向链表按某值划分成左边小中间相等右边大的形式  把链表放入数组里,在数组上做partition(笔试用) 分成小中大三个部分,再把各个部分之间串起来(面试用) -\u0026gt;6个变量,O(N)  代码     一种特殊的单链表类描述如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Node { int value; Node next; Node rand; Node(int val){value = val;} } ``` - rand指针是单链表结构中新增的指针,rand可能指向链表中任意一个节点,也可能指向null 给定一个由Node节点类型组成的无环单链表的头节点head,请实现一个函数完成这个链表的复制,并返回新的链表的头节点 - 要求时间复杂度O(N) - 要求额外空间复杂度O(1) 1. Hash表\u0026lt;Node,Node\u0026gt; 顺着比对装一遍,再遍历,用cur和get(cur)来进行复制 2. 构造一个对应关系,例如1\u0026#39;在1后面2\u0026#39;在2后面,3\u0026#39;在3后面,找random找到老节点的random再next 最后再在next方向分离出来    给定两个可能有环也可能无环的单链表,头节点head1和head2,请实现一个函数,如果两个链表相交,请返回相交的第一个节点,如果不相交,返回null  要求:如果两个长度之和为N,时间复杂度请达到O(N),额外空间复杂度达到O(1)     判定有无环,快慢指针,第一次相遇后,慢指针不动,快指针回原点,然后一起一次移动1个,下次相遇则是入环点 a. 给一个链表,返回入环的节点 b. 两个无环链表相交,返回第一个相交的节点 c. 两个有环链表,找到第一个相交的节点  能不能不给单链表头节点,只给删除的节点,就能做到在链表里删掉  借尸还魂,复制下一个节点的值,子节点指向下下个 a. 只替代了内容 b. 很大局限 c. 抖机灵 d. 无法删除最后一个节点 不行,很大问题,以上问题,必须要给头节点    栈  要求可以立即返回最小值,且pop,push,getMin为O(1)  单调栈(同步弹出省时间费空间)  两个栈,一个栈为普通栈 另一个为单调栈,普通栈压入的时候单调栈压数,小则放,大则放之前最小的 可以同步大小   单调栈不同步压入(费时间省空间)  判断当前两个栈顶是否一样     用栈拼队列  两个栈  一个push,一个pop pop的时候倒过来再输出  pop栈为空的时候才可输出 push一次性倒完        队列  用队列拼栈  分两个队列,data,help  取的时候把data元素扔到help中,剩一个,输出 然后help为data,data为help      HashSet\u0026amp;HashMap - 增删改查均为O(1)\r- Integer等大类型在HashMap,HashSet中是按值传递\r 有序表  TreeMap  firstKey() 最小的 lastKey() 最大的 离xx最近且小于的 floorKey(xx) 离xx最近且大于的 ceilingKey(xx) O(logN)   AVl 红黑树 跳表  堆  结构上:完全二叉树  0开始  i的左子节点 2*i+1 i的右子节点 2*i+2 父节点(i-1)/2   1开始  i的左孩子 2*i   小根堆  父节点是最小的   均不是则不是堆   堆排序  有关题目  几乎有序的数组排序,每个数去往的位置不超过k  生成小根堆 前k+1放入小根堆 当前最小的可能性       PriorityQueue  小根堆 poll方法,由小到大弹出    二叉树  先序 中序 后序  递归序  递归转迭代  压栈  头右左  弹 如果有左,压入左 如果有右,压入右   左右节点反着压 输出压栈      序列化反序列化  留null  题目  打印二叉树 后继节点  一棵二叉树,在中序遍历的序列中一个节点的下一个节点是谁,就是后继节点  找结构规律   凹凸折痕    二叉树的递归套路***  可以解决面试中绝大多数的二叉树问题,尤其树形dp 本质是利用递归遍历二叉树的便利性  规则  假设以X节点位头,可以向X左树和X右树要任何信息 在上一步的假设下,讨论以X为头节点的树,得到答案的可能性(最重要) 列出所有可能性后,确定到底需要向左树和右树要什么样的信息 把左树信息和右树信息求全集,就是任何一棵子树都需要返回的信息S 递归函数都返回S,每一棵子树都这么要求 写代码,在写代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息  题目  给定一棵二叉树的头节点位head,返回这颗二叉树是不是平衡二叉树 给定一棵二叉树的头节点head,任何两个节点之家你都存在距离,返回整棵二叉树的最大距离 给定一棵二叉树的头节点head,返回这颗树中最大的二叉搜索子树的头节点数 派对的最大快乐值,多叉树  这个公司要开party,决定哪些员工来,哪些员工不来  如果某个员工来了,那么这个员工的所有直接下级都不能来 派对的整体快乐值是所有到场员工的快乐值的累加 你的目标是让派对的快乐值尽量大 给定一棵多叉树的头节点boss,返回派对的最大快乐值     给定一个二叉树头,判断是否是完全二叉树 给定一棵二叉树的头节点head,和另外两个节点a和b,返回a和b的最低公共祖先  hashset做 巨简单 //TODO 递归 巨难    前缀树  单个字符串中,字符从前到后的加到一棵多叉树上 字符放在路上,节点上又专属的数据项(常见的是pass和end值) 所有样本都这样添加,如果没有就新建,如果有路就复用 沿途节点的pass值增加1,每个字符串结束时的节点end增加1  可以完成前缀相关的查询\n图  BFS 宽度优先遍历 DFS 深度优先遍历 题目先变换成自己掌握的结构 拓扑排序 -\u0026gt; 依赖问题 最小生成树  kruskal(用最小边找所有点)  由小到大union操作,直到包含所有元素 并查集   prime(用出发点找最小边循环解锁所有点)  点边点边解锁,点集,边集(由小到大,堆)   Dijkstra(给定出发点找到出发点通往其他所有点的最短路径)  给定出发点  创建一个对出发点负责的表 贪心 表中依次解锁新可达边/更新最短距离,锁死已检索的边   找到图中这个点到所有节点的最小值 TSP问题(商旅问题) 不同于Dijkstra  出发回自己城市,经过所有城市且只有一次,求最小代价   优化  建表使用小根堆(自己写,系统不能改写时重排序)  add, update,ignore          递归   Master公式\n T(N) = aT(N/b)+O(N^d)  子问题的规模是一致的(N/b) 子问题调用了a次 除了子问题调用之外,生下的复杂度为O(N^d) log(b)a\u0026gt;d,O(N^log(b)a) log(b)a\u0026lt;d,O(N^d) log(b)a==d,O(N^d(*logN))      归并排序 思想\n 左边数量多少个大,左边数量多少个小,右边数量多少个大,右边数量多少个小(用mergeSort改)  在一个数组中,一个数左边比他小的数的总和,叫数的小和,所有数的小和累加起来,叫数组小和,求数组小和  加返回值,修改merge()   降序对 - 右边有多少个数比它小      快排 思想\n 指定num,将数组分为小于等于num的和大于num的两个区  设定小于等于区从-1开始,然后指针遍历数组直到越界  如果当前数字大于num则不动,cur指针+1 如果当前数字小于等于num,cur指针的数于小于等于区指针的数互换,小于等于区指针++,cur指针++     给定num分成三块,小于区,等于区,大于区  分三个区,小于区,等于区,大于区,i跟大于区边界撞上的时候停止  arr[i]==num,i++ arr[i]\u0026lt;num,arr[i]与小于区的右一个交换(有等于的情况,与之前思路不同 ),小于区右扩,i++ arr[i]\u0026gt;num,arr[i]与大于区做一个交换,大于区左扩,i不变     荷兰国旗问题  以arr[R]划分   快排1.0 O(n)  mid放中间,左右两侧递归 有序的时候效率最低   快排2.0 O(n)  荷兰国旗问题,分为小于区,等于区,大于区,一次可以搞定一批等于的mid 有序的时候效率最低   快排3.0随机快排 O(N logN)-\u0026gt;概率累加期望 额外空间复杂度O(logN)  随机找一个值跟arr[R]交换,然后执行2.0      贪心算法  最自然智慧的算法 用一种局部最功利的标准,总是做出在当前来看最好的选择 难点在于证明局部最功利的标准可以得到全局最优解 对于贪心算法的学习主要以增加阅历为主  并查集  有若干个样本a,b,c,d类型设为V 在并查集中一开始认为每个样本都在单独的集合里 用户可以在任何时候调用如下两个方法:  boolean isSameSet(V x,V y)查询到样本x和样本y是否属于同一个集合\nvoid union(V x, V y)把x和y各自所在的样本合并成一个集合 isSameSet和union方法代价越低越好    过程  实现一个不依靠贪心策略的解法X,可以用最暴力的尝试 脑补出贪心策略A,策略B,策略C 解法X和对数器,用实验方式得知哪个最正确 不要去纠结证明  题目  给定一个由字符串组成的数组strs必须把所有的字符串拼接起来 返回所有可能的拼接结果中,字典序最小的结果  暴力,全排列,深度优先   长度一样看成一个26进制的数 \u0026lsquo;*\u0026lsquo;表示居民点,可以 放灯,需要点亮,如果灯放在i位置,可 以让i-1,i和i+1三个位置被点亮,返回如果点亮str中所有需要点亮的位置,至少需要几盏灯   哈夫曼树  去平均 小根堆,取两个最小的,相加,放回去,且加入节点,从下向上形成哈夫曼树 代价为非叶子节点的和 最小花费  5.      暴力递归 暴力递归就是尝试\n 把问题转化为规模缩小了的同类问题的子问题 有明确的不需要继续进行递归的条件(base case) 有当得到了子问题的结果之后的决策过程 不记录每一个子问题的解   大量重复计算  题目  汉诺塔  移动步数 (2^N)-1   给一个栈,逆序这个栈,不能申请额外数据结构,只能使用递归函数 打印字符串字串/子序列  字串  全排列  去重\u0026ndash;\u0026gt;容器set  分支定界 -\u0026gt;用set来登记,限制不必要的支路在源头杀死       子序列  去重\u0026ndash;\u0026gt;容器用set 子序列数量\u0026ndash;\u0026gt;动态规划      往左往右尝试模型  规定1和A对应,2和B对应\u0026hellip;那么一个数字字符串\u0026quot;111\u0026quot;会转换成 \u0026ldquo;AAA\u0026rdquo; \u0026ldquo;AK\u0026rdquo; \u0026ldquo;KA\u0026rdquo;  问总共多少转化结果   博弈论 [从小往大分析]  ab从最左或最右拿牌,目标面值最高,求胜利者的面值  双方玩家都不会在对方单独改变策略的情况下让对方得到收益   人过河 鱼吃人 人该什么时候过河 鱼吃掉人之后鱼会变成食物 鱼绝顶聪明 会决策  从小到大分析  一只鱼 -\u0026gt;必吃 两只鱼 -\u0026gt; 不吃 归纳-\u0026gt;奇数不过河,偶数过河     海盗分硬币  100个硬币,分给五个人,每个人提出方案,其他人投票是否赞成,赞成票超过一半方案则会被采纳,否则会被杀死 人性本恶  第一个人在自己不会死的情况下,提出对自己最优的方案,从小到大思考问题  E一个人 必然得到100个金币 [100] DE两个人 ,D必死 无论D如何决策,E投反对票,情况返回到1 [N,100] CDE三个人,因为C如果死掉,情况会变回2 所以无论C如何决策D都会同意 [100,0,0] BCDE四个人,如果B死了,情况会变回3,[100,0,0],所以给d,e分别1个 [98,0,1,1] ABCDE五个人,不会去拉拢B,[97,0,1,0,2]或者[97,0,1,2,0]   人性本善的模型 超过半数的模型 具体问题具体分析 都是从小往大分析     欧拉信封  一个村里,每个人必须寄出一封信,不能寄给自己,每个人只能收到一封信,有多少种寄信的方式  1个人 0种 2个人 1种 3个人 ABC ACB 两种 5个人 f(i) 输入多少人 返回可能性数量  假设B寄给E  E回寄给B 情况会变成三个人的欧拉信封问题 f(3) E不寄给B  E跟B会看成一个节点,从B入从E出 看成一个人 f(4)     这种假设下 f(5) = f(3)+f(4)   有四种可能性 所以f(5) = 4(f(3)+f(4))       N皇后  尝试方法 已经无法优化 但是常数项可以优化 N*N的棋盘上摆N个皇后 要求不同行不同列 不在一条斜线  1皇后 不成问题 2皇后 0种 3皇后 0种 4皇后 4*4 2种   一行一行试 一行放一个皇后 ,挨个试,不行就回溯   常数项优化 -\u0026gt; 位运算 非常有效      动态规划  暴力递归中范围上的尝试模型  模型 拆子问题的组织方法   用缓存来减少重复计算 只要可变参数是有限几个,只要能试出由可变参数代表的暴力递归,就能改成动态规划 不是所有的暴力递归都能改成动态规划,所有的动态规划都来自于某一个暴力递归 撞不上重复可能 没必要改成暴力递归  四种尝试模型  从左往右的尝试模型 v  背包问题 数字转字符串 钱数问题 二维表  将一个数组分成均匀的两部分     范围上的尝试模型 v  卡片 凑string 最长重复子串  f(左右都变) f(左) f(右) 左右一致,2+f(左右) 动态规划 -\u0026gt; dp  动态规划优化: dp[左]必大于dp[左下] 右同理,所以只需要比较左右,然后比较2+dp[左右]     马走日   多样本位置全对应的尝试模型 寻找业务限制的尝试模型  如何找到某个问题的动态规划方式  设计暴力递归:重要原则+4种常见尝试模型 重点! 分析有没有重复解:套路解决 用记忆化搜索 -\u0026gt; 严格表结构实现动态规划 套路解决 看看能否继续优化 套路解决  面试中设计暴力递归过程的过程  每一个可变参数的类型,一定不要比int类型更复杂 原则1可以违反,让类型突破到一维线性结构,那必须是唯一可变参数 如果发现原则1违反,但不违反原则2,只需要做到记忆化搜索即可 可变参数个数,能少则少  题目  题目一  假设有拍成一行的N个位置,记录为1-N ,N一定大于或者等于2,开始时机器人在其中的M位置上(M一定是1~N中的一个)  如果机器人来到1位置,那么下一步只能往右来到2位置 如果机器人来到N位置,那么下一步只能往左来到N-1位置 如果机器人来到中间位置,那么下一步可以往左或者往右走 规定机器人必须走K步,最终能来到P位置(P也是1~N中的一个)的方法有很多种 给定四个参数 N(规模),M(初始位置),K(需要的步数),P(目标),返回方法数      预处理 前缀和求数组滚动窗口和 问题范围和问题答案是否有线性规律  双端队列  最xx优先级队列 滑动窗口问题   单调栈  ","permalink":"http://blog.oxide.ink/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/","summary":"基础 工具   对数器\n 一个想要测的方法a 实现复杂度不好但是容易实现的方法b 实现一个随机样本产生器 方法a和方法b相同的随机样本,看看得到的结果是否一样 如果一个随机样本使得比对结果不一致,打印样本进行人工干预,改对方法a和方法b 当样本数量很多时对比测试依然正确,可以确定方法a已经正确    比较器\n 比较器的实质是重载比较运算符 比较器可以很好的应用在特殊标准的排序上 比较器可以很好的应用在根据特殊标准排序的结构上  PriorityQueue 小根堆转大根堆   写代码变得异常容易,还用于泛型编程    运算  异或运算,二进制无进位相加  性质:0^N=N,N^N=0 满足交换律和结合律(同一批数异或答案一样,无论顺序) ab互换  a = a^b b = a^b a = a^b   ab必须指向不同内存   提取最右侧1  N\u0026amp;((~N)+1) N与((N取反)+1)      排序  桶排序  数据状况强相关 -计数排序  设数组,累加   基数排序  非负十进制 添0,入桶出桶 权重逆着     排序算法的稳定性  稳定性是指同样大小的样本再排序之后不会改变相对次序 对基础类型来说,稳定性毫无意义 对非基础类型来说,稳定性有重要意义 有些算法可以实现成稳定的,而有些排序算法无论如何都实现不成稳定的 有稳定性: -处理相等情况时的策略  冒泡排序 插入排序 归并排序 桶排序 十分稳定  基数排序 计数排序     无稳定性:  选择排序 快排  partition过程必破坏稳定性   堆排     序算法总结   不基于比较的排序,对样本数据有严格的要求,不易改写 基于比较的排序,只要规定好两个样本怎么比大小就可以直接复用 基于比较的排序,时间复杂度的极限是O(NlogN) 时间复杂度O(NlogN),额外空间复杂度低于O(N),且稳定的基于比较的排序是不存在的 为了绝对的速度选快排,为了省空间选堆排,为了稳定选归并 小规模用常数项小的排序,例如插入排序,大规模用调度优秀的排序,如快排   常见的坑  归并排序的额外空间复杂度可以变成O(1),\u0026ldquo;归并排序 内部缓存法\u0026rdquo;,但是将变得不再稳定 -\u0026gt;直接堆排 \u0026ldquo;原地归并排序\u0026quot;是垃圾帖,会让时间复杂度变成O(N^2) -\u0026gt;插入排序 快排稳定性改进,\u0026ldquo;01 stable sort\u0026rdquo;,但是会对样本数据要求更多 -\u0026gt;桶排序 在整数数组中,请把奇数放在数组左边,偶数放在数组右边,要求所有奇数之间,偶数之间的原始相对次序不变 时间复杂度做到O(N).","title":"算法"}]