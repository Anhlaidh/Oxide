[{"content":"idea  ctrl+shift+v:替换变量名 ctrl+alt+v:抽取并赋值 ctrl+p:查看参数 ctrl+alt+o删除多余包 ctrl+F12 查看当前类中的包 ctrl+shift+enter 自动完成当前语句 ctrl+shift+backspace 返回到上次修改位置 alt+shift+F9 Debug  类转型\u0026amp;多态\u0026amp;契约设计  类转型：子类可以转父类，父类不可以转子类（除非父类对象本身就是子类） 多态：子类转型为父类后，调用普通方法，依旧是子类方法 契约设计：类不会直接使用另一个类，而是采用接口的形式，外部可以“空投”这个接口下的任意子类对象  static、final 和常量设计 static  static 变量：不管有多少个对象，内存中只有一份 static 方法：可以使用类名直接引用，无需 new 对象来引用   静态方法不可以调用动态变量 非静态方法可以调用静态方法 静态方法不可调用非静态方法  static 块：static 块只执行一次，并且 static 块\u0026gt;匿名块\u0026gt;构造函数  单例模式  设计模式：是经过验证的、用于某些特定场合的解决方案 GOF 提出 23 中设计模式；创建型、结构性和行为型 单例模式保证一个类在内存空间中只有一个对象   内部初始化一个单例 private 不可见，getInstance(static 方法)来取出单例对象  final  final 类：没有子类继承 final 方法：不能被子类改写（不能重写，可以重载） final 字段：基本类型被能修改值，对象类型不能修改指针（可以修改内容）  常量\u0026amp;常量池  java 中的常量：static 和 final notes.Java 接口中的变量都是常量 对象生成有两种：常量赋值（栈内存）和 new 创建（堆内存） 常见包装类  java 编译器会优化已经确定的变量 栈内存与堆内存运算会产生新的堆内存（存疑）  不可变对象  不可变对象提高读效率 不可变对象设计的方法 字符串 append 操作速度：StringBuilder\u0026gt;StringBuffer\u0026gt;String  notes.Java 访问权限 notes.Java 类库 数字类   根据数字特点选择合适的类\n  尽量使用类库自带的方法\n  整数   浮点数需要注意精度   BigInteger\n   支持无限大的整数运算   BigDecimal -支持无限大的小数运算   注意精度和截断   随机数  字符串类  String（不可变对象，只读） StringBuffer（字符串加减，同步，性能好） StringBuilder（字符串加减，不同步，性能更好）  时间类  当前多数程序还是使用 calendar 类处理时间  2. DateUtil，Instance 时间戳\n格式化类  NumberFormat  MessageFormat  DateFormat  DateFormatter   Exception 异常分类  异常：程序不正常的行为或状态 异常处理：  程序返回到安全状态 允许用户保存结果，并以适当方式关闭程序   异常分类  Throwable:所有错误的祖先 Error：系统内部错误或者资源耗尽 Exception：程序有关错误   又可分为unchecked异常和checked异常， 编译器会辅助检查checked异常  异常处理 try：正常逻辑代码 catch：当try发生异常，将执行catch代码，若无异常，绕之 finally：当try或者catch执行后，必须要执行finally\n  一个try只会进入一个catch，优先级从上而下   throws:抛出异常\n  一个方法被覆盖，覆盖他的方法必须抛出相同的异常，或者异常的子类 如果父类方法抛出多个异常，那么重写的子类方法必须抛出那些异常的子集，也就是不能抛出新的异常       自定义异常  自定义异常，需要继承Exception类或者其子类  继承自Exception就变成CheckedException 继承自RuntimeException，就变成Unchecked Exception   自定义重点在构造函数  调用父类Exception的message构造函数 可以自定义自己的成员变量   在程序中采用throw主动抛出异常  异常抛出测试     数组  数组是一种确定大小的储存同种数据的容器 初始化和遍历方法  JCF  容器框架的作用 JCF主要数据结构   列表 集合 映射  List  ArrayList ：for循环遍历最快，迭代器最慢 索引位置适中   遍历快  LinkedList ：for循环遍历最快，迭代器适中，索引位置极慢   插入快  Vector（同步）    和ArrayList类似，可变数组实现的列表\n  Vector同步，适合再 ==多线程== 下使用\n  迭代器\n     Set  确定性：对任意对象都能判定其是否属于某一集合 互异性：集合内每个元素都是不相同的，注意是内容互异 无序性：集合内的顺序无关  java中的集合接口Set   HashSet(基于散列函数的集合，无序，不支持同步)  无序，遍历for快于iterator    LinkedHashSet(基于散列函数和双向链表的集合，可排序的，不支持同步)  存储数据是插入的顺序序，for快于iterator    TreeSet(基于树结构的集合，可排序的，不支持同步)  不可有null，按着从小到大的顺序存储，for快于iterator     HashSet\u0026amp;\u0026amp;LinkedHashSet 的比较是通过hashcode比较的，若想要new的新对象根据自定义要求去重，重写hashcode方法\n 判定两个元素的hashCode是否相同，若不同，返回false 若两者hashCode相同，判定equals方法，若不同，返回false，否则返回true hashCode和equals方法是所有类都有的，因为Object类有 \u0026gt;\u0026gt;TreeSet判断重复利用compareTo方法，实体类需要继承Comparable接口，然后重写CompareTo方法   补充：Integer类重写了CompareTo方法 \u0026gt;    Map  Hashtable 同步，慢，数据量小 t是小写  HashMap 不支持同步，快，数据量大  遍历有iterator方法和KeySet方法（hashMap.get(key)）,KeySet方法速度更快   LinkedHashMap  基于双向链表的维持插入顺序的HashMap   TreeMap  基于红黑树的Map，可以根据key的自然排序，按照key的从大到小或者compareTo方法进行排序输出   Properties 同步，文件形式，数据量小   Util  Arrays\n 补充（fill(数组名，开始位数，结束位数，值)) Arrays.asList(str.split(\u0026ldquo;reg\u0026rdquo;)) 将字符串转化为list  String.join(\u0026ldquo;reg\u0026rdquo;,List) 将list转化为字符串     Collections\n-对象的比较\n  File   文件系统和java是并列的两套系统 File类是文件基本属性操作的主要类 java7提出了NIO包在某些功能上有重要的补充作用      javaIO  java文件处理类都在java.io包中 处理类分成：节点类、包装类（转化类、装饰类）  File   文件系统和java是并列的两套系统 File类是文件基本属性操作的主要类 java7提出了NIO包在某些功能上有重要的补充作用      文件读写 写入文件  写文件  先创建文件，写入数据，关闭文件 FileOutputStream,OutputStreamWriter,BufferWriter BufferWriter  write newLine   try-resource语句，自动关闭资源 关闭最外层的数据流，将会把其上所有的数据流关闭    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  public class testWrite { public static void main(String[] args) { method_1(); // method_2();  } public static void method_1() { FileOutputStream fileOutputStream = null;//节点类，负责写字节  OutputStreamWriter outputStreamWriter = null;//转化类，负责字符到字节的转化  BufferedWriter bufferedWriter = null;//装饰类，负责写字符到缓存区  //三者关系bufferedWriter(OutputStreamWriter(FIleOutputStream)))  try { fileOutputStream = new FileOutputStream(\u0026#34;./temp/abc.txt\u0026#34;); outputStreamWriter = new OutputStreamWriter(fileOutputStream, \u0026#34;UTF-8\u0026#34;); bufferedWriter = new BufferedWriter(outputStreamWriter); // bufferedReader = new BufferedReader(new OutputStreamWriter(new FileOutputStream(\u0026#34;./temp.abc\u0026#34;)));  //一句话的写法  outputStreamWriter.write(\u0026#34;我们是\u0026#34;);//TODO 存疑 javaIO可用outputStreamWrite来输出？  bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;method_1\u0026#34;); bufferedWriter.newLine(); } catch (Exception e) { e.printStackTrace(); }finally { try { bufferedWriter.close();//关闭最后一个，会将所有的底层流全部关闭  } catch (Exception ex) { ex.printStackTrace(); } } } public static void method_2() { //try-resource语句,自动关闭资源  try (BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(\u0026#34;./temp/abc.txt\u0026#34;)))) { bufferedWriter.write(\u0026#34;我们是\u0026#34;); bufferedWriter.newLine(); bufferedWriter.write(\u0026#34;method_2\u0026#34;); bufferedWriter.newLine(); } catch (Exception e) { e.printStackTrace(); } } }    读文件  先打开文件，逐行读入数据，关闭文件 FileInputStream,InputStream,BufferedReader BufferReader  readLine   try-resource语句，自动关闭资源 关闭最外层的数据流，将会把其上所有的数据流关闭    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public class testRead { public static void main(String[] args) { method_1(); System.out.println(\u0026#34;===============\u0026#34;); method_2(); } public static void method_1() { FileInputStream fileInputStream = null; InputStreamReader inputStreamReader = null; BufferedReader bufferedReader = null; String line = \u0026#34;\u0026#34;; try { fileInputStream = new FileInputStream(\u0026#34;./temp/abc.txt\u0026#34;); inputStreamReader = new InputStreamReader(fileInputStream, \u0026#34;UTF-8\u0026#34;); bufferedReader = new BufferedReader(inputStreamReader); // bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\u0026#34;./temp/abc.txt\u0026#34;)));  while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } catch (Exception e) { e.printStackTrace(); }finally { try { bufferedReader.close(); } catch (Exception e) { e.printStackTrace(); } } } public static void method_2() { try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\u0026#34;./temp/abc.txt\u0026#34;)))) { String line = \u0026#34;\u0026#34;; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } } catch (Exception e) { e.printStackTrace(); } } }   尽量使用try-resource方法，自动关闭资源\n二进制文件读写 ####写入\n 写文件  先创建文件，写入数据，关闭文件 FileOutputStream,BufferedOutputStream,DataOutputStream DataOutputStream  flush write/writeBoolean/writeByte/writeChars/writeDouble/writeInt/writeUTF/\u0026hellip;   try-source 语句，自动关闭资源 关闭最外层数据流，将会把其上所有的数据流关闭    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public class testBinWrite { public static void main(String[] args) { method_1(); } public static void method_1() { FileOutputStream fileOutputStream = null; DataOutputStream dataOutputStream = null; BufferedOutputStream bufferedOutputStream = null; try { fileOutputStream = new FileOutputStream(\u0026#34;./temp/def.dat\u0026#34;); dataOutputStream = new DataOutputStream(fileOutputStream); bufferedOutputStream = new BufferedOutputStream(dataOutputStream); dataOutputStream.writeUTF(\u0026#34;a\u0026#34;); dataOutputStream.writeInt(222); dataOutputStream.writeUTF(\u0026#34;b\u0026#34;); } catch (Exception e) { e.printStackTrace(); }finally { try { bufferedOutputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } }    读文件  先打开文件，读入数据，关闭文件 FileInputStream,BufferedInputStream,DataInputStream DataInputStream read/readBoolean/readInt/readChar/readDouble/readFloat/readUTF/\u0026hellip; try-resource语句，自动关闭资源 关闭最外层的数据流，将会把其上所有的数据流关闭    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class testBinRead { public static void main(String[] args) { method_2(); } //try-resource  public static void method_2() { try (DataInputStream dataInputStream = new DataInputStream( new BufferedInputStream(new FileInputStream(\u0026#34;./temp/def.dat\u0026#34;)))) { String a = dataInputStream.readUTF(); int b = dataInputStream.readInt(); String c = dataInputStream.readUTF(); System.out.println(a); System.out.println(b); System.out.println(c); } catch (Exception ex) { ex.printStackTrace(); } } }   总结：\n 理解节点类，转换类，包装类的联合用法 读取需要根据写入的规则进行读取，避免错位 尽量使用try-resource语句，自动关闭资源  zip读入输出 zip\n","permalink":"http://blog.oxide.ink/posts/java/java%E7%AC%94%E8%AE%B001/","summary":"idea  ctrl+shift+v:替换变量名 ctrl+alt+v:抽取并赋值 ctrl+p:查看参数 ctrl+alt+o删除多余包 ctrl+F12 查看当前类中的包 ctrl+shift+enter 自动完成当前语句 ctrl+shift+backspace 返回到上次修改位置 alt+shift+F9 Debug  类转型\u0026amp;多态\u0026amp;契约设计  类转型：子类可以转父类，父类不可以转子类（除非父类对象本身就是子类） 多态：子类转型为父类后，调用普通方法，依旧是子类方法 契约设计：类不会直接使用另一个类，而是采用接口的形式，外部可以“空投”这个接口下的任意子类对象  static、final 和常量设计 static  static 变量：不管有多少个对象，内存中只有一份 static 方法：可以使用类名直接引用，无需 new 对象来引用   静态方法不可以调用动态变量 非静态方法可以调用静态方法 静态方法不可调用非静态方法  static 块：static 块只执行一次，并且 static 块\u0026gt;匿名块\u0026gt;构造函数  单例模式  设计模式：是经过验证的、用于某些特定场合的解决方案 GOF 提出 23 中设计模式；创建型、结构性和行为型 单例模式保证一个类在内存空间中只有一个对象   内部初始化一个单例 private 不可见，getInstance(static 方法)来取出单例对象  final  final 类：没有子类继承 final 方法：不能被子类改写（不能重写，可以重载） final 字段：基本类型被能修改值，对象类型不能修改指针（可以修改内容）  常量\u0026amp;常量池  java 中的常量：static 和 final notes.","title":"Java笔记01"},{"content":"Maven Junit 测试   单元测试：对软件中最小可测试单元进行检查和验证，通常是一个函数/方法（属于白盒测试）\n 集成测试： 将多个单元相互作用，形成一个整体，对整体协调性进行测试    白盒测试： 全面了解程序内部逻辑结构，对所有的逻辑路径都进行测试，一般由程序员完成\n 黑盒测试：又名功能测试，将程序看作不可打开的盒子，一般由独立使用者完成    自动测试：用程序批量、反复的测试程序，并可自动检查程序结果是否满足预定的要求\n 手动测试：手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求    回归测试：修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误\n  深入学习：软件测试-基于问题驱动模式 朱少民\n  Junit   import static 导入该包内的所有静态方法，使用时可不加类名\n  Triangle\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package JavaLearning_Advanced.Maven; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 13:42 */ public class Triangle { public boolean judgeEdges(int a, int b, int c) { boolean result = true; //边长非负性  if (a \u0026lt;= 0 || b \u0026lt;= 0 || c \u0026lt;= 0) { return false; } //两边和大于第三边  if (a+b\u0026lt;=c) { return false;} if (b+c\u0026lt;=a) { return false;} if (c+a\u0026lt;=b) { return false;} return true; } }    testTriangle  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  import JavaLearning_Advanced.Maven.Triangle; import org.junit.Test; import static org.junit.Assert.*; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 13:44 */ public class testTriangle { @Test public void test() { assertEquals(false,new Triangle().judgeEdges(1,2,3)); } }    深入学习：Junit实战（第二版），PetarTahchiey  Java字符编码  尽可能使用UTF-8 读取写入编码保持一致  国际化   Locale 方法\n getAvailableLocales()获取所有可用的locale getDefault()返回默认的Locale    native2ascii.exe\n  ResourceBundle\n 根据Locale要求，加载语言文件 存储语言集合中的K-V对 getString(String key) 返回对应的value    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package JavaLearning_Advanced.International; import java.util.Locale; import java.util.ResourceBundle; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 14:34 */ public class HelloWorld { public static void main(String[] args) { //取得系统默认的国家/语言环境  Locale myLocale = Locale.getDefault(); System.out.println(myLocale);//zh_CN  //根据指定语言，国家环境，加载资源文件  ResourceBundle bundle = ResourceBundle.getBundle(\u0026#34;message\u0026#34;, myLocale); //从资源文件中获取信息  System.out.println(bundle.getString(\u0026#34;hello\u0026#34;)); } }   高级字符编码 正则表达式   学习正则表达式： 精通正则表达式（第三版） Jefferry E.F.Friedl\n  java.util.regex包\n Pattern 正则表达式的编译表示  compile编译一个正则表达式喂Pattern对象 matcher用Pattern对象匹配一个字符串，返回匹配结果   Matcher  IndexMethod(位置方法) //start(),start(int group),end(),end(group) StudyMethod(查找方法) //lookingAt(),find(),find(int start),matches() Replacement(替换方法) //replaceAll(String replacement)      Matcher\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package JavaLearning_Advanced.regex; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:21 */ public class MatcherDemo { private static final String REGEX = \u0026#34;\\\\bdog\\\\b\u0026#34;;//\\b表示边界  private static final String INPUT = \u0026#34;dog dog dog doggie dogg\u0026#34;; public static void main(String[] args) { //检查字符串里有多少个dog  Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); int count = 0; while (matcher.find()) { count++; System.out.println(\u0026#34;Match number\u0026#34; + count); System.out.println(\u0026#34;start()\u0026#34; + matcher.start()); System.out.println(\u0026#34;end()\u0026#34; + matcher.end()); // String f = \u0026#34;fooooooooooooo\u0026#34;; // matcher.lookingAt();//不完全匹配,匹配foo为true // matcher.find();//完全匹配，匹配foo为false  } } }   Replace\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package JavaLearning_Advanced.regex; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:39 */ public class ReplaceDemo { public static void Replace_1() { String REGEX = \u0026#34;a*b\u0026#34;;//*表示限定前面的a可以有0个或者多个  String INPUT = \u0026#34;aavfooabfooabafoobcdd\u0026#34;; String REPLACE = \u0026#34;-\u0026#34;; Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); StringBuffer stringBuffer = new StringBuffer(); // 全部替换  while (matcher.find()) { matcher.appendReplacement(stringBuffer, REPLACE); } //最后将尾巴字符串附加上  matcher.appendTail(stringBuffer); System.out.println(stringBuffer.toString()); } public static void Replace_2() { String REGEX = \u0026#34;dog\u0026#34;;//*表示限定前面的a可以有0个或者多个  String INPUT = \u0026#34;The dog says meow.All dogs say meow\u0026#34;; String REPLACE = \u0026#34;cat\u0026#34;; Pattern pattern = Pattern.compile(REGEX); Matcher matcher = pattern.matcher(INPUT); INPUT = matcher.replaceAll(REPLACE); System.out.println(INPUT); } }    OJ  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package JavaLearning_Advanced.regex; import org.apache.commons.io.Charsets; import org.apache.commons.io.IOUtils; import java.io.InputStream; import java.nio.charset.Charset; import java.util.LinkedList; import java.util.List; import java.util.Scanner; /** * @Description: * @author: Anhlaidh * @date: 2020/3/23 0023 19:55 */ public class String2inputStream { public static void main(String[] args) { //构造字符串列表  List\u0026lt;String\u0026gt; names = new LinkedList\u0026lt;\u0026gt;(); names.add(\u0026#34;xiaohong\u0026#34;); names.add(\u0026#34;xiaoming\u0026#34;); names.add(\u0026#34;Daming\u0026#34;); names.add(\u0026#34;xiaohei\u0026#34;); //合并为一个字符串，以逗号相连  String nameStr = String.join(\u0026#34;,\u0026#34;, names); //将字符串作为默认输入流  InputStream in = IOUtils.toInputStream(nameStr, Charsets.toCharset(\u0026#34;UTF-8\u0026#34;)); //重置系统的输入流  System.setIn(in); //模拟键盘输入，这也是OJ平台测试用例输入的原理  //此处也可以换成一个文件的输入流  Scanner scanner = new Scanner(System.in); scanner.useDelimiter(\u0026#34;,\u0026#34;); while (scanner.hasNext()) { System.out.println(scanner.next()); } } }   xml  常规语法  任何的起始标签都必须有一个结束标签 简化写法，例如，可以写为 大小写敏感，name和Name不一样 每个文件都要有一个根元素 标签必须按合适的顺序进行嵌套，不可错位 所有的特性都必须有值，且在值的周围加上引号 需要转义字符，如\u0026quot;\u0026lt;\u0026ldquo;需要用\u0026lt;代替      转义 符号 意思     \u0026amp;lt; \u0026lt; 小于   \u0026amp;gt; \u0026gt; 大于   \u0026amp;amp; \u0026amp; 和号   \u0026amp;apos; ' 单引号   \u0026amp;quot; \u0026quot; 双引号       注释：\u0026lt;!\u0026ndash; 内容 \u0026ndash;\u0026gt;    xml解析 未完成\nJSON  概念  JavaScript Object Notation ，JS对象表示法 是一种轻量级的数据交换格式 类似XML，更小、更快、更易解析 最早用于JavaScript中，容易解析，最后推广到全语言 尽管使用JavaScript语法，但是独立于编程语言   用途  JSON生成 JSON解析 JSON校验 和JavaBean对象进行互解析  具有一个无参的构造函数 可以包括多个属性，所有属性都是private 每个属性都有对应的Getter/Setter方法 JavaBean 用于封装数据，有可称为POJO(Plain Old notes.Java Object)      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  package JavaLearning_Advanced.Json; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.File; import java.io.IOException; import java.util.Arrays; import java.util.List; /** * @Description: * @author: Anhlaidh * @date: 2020/3/26 0026 21:42 */ public class testJackson { public static void main(String[] args) throws IOException { testJsonObject(); System.out.println(\u0026#34;分割线=====================================================\u0026#34;); testJsonFile(); } private static void testJsonFile() throws IOException { ObjectMapper objectMapper = new ObjectMapper(); //从json文件中加载，并重构为java对象  File json = new File(\u0026#34;temp/json/books.json\u0026#34;); List\u0026lt;Book\u0026gt; books = objectMapper.readValue(json, new TypeReference\u0026lt;List\u0026lt;Book\u0026gt;\u0026gt;() { }); for (Book book : books) { System.out.println(book.getAuthor()); System.out.println(book.getTitle()); } } private static void testJsonObject() throws IOException { ObjectMapper objectMapper = new ObjectMapper(); //构造对象  Person person = new Person(); person.setName(\u0026#34;TOM\u0026#34;); person.setAge(20); person.setScores(Arrays.asList(60, 70, 80)); //将对象解析为json字符串  String jsonStr = objectMapper.writeValueAsString(person); System.out.println(jsonStr); //json字符串重构对象  Person p2 = objectMapper.readValue(jsonStr, Person.class); System.out.println(p2.getName()); System.out.println(p2.getAge()); System.out.println(p2.getScores()); //从json字符串重构JsonNode对象  JsonNode node = objectMapper.readTree(jsonStr); System.out.println(node.get(\u0026#34;name\u0026#34;).asText()); System.out.println(node.get(\u0026#34;age\u0026#34;).asText()); System.out.println(node.get(\u0026#34;scores\u0026#34;)); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  [ { \u0026#34;category\u0026#34;: \u0026#34;COOKING\u0026#34;, \u0026#34;tools.title\u0026#34;: \u0026#34;Everyday Italian\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Giada De Laurentiis\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2005\u0026#34;, \u0026#34;price\u0026#34;: 30 }, { \u0026#34;category\u0026#34;: \u0026#34;CHILDREN\u0026#34;, \u0026#34;tools.title\u0026#34;: \u0026#34;Harry Potter\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;J K Rowling\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2005\u0026#34;, \u0026#34;price\u0026#34;: 29 }, { \u0026#34;category\u0026#34;: \u0026#34;WEB\u0026#34;, \u0026#34;tools.title\u0026#34;: \u0026#34;Learning XML\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Erik T.Ray\u0026#34;, \u0026#34;year\u0026#34;: \u0026#34;2003\u0026#34;, \u0026#34;price\u0026#34;: 39 } ]    总结  JSON是一种独立于编程语言的、轻量的、数据交换格式 有多种第三方库辅助我们进行JSON生成和解析 JSON会丢失顺序性    图片 - imageIO\r- 验证码\r 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  package JavaLearning_Advanced.picture; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.Random; /** * @Description: * @author: Anhlaidh * @date: 2020/3/28 0028 19:56 */ public class ValidateCode { static char[] codeSequence= {\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;G\u0026#39;,\u0026#39;H\u0026#39;,\u0026#39;I\u0026#39;,\u0026#39;J\u0026#39;,\u0026#39;K\u0026#39;,\u0026#39;L\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;N\u0026#39;,\u0026#39;O\u0026#39;,\u0026#39;P\u0026#39;,\u0026#39;Q\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;S\u0026#39;,\u0026#39;T\u0026#39;,\u0026#39;U\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Z\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;}; static int charNum = codeSequence.length; public static void main(String[] args) throws IOException { generateCode(\u0026#34;./temp/validateCode/code.jpg\u0026#34;); } private static void generateCode(String filePath) throws IOException { //首先定义验证码图片库  int width = 140;//验证码图片的宽度  int height = 40;//验证码图片的高度  BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //定义图片上的图形和干扰线  Graphics2D graphics2D = bufferedImage.createGraphics(); graphics2D.setColor(Color.GRAY);//将图像填充为浅灰色  graphics2D.fillRect(0, 0, width, height); graphics2D.setColor(Color.BLACK);//画边框  graphics2D.drawRect(0, 0, width - 1, height - 1); //随机产生16条灰色干扰线  graphics2D.setColor(Color.darkGray); //创建一个随机数生成器类，用于随机产生干扰线  Random random = new Random(); for (int i = 0; i \u0026lt; 16; i++) { int x = random.nextInt(width); int y = random.nextInt(height); int x1 = random.nextInt(50); int y1 = random.nextInt(50); graphics2D.drawLine(x, y, x1, y1); } //计算字的位置坐标  int codeCount = 4;//字的个数  int fontHeight ;//字体高度  int codeX;//第一个字符的x坐标，因为后面的字符坐标依次递增，所以他们的x轴值是codeX+i的值  int codeY;//验证字符的y坐标，因为并排所以值一样  //width-4除去左右多余的位置，使验证码更加集中显示，减的越多越集中  //codeCount+1//等比分配显示的宽度，包括左右两边的空格  codeX = (width - 4) / (codeCount + 1);//第一个字母的起始位置  fontHeight = height - 10;//height-10高度中间区域显示验证码  codeY = height - 7; //创建字体，字体的大小应该根据图片的高度来定  Font font = new Font(\u0026#34;Fixedsys\u0026#34;, Font.PLAIN, fontHeight); graphics2D.setFont(font); //随机产生codeCount数字的验证码  for (int i = 0; i \u0026lt; codeCount; i++) { //每次随机拿一个字母，赋予随机的颜色  String strRand = String.valueOf(codeSequence[random.nextInt(charNum)]); int red = random.nextInt(255); int blue = random.nextInt(255); int green = random.nextInt(255); graphics2D.setColor(new Color(red, green, blue)); //把字放到图片上  graphics2D.drawString(strRand, (i + 1) * codeX, codeY); } ImageIO.write(bufferedImage, \u0026#34;jpg\u0026#34;, new File(filePath)); } }   多进程和多线程 概念 多进程  当前的操作系统都是多任务OS 每个独立执行的任务就是一个进程 OS将时间划分为多个时间片（时间很短） 每个时间片内将CPU分配给某一个任务，时间片结束，CPU自动回收，再分配给另外任务。从外部看，所有任务都是同时在执行。 但是在CPU上，任务是按照串行依次运行（单核CPU ）。如果多核，多个进程任务可以并行。但是单个核上，多进程只能串行执行 多进程的优点  可以同时运行多个任务 程序因IO堵塞时，可以释放CPU，让CPU为其他程序服务 当系统有多个CPU时，可以为多个程序同时服务  我们的CPU不再提高频率，而是提高核数 多核和并行程序才是提高程序性能的唯一办法     多进程的缺点  太笨重，不好管理 太笨重，不好切换    多线程  一个程序可以包括多个子任务，可串/并行 每个子任务可以称为一个线程 如果一个子任务阻塞，程序可以将CPU调度另外一个子任务进行工作，这样CPU还是保留在本程序中，而不是被调度到别的程序（进程）去， 这样，提高本程序获得CPU时间和利用率  启动  start方法，会自动以新进程调用run方法 直接调用run方法，会编程串行执行 同一个线程，多次start会报错，只执行第一次start方法 多个线程启动，其启动的先后顺序是随机的 线程无需关闭，只要其run方法执行结束后，自动关闭 main函数（线程）可能早于新线程结束，整个程序并不终止 整个程序终止是等所有的线程都终止（包括main函数线程）  ####多线程实现的对比\n Thread占据了父类名额，不如Runnable方便 Thread类实现Runnable Runnable启动时需要Thread类的支持 Runnable更容易实现多线程中资源共享  结论：建议实现Runnable接口来完成多线程\n规则 规则一： 1.调用run方法来启动run方法，将会是串行运行 2. 调用start方法，来启动run方法，将会是并行运行（多线程运行） 规则二：\n main线程可能早于子线程结束 main线程和子线程都结束了，整个程序才算终止 规则三： 1.实现Runnable的对象必须包装在Thread类里面，才可以启 不能直接对Runnable对象进行start方法 规则四： 一个线程对象不能多次start，多次start将报异常 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定  一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则一： * 1.调用run方法来启动run方法，将会是串行运行 * 2. 调用start方法，来启动run方法，将会是并行运行（多线程运行） * * @author: Anhlaidh * @date: 2020/3/28 0028 22:59 */ public class first { public static void main(String[] args) throws InterruptedException { new TestThread0().run(); while (true) { System.out.println(\u0026#34;main\u0026#34;); Thread.sleep(10); } } } class TestThread0 extends Thread{ @Override public void run() { while (true) { System.out.println(\u0026#34;testThread0\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }   二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则二： * 1. main线程可能早于子线程结束 * 2. main线程和子线程都结束了，整个程序才算终止 * @author: Anhlaidh * @date: 2020/3/28 0028 23:06 */ public class second { public static void main(String[] args) throws InterruptedException { new TestThread1().start(); // while (true) { // System.out.println(\u0026#34;main\u0026#34;); // Thread.sleep(10); // }  } } class TestThread1 extends Thread{ @Override public void run() { while (true) { System.out.println(\u0026#34;testThread1\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }   三:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则三： * 1.实现Runnable的对象必须包装在Thread类里面，才可以启动 * 2. 不能直接对Runnable对象进行start方法 * @author: Anhlaidh * @date: 2020/3/28 0028 23:33 */ public class third { public static void main(String[] args) throws InterruptedException { // new TestThread2().start();  //runnable对象必须放在一个Thread类中才能运行  TestThread2 tt = new TestThread2(); Thread thread = new Thread(tt); thread.start(); while (true) { System.out.println(\u0026#34;main\u0026#34;); Thread.sleep(1000); // }  } } } class TestThread2 implements Runnable { @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName()); //输出当前线程名  try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }   四：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  package JavaLearning_Advanced.thread.rules; /** * @Description: * 规则四： * 1. 一个线程对象不能多次start，多次start将报异常 * 2. 多个线程对象都start后，哪一个先执行，完全由JVM/操作系统来主导，程序员无法指定 * @author: Anhlaidh * @date: 2020/3/28 0028 23:39 */ public class Fourth { public static void main(String[] args) { TestThread4 t1 = new TestThread4(); t1.start(); // t1.start();  TestThread4 t2 = new TestThread4(); t2.start(); } } class TestThread4 extends Thread { @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName()+\u0026#34;is running\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }   多进程和多线程的对比  线程共享数据 线程通讯更高效 线程更轻量级，更容易切换 多个线程更容易管理  多线程信息共享  线程类  通过继承Thread或实现Runnable 通过start方法，调用run方法，run方法工作 线程run结束后，线程退出   粗粒度：子线程与子线程之间、和main线程之间缺乏交流 细粒度：线程之间有信息交流通讯  通过共享变量达到信息共享 Jdk原生库不支持发送消息   通过共享变量在多个线程中共享消息  static变量 同一个Runnable类的成员变量    test1:继承thread，static修饰的变量可以共享，但是会造成数据重复\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 20:23 */ public class ThreadDemo0 { public static void main(String[] args) { new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); new TestThread0().start(); } private static class TestThread0 extends Thread { // private int tickets = 100; 每个线程卖100张，没有共享  private static int tickets = 100; //static变量是共享的，所有的线程共享  @Override public void run() { while (tickets\u0026gt;0) { System.out.println(Thread.currentThread().getName() + \u0026#34; is selling tickets\u0026#34; + tickets); tickets = tickets - 1; } } } }    多线程信息共享问题  工作缓存副本 关键步骤缺乏加锁限制   i++，并非原子性操作  读取主存i（正本）到工作缓存（副本）中 每个CPU执行（副本）i+1操作 CPU将结果写入到缓存（副本）中 数据从工作缓存（副本）刷到主存（正本）中   变量副本问题的解决办法  采用volatile关键字修饰变量 保证不同线程对共享变量操作时的可见性    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 20:55 */ public class ThreadDemo2 { public static void main(String[] args) throws InterruptedException { TestTread3 testTread3 = new TestTread3(); testTread3.start(); Thread.sleep(1000); testTread3.flag = false; System.out.println(\u0026#34;main thread is exiting\u0026#34;); } private static class TestTread3 extends Thread { // boolean flag = true;//子线程不会停止  volatile boolean flag = true;//用volatile修饰的变量可以及时在各线程里面通知  @Override public void run() { int i = 0; while (flag) { i++; } System.out.println(\u0026#34;test thread is exiting\u0026#34;); } } }    关键步骤加锁限制  互斥：某一个线程运行一个代码段（关键区），其他线程不能同时运行这个代码段 同步：多个线程的运行，必须按照某一种规定的先后顺序来运行 互斥是同步的一种特例   互斥的关键字是synchronized  synchronized代码块/函数，只能一个线程进入 synchronized能加大性能负担，但是使用简便    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package JavaLearning_Advanced.thread.message; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 21:16 */ public class ThreadDemo3 { public static void main(String[] args) { TestThread3 testThread3 = new TestThread3(); new Thread(testThread3).start(); new Thread(testThread3).start(); new Thread(testThread3).start(); new Thread(testThread3).start(); } private static class TestThread3 implements Runnable { private volatile int tickets = 100; @Override public void run() { while (tickets\u0026gt;0) { sale(); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } private synchronized void sale() { System.out.println(Thread.currentThread().getName() + \u0026#34; sale \u0026#34; + tickets--); } } }   多线程管理   线程状态\n NEW 刚创建（new） RUNNABLE就绪态（start） RUNNING运行中（run） BLOCK阻塞（sleep） TERMINATED 结束    Thread的部分API已经废弃\n 暂停和恢复：suspend/resume 消亡：stop/destroy    线程阻塞/和唤醒\n sleep，时间一到，自己就会醒来 wait/notify/notifyAll，等待，需要别人来唤醒 join，等待另一个线程结束 interrupt，向另外一个线程发送中断信号，该线程收到信号，会触发 Interrupted Exception（可接触阻塞），并进入下一步处理    线程类\n  主动interrupt\n  被动interrupt\n  多线程死锁\n 每个线程相互持有别人需要的锁（哲学家吃面问题） 预防死锁，对资源进行等级排序    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  package JavaLearning_Advanced.thread.Interrupt; import java.util.concurrent.TimeUnit; /** * @Description: * @author: Anhlaidh * @date: 2020/4/7 0007 22:05 */ public class DeadLock { public static Integer r1 = 1; public static Integer r2 = 2; public static void main(String[] args) { Thread1 t1 = new Thread1(); t1.start(); Thread2 t2 = new Thread2(); t2.start(); } } class Thread1 extends Thread { @Override public void run() { //先要r1再要r2  synchronized (DeadLock.r1) { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (DeadLock.r2) { System.out.println(\u0026#34;Thread1 is running\u0026#34;); } } } } class Thread2 extends Thread { @Override public void run() { //先要r2再要r1  synchronized (DeadLock.r2) { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (DeadLock.r1) { System.out.println(\u0026#34;Thread2 is running\u0026#34;); } } } }    守护（后台）线程  普通线程的结束，是run方法运行结束 守护线程的结束，是run方法运行结束，或main函数结束 守护线程永远不要访问资源，如文件或数据库等    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  package JavaLearning_Advanced.thread.Interrupt; /** * @Description: * @author: Anhlaidh * @date: 2020/4/7 0007 22:19 */ public class protect { public static void main(String[] args) throws InterruptedException { Thread3 t = new Thread3(); t.setDaemon(true); t.start(); Thread.sleep(2000); System.out.println(\u0026#34;main thread is exiting\u0026#34;); } } class Thread3 extends Thread { @Override public void run() { while (true) { try { Thread.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;running\u0026#34;); } } }    线程查看工具jvisualvm  并发框架   业务：任务多，数据量大\n  串行 并行\n 串行编程简单，并行编程困难 单个计算核频率下降，计算核数增多，整体性能变高    并行困难（任务分配和执行过程高度耦合）\n 如何控制粒度，切割任务 如何分配任务给线程，监督线程执行过程    并行计算  并行模式  主从模式(Master-Slave) Worker模式(Worker-Worker)   Java并发编程  Thread/Runnable/Thread组管理 Executor(重点) Fork-Join框架    线程组管理  线程组ThreadGroup  线程的集合 树形结构,大线程可以包括小线程组 可以通过enumerate方法遍历组内的线程,执行操作 能够有效管理多个线程,但是管理效率低 任务分配和执行过程高度耦合 重复创建线程,关闭线程操作,无法重用线程    Executor*  从jdk5开始提供Executor FrameWork  分离任务的创建和执行者的创建 线程重复利用(new线程代价很大)   理解共享线程池的概念  预设好的多个Thread,可弹性增加 多次执行很多很小的任务 任务创建和执行过程解耦 程序员无需关心线程池执行任务过程    Main:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  package JavaLearning_Advanced.thread.Executor.example2; import java.util.ArrayList; import java.util.List; import java.util.concurrent.ExecutionException; import java.util.concurrent.Executors; import java.util.concurrent.Future; import java.util.concurrent.ThreadPoolExecutor; /** * @Description: * @author: Anhlaidh * @date: 2020-04-08 22:15 */ public class SumTest { public static void main(String[] args) { //执行线程池  ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(8); List\u0026lt;Future\u0026lt;Integer\u0026gt;\u0026gt; resultList = new ArrayList\u0026lt;\u0026gt;(); //统计1-1000总和,分成10个任务计算,提交任务  for (int i = 0; i \u0026lt; 10; i++) { SumTask calculator = new SumTask(i*100+1,(i+1)*100); Future\u0026lt;Integer\u0026gt; result = executor.submit(calculator); resultList.add(result); } //每隔50毫秒,轮询等待10个任务结束  do { System.out.printf(\u0026#34;Main:已经完成了多少个任务:%d\\n\u0026#34;, executor.getCompletedTaskCount()); for (int i = 0; i \u0026lt; resultList.size(); i++) { Future\u0026lt;Integer\u0026gt; result = resultList.get(i); System.out.printf(\u0026#34;Main Task %d:%s\\n\u0026#34;, i, result.isDone()); } try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (executor.getCompletedTaskCount() \u0026lt; resultList.size()); //所有任务都已经结束,综合计算结果  int total = 0; for (int i = 0; i \u0026lt; resultList.size(); i++) { Future\u0026lt;Integer\u0026gt; result = resultList.get(i); Integer sum = null; try { sum = result.get(); total = total + sum; } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } System.out.println(\u0026#34;1-1000的总和\u0026#34; + total); } }   SumTask:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package JavaLearning_Advanced.thread.Executor.example2; import java.util.Random; import java.util.concurrent.Callable; /** * @Description: * @author: Anhlaidh * @date: 2020-04-08 22:17 */ public class SumTask implements Callable { private int startNumber; private int endNumber; public SumTask(int startNumber, int endNumber) { this.startNumber = startNumber; this.endNumber = endNumber; } @Override public Integer call() throws Exception { int sum = 0; for (int i = startNumber; i \u0026lt;= endNumber; i++) { sum = sum + i; } Thread.sleep(new Random().nextInt(1000)); System.out.printf(\u0026#34;%s:%d\u0026#34;, Thread.currentThread().getName(), sum); return sum; } }   Fork-Join  关键类  ForkJoinPool 任务池 RecursiveAction RecursiveTask Main:    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package JavaLearning_Advanced.thread.Fork_Join; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; /** * @Description: * @author: Anhlaidh * @date: 2020-04-09 13:37 */ public class SumTest { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建执行线程池  ForkJoinPool pool = new ForkJoinPool(8); //创建任务  SumTask task = new SumTask(1,1000000); //提交任务  ForkJoinTask\u0026lt;Long\u0026gt; result = pool.submit(task); //等待结果  do { System.out.printf(\u0026#34;Main:Thread Count:%d\\n\u0026#34;, pool.getActiveThreadCount()); System.out.printf(\u0026#34;Main:Parallelism:%d\\n\u0026#34;, pool.getParallelism()); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (!task.isDone()); //输出结果  System.out.println(result.get().toString()); } }   SumTask\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package JavaLearning_Advanced.thread.Fork_Join; import java.util.concurrent.ExecutionException; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.ForkJoinTask; /** * @Description: * @author: Anhlaidh * @date: 2020-04-09 13:37 */ public class SumTest { public static void main(String[] args) throws ExecutionException, InterruptedException { //创建执行线程池  ForkJoinPool pool = new ForkJoinPool(8); //创建任务  SumTask task = new SumTask(1,1000000); //提交任务  ForkJoinTask\u0026lt;Long\u0026gt; result = pool.submit(task); //等待结果  do { System.out.printf(\u0026#34;Main:Thread Count:%d\\n\u0026#34;, pool.getActiveThreadCount()); System.out.printf(\u0026#34;Main:Parallelism:%d\\n\u0026#34;, pool.getParallelism()); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } } while (!task.isDone()); //输出结果  System.out.println(result.get().toString()); } }   主要类  ExecutorService,ThreadPoolExecutor,Future  Executors.newCachedThreadPool/newFixedThreadPool创建线程池 ExecutorService线程池服务 Callable 具体的逻辑对象(线程类) Future返回结果    并发数据结构  阻塞式集合:当集合为空或者满时,等待 非阻塞式集合:当集合为空或者满时,不等待,返回null或异常  -List\n Vector 同步安全,写多读少 ArrayList 不安全 Collections.synchronizedList(List list) 基于synchronized,效率差 CopyOnWriteArrayList 读多写少,基于复制机制,非阻塞 Set  HashSet不安全 Collections.synchronizedSet(Set set)基于synchronized,效率差 CopyOnWriteArraySet (基于CopyOnWriteArrayList实现),读多写少,非阻塞   Map  Hashtable 同步安全,写多读少 HashMap 不安全 Collections.synchronizedMap(Map map)基于synchronized,效率差 ConcurrentHashMap,读多写少,非阻塞   Queue\u0026amp;Deque  ConcurrentLinkedQueue非阻塞 ArrayBlockingQueue/LinkedBlockingQueue阻塞    并发协作与控制 Lock  买奶茶,读写锁,互斥锁\n  Lock也可以实现同步的效果  实现更复杂的临界区结构 tryLock方法可以预判锁是否空闲 允许分离读写的操作,多个读,一个写 性能更好   ReentrantLock 类,可重入的互斥锁 ReentrantReadWriteLock类,可重入的读写锁 lock和unlock函数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128  package notes.Java.JavaLearning_Advanced.thread.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.concurrent.locks.ReentrantReadWriteLock; /** * @Description: * @author: Anhlaidh * @date: 2020-05-07 16:41 */ public class LockExample { private static final ReentrantLock queueLock = new ReentrantLock();//可重入锁  private static final ReentrantReadWriteLock orderLock = new ReentrantReadWriteLock();//可读写锁  /** * 有家奶茶店,点单时需要排队 * 假设想买奶茶的人如果看到需要排队就等等 * 假设奶茶店又老板和多名员工,记单方式比较原始,只有一个订单本 * 老板负责写新订单,员工不断查看订单本得到信息来制作奶茶,在老板写订单时员工不可以看订单本 * 多个员工可同时看订单本,但此时老板不可写入订单本 * @param args args */ public static void main(String[] args) { // byMilkTea();  handleOrder(); } private static void byMilkTea() { LockExample lockExample = new LockExample(); int CUSTOMER_CNT = 10; Thread[] customers = new Thread[CUSTOMER_CNT]; for (int i = 0; i \u0026lt; CUSTOMER_CNT; i++) { customers[i] = new Thread(new Runnable() { @Override public void run() { try { long walkingTime = (long) (Math.random() * 1000); Thread.sleep(walkingTime); lockExample.tryToBuyMilkTea(); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } }); customers[i].start(); } } private void tryToBuyMilkTea() throws InterruptedException { boolean flag = true; while (flag) { if (queueLock.tryLock()) { // queueLock.lock();  long thinkingTime = (long) (Math.random() * 500); Thread.sleep(thinkingTime); System.out.println(Thread.currentThread().getName() + \u0026#34;:来一杯奶茶,不要珍珠\u0026#34;); flag = false; queueLock.unlock(); } else { System.out.println(Thread.currentThread().getName()+\u0026#34;:再等等\u0026#34;); } if (flag) { Thread.sleep(1000); } } } private static void handleOrder() { LockExample lockExample = new LockExample(); Thread boss = new Thread(new Runnable() { @Override public void run() { while (true) { try { lockExample.addOrder(); long waitingTime = (long) (Math.random() * 1000); Thread.sleep(waitingTime); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } } }); boss.start(); int WORKER_CNT = 3; Thread[] workers = new Thread[WORKER_CNT]; for (int i = 0; i \u0026lt; WORKER_CNT; i++) { workers[i] = new Thread(new Runnable() { @Override public void run() { while (true) { try { lockExample.viewOrder(); long workingTime = (long) (Math.random() * 5000); Thread.sleep(workingTime); } catch (InterruptedException e) { System.out.println(e.getMessage()); } } } }); workers[i].start(); } } private void viewOrder() throws InterruptedException { orderLock.readLock().lock(); long readingTime = (long) (Math.random() * 500); Thread.sleep(readingTime); System.out.println(Thread.currentThread().getName()+\u0026#34;:查看订单\u0026#34;); orderLock.readLock().unlock(); } private void addOrder() throws InterruptedException { orderLock.writeLock().lock(); long writingTime = (long) (Math.random() * 1000); Thread.sleep(writingTime); System.out.println(\u0026#34;老板新加一笔订单\u0026#34;); orderLock.writeLock().unlock(); } }   Semaphore  抢车位,车位满了不可停车,其他等着\n  信号量:由1965年Dijkstra提出 信号量:本质上是一个计数器 计数器大于0,可以使用,等于0不能使用 可以设置多个并发量,例如限制10个访问 Semaphore  acquire获取 release释放   比lock更进一步,可以控制多个同时访问关键区  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  package notes.Java.JavaLearning_Advanced.thread.Semaphore; import java.util.concurrent.Semaphore; /** * @Description: * @author: Anhlaidh * @date: 2020-05-07 17:48 */ public class SemaphoreExample { private final Semaphore placeSemaphore = new Semaphore(5); public boolean parking() { if (placeSemaphore.tryAcquire()) { System.out.println(Thread.currentThread().getName() + \u0026#34;停车成功\u0026#34;); return true; } else { System.out.println(Thread.currentThread().getName() + \u0026#34;没有空位\u0026#34;); return false; } } public void leaving() { placeSemaphore.release(); System.out.println(Thread.currentThread().getName()+\u0026#34;:开走\u0026#34;); } /** * 一个车库,五个车位,十辆车需要停放,每次停放时,申请信号量 * @param args args * @throws InterruptedException exception */ public static void main(String[] args) throws InterruptedException { int tryToParkCnt = 10; SemaphoreExample semaphoreExample = new SemaphoreExample(); Thread[] parkers = new Thread[tryToParkCnt]; for (int i = 0; i \u0026lt; tryToParkCnt; i++) { parkers[i] = new Thread(new Runnable() { @Override public void run() { try { long randomTime = (long) (Math.random() * 1000); Thread.sleep(randomTime); if (semaphoreExample.parking()) { long parkingTime = (long) (Math.random() * 1000); Thread.sleep(parkingTime); semaphoreExample.leaving(); } } catch (InterruptedException e) { System.out.println(e.getMessage()); } } }); parkers[i].start(); } for (int i = 0; i \u0026lt; tryToParkCnt; i++) { parkers[i].join(); } } }   latch  百米赛跑,发令枪归零同时起跑(startSignal),运动员依次就位(doneSignal)\n  等待锁,是一个同步辅助类 用来同步执行任务的一个或者多个线程 不是用来保护临界区或者资源共享 CountDownLatch  countDown() 计数-1 await() 等待latch变成0    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package notes.Java.JavaLearning_Advanced.thread.CountDownLatch; import java.util.concurrent.CountDownLatch; /** * @Description: * @author: Anhlaidh * @date: 2020-05-08 10:58 */ public class CountDownLatchExample { /** * 设想百米赛跑比赛,发令枪发出信号后选手开始跑,全部选手跑到终点后比赛结束 * @param args args * @throws InterruptedException Interrupted Exception */ public static void main(String[] args) throws InterruptedException { int runnerCnt = 10; CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(runnerCnt); for (int i = 0; i \u0026lt; runnerCnt; i++) {//create and start threads  new Thread(new Worker(startSignal,doneSignal)).start(); } System.out.println(\u0026#34;准备工作\u0026#34;); System.out.println(\u0026#34;准备工作就绪\u0026#34;); startSignal.countDown();//let all thread proceed  System.out.println(\u0026#34;比赛开始\u0026#34;); doneSignal.await();//wait for all to finish  } private static class Worker implements Runnable { private final CountDownLatch startSignal; private final CountDownLatch downSignal; public Worker(CountDownLatch startSignal, CountDownLatch downSignal) { this.startSignal = startSignal; this.downSignal = downSignal; } @Override public void run() { try { startSignal.await(); Thread.sleep((long)(Math.random()*500)); doWork(); downSignal.countDown(); } catch (InterruptedException e) { //return;  } } private void doWork() { System.out.println(Thread.currentThread().getName()+\u0026#34;:跑完全程\u0026#34;); } } }   Barrier  分步计算总和\n  集合点,也是一个同步辅助类 允许多个线程在某一个点上进行同步 CyclicBarrier  构造函数是需要同步的线程数量 await等待其他线程,达到数量后就放行    Phaser  允许执行并发多阶段任务,同步辅助类 在每一个阶段结束的位置对线程进行同步,当所有线程都到达这步,再进行下一步 Phaser  arrive() arriveAndAwaitAdvance()    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  package notes.Java.JavaLearning_Advanced.thread.Phaser; import java.util.concurrent.Phaser; /** * @Description: * @author: Anhlaidh * @date: 2020-05-08 19:46 */ public class PhaserExample { /** * 假设举行考试,总共三个答题,每次下发一道题目,等所有学生完成后再进行下一道 * @param args */ public static void main(String[] args) { int STUDENT_CNT = 5; Phaser phaser = new Phaser(STUDENT_CNT); for (int i = 0; i \u0026lt; STUDENT_CNT; i++) { new Thread(new Student(phaser)).start(); } } private static class Student implements Runnable { private final Phaser phaser; public Student(Phaser phaser) { this.phaser = phaser; } @Override public void run() { try { doTesting(1); phaser.arriveAndAwaitAdvance(); doTesting(2); phaser.arriveAndAwaitAdvance(); doTesting(3); phaser.arriveAndAwaitAdvance(); } catch (InterruptedException e) { e.printStackTrace(); } } private void doTesting(int i) throws InterruptedException { String name = Thread.currentThread().getName(); System.out.println(name + \u0026#34;开始第\u0026#34; + i + \u0026#34;题\u0026#34;); long thinkingTime = (long) (Math.random() * 1000); Thread.sleep(thinkingTime); System.out.printf(\u0026#34;%s第%d到题答题结束\\n\u0026#34;,name,i); } } }   Exchanger  双向交换数据\n  允许在并发线程中相互交换消息 允许在2个线程种定义同步点,当两个线程都达到同步点,他们交换数据结构 Exchanger  exchange(),线程双方互相交换数据 交换数据是双向的    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  package notes.Java.JavaLearning_Advanced.thread.Exchanger; import java.util.Scanner; import java.util.concurrent.Exchanger; /** * @Description: * @author: Anhlaidh * @date: 2020-05-10 17:16 */ public class ExchangerExample { /** * 通过Exchanger实现学生成绩查询,简单线程间的数据交换 * @param args */ public static void main(String[] args) throws InterruptedException { Exchanger\u0026lt;String\u0026gt; exchanger = new Exchanger\u0026lt;String\u0026gt;(); BackgroundWorker worker = new BackgroundWorker(exchanger); new Thread(worker).start(); Scanner reader = new Scanner(System.in); while (true) { System.out.println(\u0026#34;输出要查询的的属性学生姓名:\u0026#34;); String input = reader.nextLine().trim(); exchanger.exchange(input); String value = exchanger.exchange(null); if (\u0026#34;exit\u0026#34;.equals(value)) { break; } System.out.println(\u0026#34;查询结果\u0026#34; + value); } reader.close(); } private static class BackgroundWorker implements Runnable{ final Exchanger\u0026lt;String\u0026gt; exchanger; public BackgroundWorker(Exchanger\u0026lt;String\u0026gt; exchanger) { this.exchanger = exchanger; } @Override public void run() { while (true) { try { String item = exchanger.exchange(null); switch (item) { case \u0026#34;zhangsan\u0026#34;: exchanger.exchange(\u0026#34;90\u0026#34;); break; case \u0026#34;lisi\u0026#34;: exchanger.exchange(\u0026#34;80\u0026#34;); break; case \u0026#34;wangwu\u0026#34;: exchanger.exchange(\u0026#34;70\u0026#34;); break; case \u0026#34;exit\u0026#34;: exchanger.exchange(\u0026#34;exit\u0026#34;); default: exchanger.exchange(\u0026#34;none\u0026#34;); } } catch (InterruptedException e) { e.printStackTrace(); } } } } }   定时任务  简单定时机制  设置计划任务,也就是在指定的时间开始执行某一个任务 TimerTask封装任务 Timer类 定时器   Timer  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  package notes.Java.JavaLearning_Advanced.thread.Timer; import java.util.Calendar; import java.util.Date; import java.util.Timer; import java.util.TimerTask; /** * @Description: * @author: Anhlaidh * @date: 2020-05-10 17:42 */ public class TimerTest { public static void main(String[] args) throws InterruptedException { MyTask myTask = new MyTask(); Timer timer = new Timer(); System.out.println(\u0026#34;当前时间:\u0026#34; + new Date().toLocaleString()); //当前时间一秒后,每两秒执行一次  timer.schedule(myTask,1000,2000); Thread.sleep(10000); myTask.cancel();//取消当前任务  System.out.println(\u0026#34;==============\u0026#34;); Calendar now = Calendar.getInstance(); now.set(Calendar.SECOND, now.get(Calendar.SECOND) + 3); Date runDate = now.getTime(); MyTask2 myTask2 = new MyTask2(); timer.scheduleAtFixedRate(myTask2,runDate,3000); } private static class MyTask extends TimerTask { @Override public void run() { System.out.println(\u0026#34;运行了!时间为:\u0026#34;+new Date()); } } private static class MyTask2 extends TimerTask{ @Override public void run() { System.out.println(\u0026#34;运行了!时间为:\u0026#34;+new Date()); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } } }    Executor+定时器机制 ScheduledExecutorService  定时任务 周期任务   Quartz  Quartz是一个较为完善的任务调度框架 解决程序中Timer零散管理的问题 功能更加强大  Timer执行周期任务,如果中间有一次有一场,整个任务终止执行 Quartz执行周期任务,如果中间某一次有异常,不影响下次任务执行      ​\nJava网络编程 网络基础知识   网络是当前信息技术的第一推动力\n  每个计算设备上都有若干个网卡\n  每个网卡上有（全球唯一）单独的硬件地址，MAC地址\n  ip地址\n IPV4 192.169.0.1每段0-255 IPV6 128bit长，8段，每段4个16进制数 ipconfig ifconfig    port:端口 0~65535\n 0~1023OS已经占用了，80是web，23是telnet 1024~65535，一般程序可使用（谨防冲突）    两台机器通讯就是在IP+port上进行的\n netstat -an    保留ip：127.0.0.1 本机\n  公网（万维网/互联网）和内网（局域网）\n 网络上分层的 最外层的是外网/互联网 底下每层都是内网 ip地址可以在每个层次的网重用 tracert 看当前及其和目标机器的访问中继    通讯协议TCP UDP\n TCP(Transmission Control Protocol)  传输控制协议，面向连接的协议 两台机器的可靠无差错的数据传输 双向字节流传递   UDP(User Datagram Protocol) \u0026ndash;\u0026gt;QQ(多次UDP模仿TCP) 用户数据报协议，面向无连接协议 不保证可靠的数据传输 速度快，也可以在较差的网络下使用    UDP  计算机通讯：数据从一个IP的port出发（发送方），运输到另外一个IP的port（接收方） UDP：无连接无状态的通讯协议  发送方发送消息，如果接收方刚好在目的地，则可以接受，如果不在 那这个消息就丢失了 发送方也无法得知是否发送成功 UDP的好处就是简单节省，经济    实例  DatagramSocket:通讯的数据管道  send和receive方法 （可选，多网卡）绑定一个IP和Port   DatagramPacket  集装箱：封装数据 地址标签：目的地IP+Port Receive:    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package JavaLearning_Advanced.UDP; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; /** * @Description: receive * @author: Anhlaidh * @date: 2020/3/29 0029 0:23 */ public class UdpRecv { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(3000); byte[] buf = new byte[1024]; DatagramPacket packet = new DatagramPacket(buf,buf.length); System.out.println(\u0026#34;UdpRecv：等待信息\u0026#34;); socket.receive(packet); System.out.println(\u0026#34;UdpRecv:已接受信息\u0026#34;); String strRecv = new String(packet.getData(), 0, packet.getLength()) + \u0026#34;from\u0026#34; + packet.getAddress().getHostAddress() + \u0026#34;:\u0026#34; + packet.getPort(); System.out.println(strRecv); String str = \u0026#34;nice to meet you!!\u0026#34;; DatagramPacket packet1 = new DatagramPacket(str.getBytes(), str.length(), packet.getAddress(), packet.getPort()); System.out.println(\u0026#34;UdpRecv:即将发送信息！\u0026#34;); socket.send(packet1); System.out.println(\u0026#34;UdpRecv:已发送\u0026#34;); } }   send:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  package JavaLearning_Advanced.UDP; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; /** * @Description: send * @author: Anhlaidh * @date: 2020/3/29 0029 0:24 */ public class UdpSend { public static void main(String[] args) throws Exception{ DatagramSocket socket = new DatagramSocket(); String str = \u0026#34;hi ,im a mini robot\u0026#34;; DatagramPacket packet = new DatagramPacket(str.getBytes(), str.length(), InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;), 3000); System.out.println(\u0026#34;UdpSend:我要发送信息了\u0026#34;); socket.send(packet); System.out.println(\u0026#34;UdpSend: 发送完毕\u0026#34;); Thread.sleep(1000); byte[] buf = new byte[1024]; DatagramPacket packet1 = new DatagramPacket(buf, 1024); System.out.println(\u0026#34;UdpSend：我在等待信息\u0026#34;); socket.receive(packet1); System.out.println(\u0026#34;UdpSend：已收到信息\u0026#34;); String str2 = new String(packet1.getData(), 0, packet1.getLength())+\u0026#34;from\u0026#34;+packet1.getAddress().getHostAddress() +\u0026#34;:\u0026#34;+packet1.getPort(); System.out.println(str2); } }   TCP   TCP协议：有链接、保证可靠的无误差通讯\n 服务器：创建一个ServerSocket，等待连接 客户机：创建一个Socket，连接到服务器 服务器：ServerSocket接收到连接，创建一个Socket和客户的Socket建立专线连接，后续服务器和客户机的对话 （这一对Socket）会在一个单独的线程（服务器端）上运行 服务器的ServerSocket继续等待连接，返回 i.    软件服务器有两要求：\n 它能够实现一定的功能 它必须在一个公开地址上对外提供服务    ServerSocket：服务码头\n 需要绑定Port 如果有多块网卡，需要绑定一个IP地址    Socket：运输通道\n 客户端需要绑定服务器的地址和Port 客户端往Socket输入流写入数据，送到服务端 客户端从Socket输出流取服务端过来的数据 服务器反之亦然    过程：\n 服务端等待响应时，处于阻塞状态 服务端可以同时响应多个客户端 服务端每接受一个客户端，就启动一个独立的线程与其对应 客户端或者服务端都可以选择关闭这条Socket通道 实例  服务端先启动，且一直保留 客户端后启动，可以先退出      Server:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package JavaLearning_Advanced.TCP; import java.io.*; import java.net.ServerSocket; import java.net.Socket; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 13:16 */ public class TCPServer2 { public static void main(String[] args) { try { ServerSocket serverSocket = new ServerSocket(8001); while (true) { Socket socket = serverSocket.accept(); System.out.println(\u0026#34;来了一个client\u0026#34;); new Thread(new Worker(socket)).start(); } } catch (Exception e) { e.printStackTrace(); } } private static class Worker implements Runnable{ private Socket socket; public Worker(Socket socket) { this.socket = socket; } @Override public void run() { try { System.out.println(\u0026#34;服务人员已启动\u0026#34;); InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); DataOutputStream dos = new DataOutputStream(outputStream); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); while (true) { String strWord = bufferedReader.readLine(); System.out.println(\u0026#34;client said:\u0026#34; + strWord + \u0026#34;:\u0026#34; + strWord.length()); if (strWord.equalsIgnoreCase(\u0026#34;quit\u0026#34;)) { break; } String strEcho = strWord + \u0026#34;666\u0026#34;; System.out.println(\u0026#34;server said:\u0026#34; + strWord + \u0026#34;---------\u0026gt;\u0026#34; + strEcho); dos.writeBytes(strWord + \u0026#34;---------\u0026gt;\u0026#34; +strEcho+ System.getProperty(\u0026#34;line.separator\u0026#34;)); } bufferedReader.close(); dos.close(); } catch (Exception e) { e.printStackTrace(); } } } }   Client:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  package JavaLearning_Advanced.TCP; import java.io.*; import java.net.InetAddress; import java.net.Socket; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 11:47 */ public class TcpClient { public static void main(String[] args) { try { Socket socket = new Socket(InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;), 8001); // 同一个通道，服务端输出流就是客户端的输入流，服务端的输入流，就是客户端的输出流  InputStream inputStream = socket.getInputStream();//开启通道的输入流  BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); OutputStream outputStream = socket.getOutputStream();//开启通道的输出流  DataOutputStream dataOutputStream = new DataOutputStream(outputStream); BufferedReader brKey = new BufferedReader(new InputStreamReader(System.in)); while (true) { String strWord = brKey.readLine(); if (strWord.equalsIgnoreCase(\u0026#34;quit\u0026#34;)) { break; } else { System.out.println(\u0026#34;i want to sent \u0026#34;+strWord); // outputStream.write(strWord.getBytes(), 0, strWord.length());//可以这么写  dataOutputStream.writeBytes(strWord+System.getProperty(\u0026#34;line.separator\u0026#34;)); System.out.println(\u0026#34;server said\u0026#34;+bufferedReader.readLine()); } } dataOutputStream.close(); bufferedReader.close(); } catch (Exception e) { e.printStackTrace(); } } }   HTTP  在浏览器输入URL地址 浏览器将连接到远程服务器（IP=Port(80)） 请求下载一个HTML文件下来，放到本地临时文件夹中 在浏览器显示出来  实例  URLConnection  获取资源的连接器 根据URL的openConnection()方法获得URLConnection connect方法，建立和资源的联系通道 getInputStream方法，获取资源的内容    get:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  package JavaLearning_Advanced.HTTP; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.URL; import java.net.URLConnection; import java.util.List; import java.util.Map; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 14:14 */ public class URLConnectionGet { public static void main(String[] args) { try { String urlName = \u0026#34;http://www.baidu.com\u0026#34;; URL url = new URL(urlName); URLConnection connection = url.openConnection(); connection.connect(); //打印Http的头部信息  Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; headers = connection.getHeaderFields(); for (Map.Entry\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; entry : headers.entrySet()) { String key = entry.getKey(); for (String value : entry.getValue()) { System.out.println(key + \u0026#34;:\u0026#34; + value); } } //输出将要收到的内容属性信息  System.out.println(\u0026#34;-------------------\u0026#34;); System.out.println(\u0026#34;getContentType\u0026#34; + connection.getContentType()); System.out.println(\u0026#34;getContentLength\u0026#34; + connection.getContentLength()); System.out.println(\u0026#34;getContentEncoding\u0026#34; + connection.getContentEncoding()); System.out.println(\u0026#34;getDate\u0026#34; + connection.getDate()); System.out.println(\u0026#34;getExpiration\u0026#34; + connection.getExpiration()); System.out.println(\u0026#34;getLastModified\u0026#34; + connection.getLastModified()); System.out.println(\u0026#34;-------------------\u0026#34;); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream(),\u0026#34;UTF-8\u0026#34;)); //输出收到的内容  String line = \u0026#34;\u0026#34;; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } }   Post:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  package JavaLearning_Advanced.HTTP; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.net.*; import java.util.HashMap; import java.util.Map; import java.util.Scanner; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 14:42 */ public class URLConnectionPost { public static void main(String[] args) throws IOException { String url = \u0026#34;https://www.usps.com/go/ZipLookupAction.action\u0026#34;; Object userAgent = \u0026#34;Httpie/0.9.2\u0026#34;; Object redirects = \u0026#34;1\u0026#34;; CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL)); Map\u0026lt;String, String\u0026gt; params = new HashMap\u0026lt;String, String\u0026gt;(); params.put(\u0026#34;tAddress\u0026#34;, \u0026#34;1 Market Street\u0026#34;); params.put(\u0026#34;tCity\u0026#34;, \u0026#34;San Francisco\u0026#34;); params.put(\u0026#34;sState\u0026#34;, \u0026#34;CA\u0026#34;); String result = doPost(new URL(url), params, userAgent == null ? null : userAgent.toString(), redirects == null ? -1 : Integer.parseInt(redirects.toString())); System.out.println(result); } private static String doPost(URL url, Map\u0026lt;String, String\u0026gt; nameValueParis, String userAgent, int redirects) throws IOException { HttpURLConnection connection = (HttpURLConnection) url.openConnection(); if (userAgent != null) { connection.setRequestProperty(\u0026#34;User-Agent\u0026#34;, userAgent); } if (redirects \u0026gt;= 0) { connection.setInstanceFollowRedirects(false); connection.setDoOutput(true); } //输出请求的参数  try (PrintWriter out = new PrintWriter(connection.getOutputStream())) { boolean first = true; for (Map.Entry\u0026lt;String, String\u0026gt; pair : nameValueParis.entrySet()) { //参数必须这样拼接a=1\u0026amp;b=2\u0026amp;c=3  if (first) { first = false; } else { out.println(\u0026#39;\u0026amp;\u0026#39;); } String name = pair.getKey(); String value = pair.getValue(); out.print(name); out.print(\u0026#39;=\u0026#39;); out.print(URLEncoder.encode(value, \u0026#34;UTF-8\u0026#34;)); } String encoding = connection.getContentEncoding(); if (encoding == null) { encoding = \u0026#34;UTF-8\u0026#34;; } if (redirects \u0026gt; 0) { int responseCode = connection.getResponseCode(); System.out.println(\u0026#34;responseCode:\u0026#34; + responseCode); if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || responseCode == HttpURLConnection.HTTP_MOVED_TEMP || responseCode == HttpURLConnection.HTTP_SEE_OTHER) { String location = connection.getHeaderField(\u0026#34;Location\u0026#34;); if (location != null) { URL base = connection.getURL(); connection.disconnect(); return doPost(new URL(base, location), nameValueParis, userAgent, redirects - 1); } } } else if (redirects == 0) { throw new IOException(\u0026#34;too many redirects\u0026#34;); } //获取html内容  StringBuilder response = new StringBuilder(); try (Scanner in = new Scanner(connection.getInputStream(), encoding)) { while (in.hasNextLine()) { response.append(in.nextLine()); response.append(\u0026#34;\\n\u0026#34;); } } catch (IOException e) { InputStream err = connection.getErrorStream(); if (err == null) { throw e; } try (Scanner in = new Scanner(err)) { response.append(in.nextLine()); response.append(\u0026#34;\\n\u0026#34;); } } return response.toString(); } } }   JDK HttpClient (JDK9新增，JDK10更新，JDK11正式发布)  java.net.http包 取代URLConnection 支持HTTP/1.1和HTTP/2 实现大部分HTTP方法 主要类  HttpClient HttpRequest HttpResponse    Get:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package JavaLearning_Advanced.HTTP.HttpClient; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 15:38 */ public class JDKHttpClientGet { public static void main(String[] args) { doGet(); } private static void doGet() { try { HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder(URI.create(\u0026#34;http://www.baidu.com\u0026#34;)).build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); } catch (Exception e) { e.printStackTrace(); } } }   Post:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package JavaLearning_Advanced.HTTP.HttpClient; import java.net.URI; import java.net.URLEncoder; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 15:43 */ public class JDKHttpClientPost { public static void main(String[] args) { doPost(); } private static void doPost() { try { HttpClient client = HttpClient.newBuilder().build(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(\u0026#34;https://zh-tools.usps.com/zip-code-lookup.htm?byaddress\u0026#34;)) .header(\u0026#34;User-Agent\u0026#34;, \u0026#34;HTTPie/0.9.2\u0026#34;) .header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded;charset=utf-8\u0026#34;) .POST(HttpRequest.BodyPublishers.ofString( \u0026#34;tAdress=\u0026#34; + URLEncoder.encode(\u0026#34;1 Market Street\u0026#34;, \u0026#34;UTF-8\u0026#34;) + \u0026#34;tCity=\u0026#34;+ URLEncoder.encode(\u0026#34;San Francisco\u0026#34;, \u0026#34;UTF-8\u0026#34;) + \u0026#34;sState=\u0026#34;+ \u0026#34;CA\u0026#34;) ).build(); HttpResponse response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.statusCode()); System.out.println(response.headers()); System.out.println(response.body().toString()); } catch (Exception e) { e.printStackTrace(); } } }   HttpComponent Get:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package JavaLearning_Advanced.HTTP.HttpComponet; import org.apache.http.HttpResponse; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 16:53 */ public class HttpComponentsGet { public static void main(String[] args) { CloseableHttpClient httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom() .setConnectionRequestTimeout(5000)//设置超时时间  .setConnectionRequestTimeout(5000)//设置请求超时时间  .setSocketTimeout(5000) .setRedirectsEnabled(true)//默认允许自动重定向  .build(); HttpGet httpGet = new HttpGet(\u0026#34;http://www.baidu.com\u0026#34;); httpGet.setConfig(requestConfig); String strResult = \u0026#34;\u0026#34;; try { HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == 200) { strResult = EntityUtils.toString(httpResponse.getEntity(),\u0026#34;UTF-8\u0026#34;);//获得返回结果  System.out.println(strResult); } } catch (Exception e) { e.printStackTrace(); } } }   Post;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  package JavaLearning_Advanced.HTTP.HttpComponet; import org.apache.http.HttpResponse; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpPost; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.impl.client.LaxRedirectStrategy; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.ArrayList; import java.util.List; /** * @Description: * @author: Anhlaidh * @date: 2020/3/29 0029 17:03 */ public class HttpComponentsPost { public static void main(String[] args) throws UnsupportedEncodingException { //获取可关闭的httpClient  //CloseableHttpClient  CloseableHttpClient httpClient = HttpClientBuilder.create().setRedirectStrategy(new LaxRedirectStrategy()).build(); //配置超时时间  RequestConfig requestConfig = RequestConfig.custom() .setSocketTimeout(10000) .setConnectTimeout(10000) .setConnectionRequestTimeout(10000) .setRedirectsEnabled(false).build(); HttpPost httpPost = new HttpPost(\u0026#34;https://zh-tools.usps.com/zip-code-lookup.htm?byaddress\u0026#34;); //配置post参数  List\u0026lt;BasicNameValuePair\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new BasicNameValuePair(\u0026#34;tAdress\u0026#34;, URLEncoder.encode(\u0026#34;1 Market Street\u0026#34;, \u0026#34;UTF-8\u0026#34;)));//请求参数  list.add(new BasicNameValuePair(\u0026#34;tCity\u0026#34;, URLEncoder.encode(\u0026#34;San Francisco\u0026#34;, \u0026#34;UTF-8\u0026#34;)));//请求参数  list.add(new BasicNameValuePair(\u0026#34;sState\u0026#34;, \u0026#34;CA\u0026#34;));//请求参数  try { UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, \u0026#34;UTF-8\u0026#34;); // 设置post请求参数  httpPost.setEntity(entity); httpPost.setHeader(\u0026#34;User-Agent\u0026#34;, \u0026#34;HTTPie/0.9.2\u0026#34;); HttpResponse httpResponse = httpClient.execute(httpPost); String result = \u0026#34;\u0026#34;; if (httpResponse != null) { int statusCode = httpResponse.getStatusLine().getStatusCode(); System.out.println(statusCode); if (statusCode == 200) { result = EntityUtils.toString(httpResponse.getEntity()); } else { result = \u0026#34;ERROR Response\u0026#34; + httpResponse.getStatusLine().toString(); } } else { } System.out.println(result); } catch (Exception e) { e.printStackTrace(); }finally { try { if (httpClient != null) { httpClient.close(); } } catch (Exception e) { e.printStackTrace(); } } } }   Java调用其他语言 Python  解释性脚本语言 目前版本3 Jython  将Python源码编译成JVM字节码,由JVM执行对应的字节码,可以很好的与JVM继承 不是Java与Python的连接器    ","permalink":"http://blog.oxide.ink/posts/java/java%E7%AC%94%E8%AE%B002/","summary":"Maven Junit 测试   单元测试：对软件中最小可测试单元进行检查和验证，通常是一个函数/方法（属于白盒测试）\n 集成测试： 将多个单元相互作用，形成一个整体，对整体协调性进行测试    白盒测试： 全面了解程序内部逻辑结构，对所有的逻辑路径都进行测试，一般由程序员完成\n 黑盒测试：又名功能测试，将程序看作不可打开的盒子，一般由独立使用者完成    自动测试：用程序批量、反复的测试程序，并可自动检查程序结果是否满足预定的要求\n 手动测试：手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求    回归测试：修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误\n  深入学习：软件测试-基于问题驱动模式 朱少民\n  Junit   import static 导入该包内的所有静态方法，使用时可不加类名\n  Triangle\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package JavaLearning_Advanced.","title":"Java笔记02"},{"content":"语法糖 Syntactic sugar jdk版本  编译级别 兼容级别  编译后高版本可以运行低版本字节码 反之不行    for/for-each  for  for(int i=0;i\u0026lt;nums.leng;i++) 可以删除元素   for-each  for(String i:hs) 5.0开始存在 语法简洁 不能删除元素 只能正向遍历 不能同时遍历两个集合    enum类型  java5 推出 enum有多少个值就有几个实例对象 可以添加属性/构造函数/方法 构造函数只能是package-private(default)或者private,内部调用 enum类型  所有enum类型都是Enum的子类,也继承了相应方法 ordinal()返回枚举所在的索引位置,从0开始 compareTo()比较两个枚举值的索引位置大小 toString()返回枚举值的字符串标识 valueOf()将字符串初始化为枚举对象 values() 返回所有的枚举值    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package notes.Java.Java_Final.suger; /** * @Description: * @author: Anhlaidh * @date: 2020-07-05 21:31 */ public class testEnum { public static void main(String[] args) { Fruit a1 = Fruit.APPLE; System.out.println(\u0026#34;Price is\u0026#34; + a1.price); System.out.println(\u0026#34;====================\u0026#34;); Day d1 = Day.MONDAY; Day d2 = Enum.valueOf(Day.class, \u0026#34;MONDAY\u0026#34;); System.out.println(d1 == d2); Day d3 = Enum.valueOf(Day.class, \u0026#34;TUESDAY\u0026#34;); System.out.println(d1.compareTo(d3)); //遍历  for (Day item : Day.values()) { //输出索引值  System.out.println(item.toString() + \u0026#34;,\u0026#34; + item.ordinal()); } } enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY } enum Fruit { APPLE(10), ORANGE(8); private int price; Fruit(int price) { this.price = price; } public int getPrice() { return price; } } }   不定项参数  JDK5提供了不定参数(可变参数)功能  类型后面加3个点,入int\u0026hellip;/double\u0026hellip;/String\u0026hellip; 可变参数,本质上是一个数组 一个方法只能由一个不定项参数,且位于参数列表的最后 重载的优先级规则1:固定参数的方法,比可变参数优先级更高 重载的优先级规则2:调用语句,同时与两个带可变参数的方法匹配,则报错    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  package notes.Java.Java_Final.suger; /** * @Description: 可变参数 * @author: Anhlaidh * @date: 2020-07-05 21:46 */ public class testVariableArgument { public static void main(String[] args) { print(); print(\u0026#34;aaa\u0026#34;); print(\u0026#34;aaa\u0026#34;,\u0026#34;bbb\u0026#34;); print(\u0026#34;aaa\u0026#34;,\u0026#34;bbb\u0026#34;,\u0026#34;ccc\u0026#34;); } private static void print(String... args) { System.out.println(args.length); for (String arg : args) { System.out.println(arg); } } //当只有一个参数时,本方法优先级更高  private static void print(String s) { System.out.println(\u0026#34;优先级高的方法\u0026#34;); } //错误:一个方法不可以有多个可变参数 // public static void print(String... args, int... irgs) { // // }  //调用语句,同时与两个带可变参数的方法匹配,则报错 // private static void print(String s1, String... args) { // // } }   静态导入  import static 导入类中的静态方法  使用时可以直接写方法名,不写类名   少用* 如果重名需要补充类名  自动装箱和拆箱  JDK5开始引入,简化基本类型和对象转化的写法 Integer\u0026ndash;int\u0026hellip; 编译器的工作,不是jvm的工作 ==:基本类型是内容相同,对象是指针是否相同 基本类型没有空值,对象有null 基础数据类型与封装类型进行 ==,+,-,*,/操作运算,会将封装类进行拆箱,对基础数据类型进行运算 谨慎使用多个非同类的数值类进行运算  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package notes.Java.Java_Final.suger; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 15:31 */ public class testNumber { public static void main(String[] args) { Integer a1 = 1000; int a2 = 1000; Integer a3 = 2000; Long a4 = 2000L; long a5 = 2000L; System.out.println(a1 == a2);//拆箱再进行数值比较  System.out.println(a3 == (a1 + a2));//拆箱再进行数值比较  System.out.println(a4 == (a1 + a2));//拆箱再进行数值比较  System.out.println(a5 == (a1 + a2));//拆箱再进行数值比较  System.out.println(a3.equals(a1 + a2));//equals要求同类且内容相同  System.out.println(a4.equals(a1 + a2));//equals要求同类且内容相同  System.out.println(a4.equals((long)(a1 + a2)));//equals要求同类,且值相同 // System.out.println(a3 == a4);//不同类型不能比较  } }   多异常并列  多个异常用 | 隔开 多个异常之间不能有直接/简介继承关系  数字增强  数字可以二进制赋值  避免二进制计算 byte/short/int/long   数值字面量中可以使用下划线  增加数字的可读性和纠错功能 short/int/long/float/double 下划线只能出现在数字中间    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  package notes.Java.Java_Final.suger; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 15:40 */ public class testNumber2 { public static void main(String[] args) { test1(); test2(); } private static void test2() { long a1 = 9999999999L; long a2 = 9_999_999_999L; int a3 = 0b0111_1011_0001;//二进制0b开头  int a4 = 02_014;//8进制,0开头  int a5 = 123__45;//可以多个下划线  int a6 = 0x7_B_1;//十六进制  float a7 = 3.56_78f;//float  double a8 = 1.3_45_67;//double  // int b1 = 0b_123_4; _必须在数字之间 // int b2 = 0123_4_;不能在末尾 // int b3 = _123;不能在开头 // int b4 = 0_ x_123;不能拆开0x // int b5 = 0x_51;_必须在数字之间 // long b6 = 1000_L;_必须在数字之间 // float b7 = 1.34f _;_不能在末尾  } private static void test1() { byte a1 = (byte) 0b00100001; short a2 = (short) 0b001010100; int a3 = 0b0010101010; int a4 = 0b101; int a5 = 0B101;//B可以大小写  long a6 = 0b1010101010010010010101010L; final int[] s1 = {0b101010, 0b101101, 0b1101111, 0b1111}; System.out.println(a5); System.out.println(Integer.toBinaryString(a5)); } }   接口方法   java8 接口默认方法/静态方法(都带具体实现)\n  默认方法\n 规则  以default关键字标注,其他定义和普通函数一样 规则1:默认方法 不能重写 Object中的方法 规则2:实现类可以继承/重写父接口默认方法 规则3:接口可以继承/重写父接口的默认方法 规则4:当父类和父接口都有(同名同参数) 默认方法,子类继承父类的默认方法,这样可以兼容JDK7及以前的代码 规则5:子类实现了两个接口(均有同名同参数的默认方法),那么编译失败,必须在子类中重写这个default方法      静态方法\n 属于本接口,不属于子类/子接口 子类(子接口)没有继承该静态方法,只能通过所在的接口名来调用 -java9 私有方法 解决多个默认方法/静态方法的内容重复问题 私有方法属于本接口,只在本接口内使用,不属于子类/子接口 子类(子接口)没有继承该私有方法,也无法调用 静态私有方法可以被静态/默认方法调用,非静态私有方法被默认方法调用    接口,抽象类\n 相同点  都是抽象的,都不能被实例化,即不能被new 都可以有实现方法 都可以不需要继承者实现所有方法   不同点(java12之前)  抽象类最多只能继承一个,接口可以实现多个 接口的变量默认是public static final,且必须有初值,子类不能修改,而抽象类的变量默认是default,子类可以继承修改 接口没有构造函数,抽象类有构造函数 接口没有main函数,抽象类可以有main函数 接口有public/default/private的方法,抽象类只有public/private/protected/不写关键字的(default)的方法      try-with-resource  jdk7提供try-with-resource  资源要求定义在try中,若已经定义在外面,则需要一个本地变量   jdk9不在要求定义临时变量,可以直接使用外部资源变量 原理  资源对象必须实现AutoCloseable接口,即close方法,jdk自带    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package notes.Java.Java_Final.suger.testTryWithResource; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 16:58 */ public class test { public static void main(String[] args) { try (MyConnection connection = new MyConnection()) { connection.sendData(); } catch (Exception e) { e.printStackTrace(); } } } class MyConnection implements AutoCloseable { public void sendData() throws Exception { System.out.println(\u0026#34;Send Data...\u0026#34;); } @Override public void close() throws Exception { System.out.println(\u0026#34;Close...\u0026#34;); } }   ResourceBundle文件加载  JDK9及以后,ResourceBundle默认以UTF-8方式加载  var类型  java10推出var  避免信息冗余 对齐了变量名 更容易阅读 本质上还是强类型语言,编译器负责推断类型,并写入字节码文件,因此推断后不能更改   var的限制  可以用在局部变量中,非类成员变量 可以在for/for-each中 声明时必须初始化 不能用在方法(形式)参数和返回类型 大面积滥用会使代码整体阅读性变差 var 只在编译时起作用,没有在字节码中引入新的内容,也没有专门的jvm指令处理var    switch  支持的类型:byte/Byte,short/Short,int/Integer,char/Character,String(7.0),Enum(5.0) 仍不支持long/float/double 多分支合并  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package notes.Java.Java_Final.suger; import java.util.Scanner; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 17:16 */ public class testSwitch { public static void main(String[] args) { // test1();  test2(); } private static void test2() { Scanner scanner = new Scanner(System.in); int num= scanner.nextInt(); int days = switch (num){ case 1,3,5,7,8,10,12 -\u0026gt; 31; case 4,6,9,11 -\u0026gt; 30; default -\u0026gt; 28; }; System.out.println(days); } private static void test1() { Scanner scanner = new Scanner(System.in); String month = scanner.next(); int result=-1; switch (month) { case \u0026#34;Jan\u0026#34;,\u0026#34;Mar\u0026#34;,\u0026#34;May\u0026#34;,\u0026#34;July\u0026#34;,\u0026#34;Aug\u0026#34;,\u0026#34;Oct\u0026#34;,\u0026#34;Dec\u0026#34; -\u0026gt; result = 31; case \u0026#34;Apr\u0026#34;,\u0026#34;June\u0026#34;,\u0026#34;Sep\u0026#34;,\u0026#34;Nov\u0026#34; -\u0026gt; result = 30; case \u0026#34;Feb\u0026#34; -\u0026gt; result = 28; default -\u0026gt; result = -1; } System.out.println(result); } }   反射 reflection  定义  程序可以访问,检测和修改它本身状态或行为的能力,即自描述和自控制 可以在运行时加载,探知,和使用编译期间完全未知的类 给java插上动态语言特性的翅膀,弥补强类型语言的不足 java.lan.reflect包,在java2存在,java5完善   功能  在运行中分析类的能力 在运行中查看和操作对象  基于反射自由创建对象 反射构建出无法直接访问的类 set或者get到无法访问的成员变量 调用不可访问的方法   实现通用的数组操作代码 类似函数指针的功能   创建对象  静态编码\u0026amp;编译(new) 克隆(clone()),继承Cloneable,速度快 序列化serialization,反序列化deserialization继承Serializable接口    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  package notes.Java.Java_Final.Reflect; import java.io.*; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 18:05 */ public class testSerialization { public static void main(String[] args) throws IOException, ClassNotFoundException { A obj1 = new A(); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\u0026#34;data.obj\u0026#34;)); out.writeObject(obj1); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\u0026#34;data.obj\u0026#34;)); A obj2 = (A) in.readObject(); in.close(); obj2.hello(); } } class A implements Serializable { private static final long serialVersionUID = 1L; public void hello() { System.out.println(\u0026#34;hello from A\u0026#34;); } } ```     反射 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  package notes.Java.Java_Final.Reflect; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /** * @Description: * @author: Anhlaidh * @date: 2020-07-07 19:32 */ public class testNewInstance { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException { Object obj1 = Class.forName(\u0026#34;notes.Java.Java_Final.Reflect.A\u0026#34;).newInstance(); Method m = Class.forName(\u0026#34;notes.Java.Java_Final.Reflect.A\u0026#34;).getMethod(\u0026#34;hello\u0026#34;); m.invoke(obj1);//获取方法  A obj2 = (A) Class.forName(\u0026#34;notes.Java.Java_Final.Reflect.A\u0026#34;).newInstance(); Constructor\u0026lt;A\u0026gt; constructor = A.class.getConstructor();//构造函数  A obj3 = constructor.newInstance(); obj3.hello(); } }      内容  Class:类型标识   JVM为每个对象都保留其类型标识信息(Runtime Type Identification) 成员变量,方法,构造函数,修饰符,包,父类,父接口\u0026hellip; 成员变量Field 方法Method 构造函数Constructor    编译器API  对 .java文件即时编译 对字符串即时编译 监听在编译过程中产生的警告和错误 在代码中运行编译器(并非:Runtime命令调用javac命令)  JavaCompiler   1.6推出\n  可用在程序文件中的Java编译器接口(代替javac.exe)\n  在程序中编译java文件,产生class文件\n  run方法(继承自java.tools.Tools):较简单,可以编译java源文件,生成class文件,但不能指定输出 路径,监控错误信息,调用后就在源码所在目录生成class文件\n  getTask方法:更强大的功能,可以编译java源文件,包括在内存中的java文件(字符串),生成class文件\n  编译文件:\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  package notes.Java.Java_Final.JavaCompiler; import javax.tools.JavaCompiler; import javax.tools.ToolProvider; import java.io.ByteArrayOutputStream; import java.nio.charset.Charset; /** * @Description: * @author: Anhlaidh * @date: 2020-08-04 14:30 */ public class SimpleJavaCompiler { public static void main(String[] args) { // successCompile();  failCompile(); } private static void failCompile() { ByteArrayOutputStream err = new ByteArrayOutputStream(); JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); int result = compiler.run(null, null, err, \u0026#34;./aaa.java\u0026#34;); if (0 == result) { System.out.println(\u0026#34;Success\u0026#34;); } else { System.out.println(\u0026#34;Fail\u0026#34;); System.out.println(new String(err.toByteArray(), Charset.defaultCharset()) ); } } private static void successCompile() { JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); /** * 第一个参数:输入流,null表示默认使用system.in * 第二个参数:输出流,null标识默认使用system.out * 第三个参数:错误流,null标识默认使用system.err * 第四个参数:String...需要编译的文件名 * 返回值:0表示成功,其他错误 */ int result = compiler.run(null, null, null, \u0026#34;G:\\\\Coding\\\\src\\\\main\\\\java\\\\notes.Java\\\\Java_Final\\\\API\\\\hello1.java\u0026#34;,\u0026#34;G:\\\\Coding\\\\src\\\\main\\\\java\\\\notes.Java\\\\Java_Final\\\\API\\\\hello2.java\u0026#34;); System.out.println(0 == result ? \u0026#34;Success\u0026#34; : \u0026#34;Fail\u0026#34;); } }    编译字符串  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  package notes.Java.Java_Final.JavaCompiler; import javax.tools.*; import java.io.File; import java.lang.reflect.Method; import java.net.URISyntaxException; import java.net.URL; import java.nio.charset.Charset; import java.util.Arrays; /** * @Description: * @author: Anhlaidh * @date: 2020-08-04 14:46 */ public class JavaCompilerTask { public static void main(String[] args) { compilerJavaFromString(); // System.out.println(\u0026#34;hello world\u0026#34;);  } private static void compilerJavaFromString() { StringBuffer stringBuffer = new StringBuffer(); String className = \u0026#34;Hello\u0026#34;; stringBuffer.append(\u0026#34;public class \u0026#34; + className + \u0026#34;{\u0026#34;); stringBuffer.append(\u0026#34; public static void main(String[] args) {\u0026#34;); stringBuffer.append(\u0026#34; System.out.println(\\\u0026#34;hello world\\\u0026#34;);\\n\u0026#34;); stringBuffer.append(\u0026#34;}\\n\u0026#34;); stringBuffer.append(\u0026#34;}\\n\u0026#34;); Class\u0026lt;?\u0026gt; c = compiler(className, stringBuffer.toString()); try { //生成对象  Object obj = c.newInstance(); Method m = c.getMethod(\u0026#34;main\u0026#34;, String[].class); m.invoke(obj, new Object[]{new String[]{}}); } catch (Exception e) { e.printStackTrace(); } } private static Class\u0026lt;?\u0026gt; compiler(String className, String javaCode) { JavaSourceFromString srcObject = new JavaSourceFromString(className, javaCode); System.out.println(srcObject.getCode()); Iterable\u0026lt;? extends JavaFileObject\u0026gt; fileObjects = Arrays.asList(srcObject); JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, Charset.defaultCharset()); DiagnosticCollector\u0026lt;JavaFileObject\u0026gt; diagnosticCollector = new DiagnosticCollector\u0026lt;\u0026gt;(); //设置编译的输出目录,并包装在options中  String flag = \u0026#34;-d\u0026#34;; String outDir = \u0026#34;\u0026#34;; try { URL resource = Thread.currentThread().getContextClassLoader().getResource(\u0026#34;\u0026#34;); File classpath = new File(resource.toURI()); outDir = classpath.getAbsolutePath() + File.separator; System.out.println(outDir); } catch (URISyntaxException e) { e.printStackTrace(); } Iterable\u0026lt;String\u0026gt; options = Arrays.asList(flag, outDir); /** * JavaCompiler.getTask方法:以future的任务形式(多线程)来执行编译任务 * 第一个参数:额外输出流,null表示默认使用System.err * 第二个参数:文件管理器,null表示编译器默认方法来报告诊断信息 * 第三个参数:诊断监听器,null表示使用编译器默认方法来报告诊断信息 * 第四个参数:编译器参数,null表示无参数 * 第五个参数:需要经过annotation处理的类名,null表示没有类需要annotation * 第六个参数,待编译的类 */ JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnosticCollector, options, null, fileObjects); //等待编译结束  boolean result = task.call(); if (result == true) { try { return Class.forName(className); } catch (ClassNotFoundException e) { e.printStackTrace(); } } else { for (Diagnostic diagnostic : diagnosticCollector.getDiagnostics()) { System.out.println(\u0026#34;Error on line:\u0026#34; + diagnostic.getLineNumber() + \u0026#34;;URI\u0026#34; + diagnostic.getSource().toString()); } } return null; } }    其中的JavaSourceFromString 类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package notes.Java.Java_Final.JavaCompiler; import javax.tools.SimpleJavaFileObject; import java.io.IOException; import java.net.URI; /** * @Description: A file object used to represent source coming from a string * @author: Anhlaidh * @date: 2020-08-04 14:57 */ public class JavaSourceFromString extends SimpleJavaFileObject { private String code; public JavaSourceFromString(String name, String code) { super(URI.create(\u0026#34;string:///\u0026#34; + name.replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;) + Kind.SOURCE.extension),Kind.SOURCE); this.code = code; } @Override public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException { return code; } public String getCode() { return code; } }    notes.Java EE 的Jsp编译 在线编程观景 在线程序评判系统(OJ) 自动化的构建和测试工具  代理(Proxy):代替处理  代理模式  外界不用直接访问目标对象,而是访问代理对象,由代理对象再调用目标对象 代理对象中可以添加监控和审查处理 静态代理  代理对象持有目标对象的句柄 所有调用目标对象的方法,都调用代理对象的方法 对每个方法,需要静态编码(理解简单,但代码繁琐)   动态代理  对目标对象的方法每次被调用,进行动态拦截 方法重名会用第一个接口的方法     Main  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package notes.Java.Java_Final.Proxy.test; import java.lang.reflect.*; import java.util.Arrays; /** * @Description: * @author: Anhlaidh * @date: 2020-08-04 18:06 */ public class MultipleInterfacesProxyTest { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Cook cook = new CookImpl(); ClassLoader cl = MultipleInterfacesProxyTest.class.getClassLoader(); ProxyHandler handler = new ProxyHandler(cook); //生成代理类型  Class\u0026lt;?\u0026gt; proxyClass = Proxy.getProxyClass(cl, new Class\u0026lt;?\u0026gt;[]{Cook.class, Driver.class}); //生成代理对象  Object proxy = proxyClass.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{handler}); System.out.println(Proxy.isProxyClass(proxyClass)); Proxy p = (Proxy) proxy; System.out.println(Proxy.getInvocationHandler(proxy).getClass().getName()); System.out.println(\u0026#34;proxy类型\u0026#34; + proxyClass.getName()); //代理对象都继承于java.lang.reflect.Proxy,但是获取父类是Object而不是Proxy  Class father = proxyClass.getSuperclass(); System.out.println(\u0026#34;proxy的父类类型:\u0026#34; + father.getName()); Class[] cs = proxy.getClass().getInterfaces(); for (Class c : cs) { System.out.println(\u0026#34;proxy的父接口类型\u0026#34; + c.getName()); } System.out.println(\u0026#34;===============\u0026#34;); Method[] ms = proxy.getClass().getMethods(); for (Method m : ms) { System.out.println(\u0026#34;调用方法\u0026#34; + m.getName() + \u0026#34;参数为\u0026#34; + Arrays.deepToString(m.getParameters())); } System.out.println(\u0026#34;===============\u0026#34;); Cook c = (Cook) proxy; c.doWork(); Driver d = (Driver) proxy; d.doWork(); } }    Handler  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package notes.Java.Java_Final.Proxy.test; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Arrays; /** * @Description: * @author: Anhlaidh * @date: 2020-08-04 18:03 */ public class ProxyHandler implements InvocationHandler { private Cook cook; public ProxyHandler(Cook cook) { this.cook = cook; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;proxy类型\u0026#34; + proxy.getClass().getName()); System.out.println(\u0026#34;调用方法\u0026#34; + method + \u0026#34;;参数为\u0026#34; + Arrays.deepToString(args)); Object result = method.invoke(cook, args); return result; } }   AOP(Aspect Oriented Programming)  面向对象: 将需求功能划分为不同的,独立,分装良好的类,并让他们通过继承和多态实现相同和不同行为 面向切面: 将通用需求功能从众多类中分离出来,使得很多类共享一个行为,一旦发生变化,不必修改很多类,而只修改这个行为即可  面向切面编程  一个概念/规范,没有限定语言 不是取代OOP编程,而是OOP的补充,和数据库的触发器有点相似 主要内容  Aspect:配置文件,包括一些Pointcut和响应的Advice JointPoint:在程序中明确定义的点,如方法调用,对类成员访问等 PointCut: 一组JointPoint,可以哦通过逻辑关系/通配符/正则等组合起来,定义了响应advice将要发生的地方 Advice:定义了在pointcut处要发生的动作,通过before/after/around来关联 weaving:advice代码在具体jointPoint的关联方式    注解Annotation  JDK1.5引入 位于源码中(代码/注释/注解),使用其他工具进行处理的标签 注解用来修饰程序的元素,但不会对修饰的对象有直接的影响 只有通过某种配套的工具才会对注解信息进行访问和处理 主要用途  提供信息给编译器/IDE工具 可用于其他工具来产生额外的代码/配置文件等 有一些注解可在程序运行时访问,增加程序动态性   @SuppressWarning  不同jdk 不同,javac -X可查看    自定义注解  注解可以包括的类型  8种基本类型 String Class enum 注解类型 由前面类型组成的数组    1 2 3 4 5 6 7 8 9 10 11 12 13 14  package notes.Java.Java_Final.Annotation; public @interface BugReport { enum Status {UNCONFIRMED,CONFIRMED,FIXED, NOTABUG}; boolean showStopper() default true; String assignedTo() default \u0026#34;[notes]\u0026#34;; Status status() default Status.UNCONFIRMED; String[] reportedBy(); }    注解使用的位置(@Target) @Retention(RetentionPolicy.RUNTIME) 编译时也存在 自定义注解及其使用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package notes.Java.Java_Final.Annotation.Single; import java.lang.reflect.Method; /** * @Description: * @author: Anhlaidh * @date: 2020-08-05 17:18 */ public class Main { public static void main(String[] args) throws ClassNotFoundException { int passed = 0, failed = 0; String className = \u0026#34;notes.Java.Java_Final.Annotation.Single.Foo\u0026#34;; for (Method m : Class.forName(className).getMethods()) { if (m.isAnnotationPresent(SingleTest.class)) { System.out.println(m.getName()); SingleTest st = m.getAnnotation(SingleTest.class); try { m.invoke(null, st.value()); passed++; } catch (Throwable throwable) { System.out.printf(\u0026#34;Test %s failed %s %n\u0026#34;, m, throwable.getCause().getMessage()); failed++; } } } System.out.printf(\u0026#34;Success: %d ,Failed: %d %n\u0026#34;, passed, failed); } }   元注解   修饰注解的注解\n  @Target 设置目标范围\n 限定目标注解作用于什么位置@Target({ElementType.METHOD}) ElementType.ANNOTATION_TYPE(注:修饰注解) ElementType.CONSTRUCTOR ElementType.FIELD ElementType.LOCAL_VARIABLE ElementType.METHOD ElementType.PACKAGE ElementType.PARAMETER ElementType.TYPE(注:任何类型,即上面的类型都可以修饰)    @Retention 设置保持性\n 修饰其他注解的存在范围 Retention.SOURCE 注解仅存在源码,不在class文件 Retention.CLASS(默认的注解保留策略) 注解存在于.class文件,不能被JVM加载 Retention.RUNTIME这种策略下,注解可以被JVM运行时访问到,通常情况下,可以结合反射来做一些事情    @Inherited 注解继承\n 让一个类和他的子类都包含某个注解 普通的注解没有继承功能    @Repeatable 此注解可以重复修饰\n 自jdk1.8引入 表示被修饰的注解可以重复应用标注 需要定义注解和容器注解    @Document 文档\n 指明这个注解可以被javadoc工具解析,形成帮助文档    RUNTIME注解调用路线\n Java为注解产生一个代理类 这个代理类包括一个AnnotationInvocationHandler成员变量 AnnotationInvocationHandler有个Map的成员变量,用来存储所有的注解的属性赋值 在程序中,调用注解接口的方法,将会被代理类接管,然后根据方法名字,到Map里拿到对应的Value并返回    嵌套类 Nested classes  静态嵌套类: Static nested classes,即前面有static修饰符  层级和包围类(enclosing class)的成员变量/方法一样 静态嵌套类可以定义静态和非静态成员 第三方需要通过外部包围类才可以访问到静态嵌套类  Outer.Inner obj = new Outer.Inner();     非静态嵌套类: Non-static nested classes ,又名内部类,Inner classes  普通内部类(成员内部类)  非static的类,定义在某个类的成员变量位置 定义后在类里面均可以使用 在第三方类中,需要先创建外部包围类实例,才能创建内部类的实例,不允许单独的普通内部类对象存在  Outer.Inner obj = Outer.new Inner();     局部内部类(Local classes)  定义在代码块中的非静态的类,如方法,for循环,if语句等 定义后,即可创建对象使用 只能活在这个代码块中,代码块结束后,外界无法使用该类   匿名内部类(Anonymous class)  没有类名的内部类,必须继承一个父类/实现一个父接口 在实例化以后,迅速转型为父类/父接口 这种类型的对象,只能new一个对象,之后以对象名字操作 可在普通语句和成员变量赋值时使用内部类     为什么需要嵌套类  不同的访问权限要求,更细粒度的访问控制 简介,避免过多的类定义 语言设计过于复杂,较难学习和使用      位置 名字(编译后的class文件) 作用范围 基本信息 嵌套类内部的内容 可访问的外部包围类的内容 和外部类的关系     匿名内部类 成员变量或者成员方法内 外部类名+$+数字编号 跟随被复制变量的作用范围,外界无法访问 没有类名,没有构造函数没有static,private/default/protected/public修饰 不能带静态成员 访问外部的所有成员 在外部类对象内部   局部内部类 成员方法内 外部类名+$+序号+内部类名 所在的方法内外界无法访问 有类名,有构造函数没有static,private/default/protected/public修饰 不能带静态成员,除了常量 访问外部的所有成员 在外部类的对象内部   普通内部类 成员变量 外部类名+$+内部类名 包围类内可以访问,外界可以访问 有类名,有构造函数没有static,private/default/protected/public修饰 不能带静态成员,除了常量 访问外部的所有成员 外界可以new,但是必须依附于一个外部包围类对象   静态嵌套类 成员变量 外部类名+$+内部类名 包围类内部可以访问,外界可以访问 有类名,有构造函数有static,private/default/protected/public修饰 可以定义静态成员变量和方法 访问外部的所有静态成员 可以new,可独立进行工作     变量遮蔽:Shadowing  嵌套类变量和外部包围类的变量重名  以离得近作为优先原则 优先级高的变量回遮蔽优先级低的变量 外部包围类.this.变量名,可以访问到外部包围类的成员变量 静态嵌套类不能访问非静态变量 Java7及以前,匿名内部类和局部内部类只能访问外部包围类的final成员变量 Java8及以后,匿名内部类和局部内部类可以访问外部包围类的final成员变量和 事实意义上的final变量(effectively final,一个变量定值后,再也没有改过值)      Lambda表达式  参数,箭头,一个表达式 参数,箭头,{多个语句} 类似于匿名方法,一个没有名字的方法 参数,箭头,表达式语句 可以忽略写参数类型 坚决不声明返回值类型 没有public/protected/private/static/final等修饰符 单句表达式,将直接返回值,不用大括号 带return语句,算多句,必须用大括号  函数式接口  是一个接口,符合Java接口的定义 只包含一个抽象方法的接口 可以包含其他的default方法,static方法,private方法 由于只有一个未实现的方法,所以Lambda表达式可以自动填上这个尚未实现的方法 采用Lambda表达式,可以自动创建出一个(伪)嵌套类的对象(没有实际嵌套类class文件产生),然后使用, 比真正嵌套类更加轻量,更加简洁高效  1 2 3 4 5 6 7  package notes.Java.Java_Final.Lambda; @FunctionalInterface //标记为函数式接口 public interface StringChecker { public boolean test(String s); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  package notes.Java.Java_Final.Lambda; /** * @Description: * @author: Anhlaidh * @date: 2020-08-06 21:38 */ public class Main { public static void main(String[] args) { String[] s = new String[]{\u0026#34;aaa\u0026#34;, \u0026#34;bbbb\u0026#34;, \u0026#34;cccccc\u0026#34;}; StringChecker eventLength = s1 -\u0026gt; { if (s1.length() % 2 == 0) { return true; } return false; }; for (String p : s) { if (eventLength.test(p)) { System.out.println(p); } } } }   系统自带的函数式接口    接口 参数 返回值 实例     Predicate T Boolean 接收一个参数,返回一个boolean   Consumer T void 接受一个参数,无返回   Function\u0026lt;T,R\u0026gt; T R 接受一个参数,返回一个值   Supplier None T 数据工厂    方法引用  Class::staticMethod  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package notes.Java.Java_Final.Lambda; /** * @Description: * @author: Anhlaidh * @date: 2020-08-06 22:26 */ public class method { public static void main(String[] args) { double a = -3.5; double b = worker(Math::abs, a); System.out.println(b); double c = worker(Math::floor, a); System.out.println(c); double d = worker((num -\u0026gt; (num % 10)), a); System.out.println(d); } public static double worker(NumFunction nf, double num) { return nf.calculate(num); } }    Class::instanceMethod  第一个参数将变成方法的执行体 String::compareToIgnoreCase等价于(x,y)-\u0026gt;x.compareToIgnoreCase(y)  1 2 3  String[] planets = new String[]{\u0026#34;DDD\u0026#34;,\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;}; Arrays.sort(planets, String::compareToIgnoreCase); System.out.println(Arrays.toString(planets));      object::instanceMethod  支持this::instanceMethod 支持super::instanceMethod   Class::new,调用某类构造函数,支持单个对象构建 Class[]::new,调用某类构造函数,支持数组对象构建 应用  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package notes.Java.Java_Final.Lambda; import java.util.ArrayList; import java.util.Arrays; /** * @Description: * @author: Anhlaidh * @date: 2020-08-07 15:06 */ public class testIterable { public static void main(String[] args) { String[] p = new String[]{\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;}; ArrayList\u0026lt;String\u0026gt; pList = new ArrayList\u0026lt;String\u0026gt;(Arrays.asList(p)); for (String s : pList) { System.out.println(s); } pList.forEach(System.out::println); } }   流 stream  sequence of elements:一个流对外提供一个接口,可以访问到一串特定的数据,流不存储元素,但是可以根据需要进行计算转化 source:数据来源,如数据结构,数组,文件等 aggregate operation:聚合操作,流支持像SQL操作或者其他函数式语言的操作 如filter/map/reduce/find/match/sorted等 Stream流  pipelining:很多流操作也是返回一个流 Internal Iteration:流操作进行迭代,用户感知不到循环遍历    流的工作流程  流的创建   Collection接口的stream方法 Arrays.stream(数组) Stream.of()     empty() 空流      流的转换,将流转换为其他流的中间操作,可包括多个步骤(惰性操作) 流的计算结果,这个操作会强制执行之前的惰性操作,这个步骤以后,流就再也不用了  ","permalink":"http://blog.oxide.ink/posts/java/java%E7%AC%94%E8%AE%B003/","summary":"语法糖 Syntactic sugar jdk版本  编译级别 兼容级别  编译后高版本可以运行低版本字节码 反之不行    for/for-each  for  for(int i=0;i\u0026lt;nums.leng;i++) 可以删除元素   for-each  for(String i:hs) 5.0开始存在 语法简洁 不能删除元素 只能正向遍历 不能同时遍历两个集合    enum类型  java5 推出 enum有多少个值就有几个实例对象 可以添加属性/构造函数/方法 构造函数只能是package-private(default)或者private,内部调用 enum类型  所有enum类型都是Enum的子类,也继承了相应方法 ordinal()返回枚举所在的索引位置,从0开始 compareTo()比较两个枚举值的索引位置大小 toString()返回枚举值的字符串标识 valueOf()将字符串初始化为枚举对象 values() 返回所有的枚举值    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package notes.","title":"Java笔记03"},{"content":"哔哩哔哩视频   https://yyqx.online/posts/hugo博客latex渲染/)\n Mermaid sequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-John: Hello John, how are you?\rloop Healthcheck\rJohn-John: Fight against hypochondria\rend\rNote right of John: Rational thoughts prevail...\rJohn--Alice: Great!\rJohn-Bob: How about you?\rBob--John: Jolly good!\r\r Latex 行内样式：$x=2$\n代码块： $$ f(x)=\\int_{-\\infty}^\\infty\\widehat f\\xi,e^{2\\pi i\\xi x},d\\xi $$\n网易云音乐 单曲：  歌单：  ","permalink":"http://blog.oxide.ink/posts/hugo-extend/","summary":"哔哩哔哩视频   https://yyqx.online/posts/hugo博客latex渲染/)\n Mermaid sequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-John: Hello John, how are you?\rloop Healthcheck\rJohn-John: Fight against hypochondria\rend\rNote right of John: Rational thoughts prevail...\rJohn--Alice: Great!\rJohn-Bob: How about you?\rBob--John: Jolly good!\r\r Latex 行内样式：$x=2$\n代码块： $$ f(x)=\\int_{-\\infty}^\\infty\\widehat f\\xi,e^{2\\pi i\\xi x},d\\xi $$\n网易云音乐 单曲：  歌单：  ","title":"Markdown Extend"},{"content":"Hugo PlantUML ","permalink":"http://blog.oxide.ink/posts/demo/","summary":"Hugo PlantUML ","title":"Demo"},{"content":"萝卜博客 https://radish.cloud\n","permalink":"http://blog.oxide.ink/links/","summary":"萝卜博客 https://radish.cloud","title":""},{"content":"","permalink":"http://blog.oxide.ink/posts/db/dbtemplate/","summary":"","title":"DBTemplate"},{"content":"概述  ES不等于搜索引擎 分布式的搜索,存储,数据分析引擎 优点:  面向开发者友好,屏蔽了Luncene的复杂特性,集群自动发现 自动维护数据在多个节点上的建立 帮我们做搜索请求的负载均衡 自动维护冗余副本,保证了部分节点宕机的情况下仍然不会有任何数据丢失 ES基于Lucene提供了很多高级功能:符合查询,聚合分析,基于地理位置 对于大公司,可以构建几百台服务器的大型分布式集群,处理PB级别数据 相遇传统数据库,提供了全文见检索,同义词处理,相关度排名,聚合分析以及海量数据的近实时(NTR)处理,这些传统数据库完全做不到   应用领域  搜索引擎 各大网站的用户行为日志(点击,浏览,收藏,评论) BI 数据分析 Github ELK (Elasticseach(数据存储) Logstash(日志采集) Kibana(可视化))    核心概念和原理  搜索  SQL 用了%不能用索引 -\u0026gt;性能差  like % 搜索时间复杂度O(n)   不能分词   倒排索引  分词 生成相关度 * 排序 空间换时间   数据结构  document List 关键词在每个doc中出现的次数 TF term frequency 词频 IDF inverse doc frequency 关键词在当前doc出现的次数 每个doc的长度 越长相关度越低 包含这个关键词的所有doc的平均长度     核心概念  集群:每个集群至少包含两个节点 Node:集群中的节点 一个节点不代表是一台机器 Filed: 一个数据字段,与index和type可以定位一个doc Document:ES最小的数据单元 Json Type:逻辑上的数据分类 Index:一类相同或者相似的doc 分片shard  一个index包含多个shard,默认5p,默认每个p分配一个r,p的数量在创建索引的时候设置,如果想修改,需要重建索引 每个shard都是一个lucene实例,有完整的创建索引的处理请求能力 ES会自动在nodes尚未我们zuoshard均衡 一个doc不可能同时存在于多个PShard,但是可以同时多个Rshard p和对应的r不能同时存在于同一个节点,所以最低的可用配置是两台节点,互为主备   横向扩容 Parimary Shared Replica Shard     容错  两台机子p0,p1,p2 r0,r1,r2 p挂掉之后r顶上 容错机制  master选举  findMaster  脑裂 可能会产生多个master节点   判断自己是否为master 广播/findMaster   replica容错 重启故障机 数据恢复  只拷贝新增数据 不是全量拷贝        使用  健康值检查  CRUD  Query String search 类似于Url挂参数搜索 Query DSL Query and filter  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  GET /_cat/health?v PUT /test_index?pretty GET _cat/indices DELETE /test_index?pretty PUT /product/_doc/1 { \u0026#34;name\u0026#34;:\u0026#34;xiaomi erji\u0026#34;, \u0026#34;desc\u0026#34;:\u0026#34;erji zhong de huangmenji\u0026#34;, \u0026#34;price\u0026#34;:1999, \u0026#34;tags\u0026#34;:[\u0026#34;low\u0026#34;,\u0026#34;bufangshui\u0026#34;,\u0026#34;yinzhicha\u0026#34;] } PUT /product/_doc/2 { \u0026#34;name\u0026#34;:\u0026#34;xiaomi shouji\u0026#34;, \u0026#34;desc\u0026#34;:\u0026#34;erji zhong de huangmenji\u0026#34;, \u0026#34;price\u0026#34;:2999, \u0026#34;tags\u0026#34;:[\u0026#34;low\u0026#34;,\u0026#34;bufangshui\u0026#34;,\u0026#34;yinzhicha\u0026#34;] } PUT /product/_doc/3 { \u0026#34;name\u0026#34;:\u0026#34;xiaomi nfc shouji\u0026#34;, \u0026#34;desc\u0026#34;:\u0026#34;erji zhong de huangmenji\u0026#34;, \u0026#34;price\u0026#34;:3999, \u0026#34;tags\u0026#34;:[\u0026#34;low\u0026#34;,\u0026#34;bufangshui\u0026#34;,\u0026#34;yinzhicha\u0026#34;] } PUT /product/_doc/4 { \u0026#34;name\u0026#34;:\u0026#34;xiaomi yinxiang\u0026#34;, \u0026#34;desc\u0026#34;:\u0026#34;erji zhong de huangmenji\u0026#34;, \u0026#34;price\u0026#34;:4999, \u0026#34;tags\u0026#34;:[\u0026#34;low\u0026#34;,\u0026#34;bufangshui\u0026#34;,\u0026#34;yinzhicha\u0026#34;] } GET /product/_doc/_search { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;shouji xiaomi\u0026#34; } }, \u0026#34;sort\u0026#34;:[ {\u0026#34;price\u0026#34;:\u0026#34;desc\u0026#34;}] } POST /product/_doc/1/update { \u0026#34;doc\u0026#34;:[] } DELETE /product/_doc/1   ES分布式文档系统  实现高可用  ES在分配单个索引的分片时会将每个分片尽可能分配到更多的节点上  但是实际情况取决于集群拥有的分片和索引以及他们的大小,不一定总是能均匀的分布   ES不允许Primary与Replica放在同一个节点中,并且同一个节点不接受完全相同的两个Replica 同一个节点允许多个索引的分片同时存在   容错  向下兼容 自行恢复的能力   ESNode  默认配置 node.master=true node,data=true  Master:主节点,每个集群只有一个 专注于集群的管理 协调节点-\u0026gt;转发  尽量避免node.data = true   voting:投票节点  master宕机了投票选举master 数量等于数据节点 设置了Node.voting_only=true 即使node.master=true 也不会参选 voting_only仍然可以做数据节点(node.data=true)   coordinating:协调节点    node.master node.data node.voting_only 节点详情     true 尽量false false master节点 /候选节点,参选为master   false true true 投票节点,不仅投票,还存数据   false false true 不存数据的投票节点 -\u0026gt; 协调节点   false true false 数据节点,主要负责数据的查询以及增删改       投票选举master  集群节点数量一般是奇数个 投票节点与与数据节点数量相同  如果是偶数个,默认投票节点减少一个   步骤  寻找clusterStateVersion比自己高的节点,想起发送选票 如果clusterStateVersion一样,则在候选节点(包含当前节点)中选id最小的一个节点,向该节点发送选举投票 如果一个节点收到足够多的投票并且也向自己投票了,那么该节点成为master开始发布集群状态     脑裂问题  discovery.zen.minimum_master_nodes=N/2+1 小于等于两台机子的集群会产生脑裂    ES 查询语法   search\n timeout true/false(默认)  超过指定时间,停止查询,查到多少条返回多少条      Query String\n Url  GET /product/_search?from=0\u0026amp;size=2\u0026amp;sort=price:asc  取前两个 排序  加了排序之后没有相关度分数  因为加了排序之后score就没有意义了 score是null            QueryDSL 重点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171  GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} } } # get GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;nfc\u0026#34; } } } # sort GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;xiaomi\u0026#34; } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;FIELD\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ] } # multi match 多字段查询一个关键词 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;multi_match\u0026#34;: { \u0026#34;query\u0026#34;: \u0026#34;nfc\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;name\u0026#34;,\u0026#34;desc\u0026#34;] } }, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34; } ] } # _source 指定返回字段 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;nfc\u0026#34; } }, \u0026#34;_source\u0026#34;: [\u0026#34;name\u0026#34;,\u0026#34;price\u0026#34;] } #分页 from size GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: \u0026#34;asc\u0026#34; } ], \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 1 } # 全文检索 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;nfc\u0026#34; } } } # 分词器 GET /_analyze { \u0026#34;analyzer\u0026#34;:\u0026#34;standard\u0026#34;, \u0026#34;text\u0026#34;:\u0026#34;xiaomi nfc phone\u0026#34; } #短语搜索 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_phrase\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;xiaomi\u0026#34; } , \u0026#34;bool\u0026#34;: { } } } #query and filter GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;bool\u0026#34;: { \u0026#34;must\u0026#34;: [ {\u0026#34;match\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;xiaomi\u0026#34;}}, {\u0026#34;match\u0026#34;: {\u0026#34;desc\u0026#34; \u0026#34;shouji\u0026#34;}}], \u0026#34;filter\u0026#34;: [ {\u0026#34;match_phrase\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;xiaomi\u0026#34;}}, {\u0026#34;range\u0026#34;:{\u0026#34;price\u0026#34;:{ \u0026#34;gte\u0026#34;:10,\u0026#34;lte\u0026#34;:20}}} ], \u0026#34;should\u0026#34;: [ {\u0026#34;range\u0026#34;: { \u0026#34;FIELD\u0026#34;: { \u0026#34;gte\u0026#34;: 10, \u0026#34;lte\u0026#34;: 20 } }} ], \u0026#34;minimum_should_match\u0026#34;: 1 } } } # 高亮 GET /product/_search { \u0026#34;query\u0026#34;: { \u0026#34;match_phrase\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;nfc\u0026#34; } }, \u0026#34;highlight\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;name\u0026#34;: {} } } } #scroll search GET /product/_search?scroll=1m { \u0026#34;query\u0026#34;: { \u0026#34;match_all\u0026#34;: {} }, \u0026#34;sort\u0026#34;: [ { \u0026#34;price\u0026#34;: { \u0026#34;order\u0026#34;: \u0026#34;desc\u0026#34; } } ] } GET /_search/scroll { \u0026#34;scroll_id\u0026#34; : \u0026#34;FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFjhiSmpqSkhqU1FlR1pfbXJYaTZ2ZVEAAAAAAABoRBZJOWhLcFBtUVJfMlg4SU4wQldrV2VR\u0026#34; }     关键词\n \u0026quot;term:{}\u0026quot; query-term完全匹配 不会分词 \u0026quot;match\u0026quot;:{} 匹配 模糊匹配 先对输入进行分词,对分词后的结果进行查询 \u0026quot;match_parse\u0026quot;:{} \u0026quot;match_All\u0026quot;:{} 匹配所有 \u0026quot;multi_match\u0026quot;:{}:根据多个字段查询一个关键词 \u0026quot;_source:{}\u0026quot;元数据,想要查询多个字段  \u0026quot;from\u0026quot;:0,\u0026quot;size\u0026quot;:2deep-paging 分页 \u0026quot;range\u0026quot;:{} \u0026quot;gte\u0026quot;: NUM \u0026quot;lte\u0026quot;:NUM 取范围    全文检索  term  不会被分词    短语搜索  match_phrase  Query and filter 查询和过滤  bool   must\n  filter 过滤器,不计算相关度分数,cache\n 缓存功能  filter并不是每次执行都会进行cache,而是当执行一定次数的时候才会进行cache一个二进制数组,1表示匹配,0表示不匹配,这个次数不是固定的 filter会优先过滤掉稀疏的数据,保留匹配的cache数组 filter cache保存的是匹配的结果,不需要再从倒排索引中去查找比对,大大提高查询速度 filter一般会在query之前执行,过滤掉一部分数据,从而提高query速度 filter不计算相关度分数,在执行效率上较query高 党员数据发生改变时,cache也会更新      should 可能满足 or\n 多个条件,满足minimum_should_match 默认是0    must_not 不计算相关度分数\n    Deep paging  深度分页 返回结果不要超过1000个 解决办法  避免深查询 scroll search    scroll search  先查询一部分,给查询的加一个标识,下次继续查询后面的 GET /product/_search?scroll=1m 1m是有效期,1s 1ms  \u0026quot;scroll\u0026quot;:\u0026quot;1m\u0026quot; 延期    Mapping  mapping 就是es数据字段field的type元数据,es在创建索引的时候,dynamic mapping会自动为不同的数据指定相应的mapping mapping中包含了字段的类型,搜索方式(exact value或者full text),分词器等 查看mapping GET /product/_mappings 搜索方式  exact value 精确匹配:在倒排索引过程中,分词器会将field作为一个整体创建到索引中 full text 全文检索,分词,近义词,混淆词,大小写,词性,过滤,时态转换等(normalization)   Mapping Parameter  index 是否对当前字段创建索引,默认为true,如果不创建索引,该字段不会通过索引被搜索到,但仍会在source元数据中展示 analyzer 指定分析器(character filter,tokenizer,Token filters) boost 对当前字段相关度的评分权重,默认是1 coerce 是否允许强制类型转换 copy_to    ","permalink":"http://blog.oxide.ink/posts/db/elasticsearch/","summary":"概述  ES不等于搜索引擎 分布式的搜索,存储,数据分析引擎 优点:  面向开发者友好,屏蔽了Luncene的复杂特性,集群自动发现 自动维护数据在多个节点上的建立 帮我们做搜索请求的负载均衡 自动维护冗余副本,保证了部分节点宕机的情况下仍然不会有任何数据丢失 ES基于Lucene提供了很多高级功能:符合查询,聚合分析,基于地理位置 对于大公司,可以构建几百台服务器的大型分布式集群,处理PB级别数据 相遇传统数据库,提供了全文见检索,同义词处理,相关度排名,聚合分析以及海量数据的近实时(NTR)处理,这些传统数据库完全做不到   应用领域  搜索引擎 各大网站的用户行为日志(点击,浏览,收藏,评论) BI 数据分析 Github ELK (Elasticseach(数据存储) Logstash(日志采集) Kibana(可视化))    核心概念和原理  搜索  SQL 用了%不能用索引 -\u0026gt;性能差  like % 搜索时间复杂度O(n)   不能分词   倒排索引  分词 生成相关度 * 排序 空间换时间   数据结构  document List 关键词在每个doc中出现的次数 TF term frequency 词频 IDF inverse doc frequency 关键词在当前doc出现的次数 每个doc的长度 越长相关度越低 包含这个关键词的所有doc的平均长度     核心概念  集群:每个集群至少包含两个节点 Node:集群中的节点 一个节点不代表是一台机器 Filed: 一个数据字段,与index和type可以定位一个doc Document:ES最小的数据单元 Json Type:逻辑上的数据分类 Index:一类相同或者相似的doc 分片shard  一个index包含多个shard,默认5p,默认每个p分配一个r,p的数量在创建索引的时候设置,如果想修改,需要重建索引 每个shard都是一个lucene实例,有完整的创建索引的处理请求能力 ES会自动在nodes尚未我们zuoshard均衡 一个doc不可能同时存在于多个PShard,但是可以同时多个Rshard p和对应的r不能同时存在于同一个节点,所以最低的可用配置是两台节点,互为主备   横向扩容 Parimary Shared Replica Shard     容错  两台机子p0,p1,p2 r0,r1,r2 p挂掉之后r顶上 容错机制  master选举  findMaster  脑裂 可能会产生多个master节点   判断自己是否为master 广播/findMaster   replica容错 重启故障机 数据恢复  只拷贝新增数据 不是全量拷贝        使用  健康值检查  CRUD  Query String search 类似于Url挂参数搜索 Query DSL Query and filter  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  GET /_cat/health?","title":"ElasticSearch"},{"content":"介绍 数据是什么 如何存储 数据库引擎   innodb\n  myisam\n  memory\n  区别\n innodb存储引擎数据跟索引文件放在一个文件中,myisam分为不同文件 innodb支持事务,myisam不支持事务 innodb支持表锁和行锁,myisam支持表锁 innodb有外键,myisam没有外键    索引的分类  主键索引  主键索引是一种唯一性索引,但它必须指定为primary key,每个表只能有一个主见   唯一索引  索引的列所有值都只能出现一次,即必须唯一,值可以为空   普通索引  基本的索引类型,值可以为空,没有唯一性限制   全文索引  全文索引类型为FULLTEXT,全文索引可以在varchar,char,text类型的列上创建   组合索引  多列值组成一个索引,专门用于组合搜索    回表 最左匹配原则 索引覆盖 索引下推 select * from t1 where age=? and gender=? 先根据age字段从存储引擎层将数据拉取回server层,然后在server层进行gender筛选,再从存储引擎层拉去数据的 时候,就会直接根据age,gender一起筛选 ##准备\n数据库   云数据库\n RDS,PolarDB,TDSQL    NewSQL\n TiDB    生产线\n 厂家  Oracle 官方 MariaDB Percona      5.6\n 5.6.36,5.6.38,5.6.40,5.6.46    5.7\n 5.7.20 22 24\u0026hellip;.    8.0\n 8.0.11,8.0.17,8.0.18    C:社区版\n  E:企业版\n  linux环境 mysql指令  数据初始化  mysqld --initialize-insecure --user=xxx --basedir=/app/database/mysql --datadir=/data/3306/ 有-insecure  初始化完成后,有12位临时密码,必须在使用mysql之前重置这个密码 密码管理使用严格模式: 3种密码复杂度,8位以上       SQL概述  Structured Query Language  用来跟数据库打交道,完成和数据库的通信,90%以上的SQL语句是通用的   数据库(notes.DB)  notes.DB: 通常是一个或一组文件,保存了一些符合特定规格的数据 DBMS:DataBase Management System 数据库管理系统 MySql,Oracle,执行SQL,操作数据库    连接数据库  mysql -uxxxxx -pxxxxx  1  msyql -uroot -p123456   概念  table  一种结构化的文件,用来存储特定类型的数据   SQL的分类  数据查询语言(DQL-Data Query Language)  select   数据操纵语言(DML-Data Manipulation Language)  insert,delete,update   数据定义语言(DDL-Data Definition Language)  create,drop,alter   事务控制语言(TCL-Transactional Control Language)  commit,rollback   数据控制语言(DCL-Data Control Language)  grant,revoke      常用命令  select version();查看版本 select database();查看当前数据库 desc \u0026lt;database\u0026gt;; 查看详细信息 show create table \u0026lt;tablename\u0026gt;;查看建表语句  Base 简单查询   查询\n select \u0026lt;volumes\u0026gt; from \u0026lt;table\u0026gt;; 查询某个字段的信息(无视大小写)  可以加数学表达式  select empno,ename,sal*12 from emp;   重命名   select empno,ename,sal*12 as years from emp; 加as,可空格不写as select empno,ename,sal*12 as years from emp;        条件查询\n select \u0026lt;volumes\u0026gt; from \u0026lt;table\u0026gt; where \u0026lt;条件\u0026gt;; 条件      运算符 说明     = 等于   \u0026lt;\u0026gt;或!= 不等于   \u0026lt; 小于   \u0026gt; 大于   \u0026gt;= 大于等于   between \u0026hellip;and\u0026hellip; 两只之间,等同于\u0026gt;= and \u0026lt;=,左闭右开   is null 为null(is not null 不为空)   and 并且 ,优先级高于\u0026rsquo;or'   or 或者   in 包含   not 取非,主要用在is 或 in中   like 模糊查询,支持%或下划线匹配,%匹配任意个字符,下划线,一个下划线匹配一个字符          排序\n order by \u0026lt;volume\u0026gt; 默认升序,volume可为数字,代表第几个属性  asc 升序 desc 降序      数据处理函数/单行处理函数\n     运算符 说明 示例     Lower 转换小写 lower(ename)   upper 转换大写 upper(ename)   substr 子串 substr(ename,1,2)   length 取长度 length(ename)   trim 去空格 trim(ename)   str_to_date 将字符串换成日期 str_to_date(\u0026lsquo;字符串\u0026rsquo;,\u0026lsquo;时间格式\u0026rsquo;)   date_format 格式化日期 date_format(日期类型数据,\u0026lsquo;日期格式\u0026rsquo;)   format 设置千分位    round 四舍五入 round(comm,0)第二个参数为取得为数,可为负数   rand() 生成随机数 与java Math.Random()类似   ifnull 将null转换为具体值 ifnull(comm,0)如果comm为null,则转换为0        日期\n 关于MySQL中的日期处理  每一个数据库处理日期的时候,采用的机制都是不同的,日期处理都有自己的一套机制,所以在实际开发中 表中的字段定义为DATE类型,这种情况很少,因为一旦使用日期类型,那么java程序将不能够通用,在实际开发中 一般使用\u0026quot;日期字符串\u0026quot;来表示日期      MySQL数据库管理系统中对日期的处理提供了两个重要函数\n str_to_date date_format    str_to_date\n 该函数的作用是:将日期字符串转换成日期类型 varchar\u0026ndash;\u0026gt;date 该函数的执行结果是DATE类型 该函数的使用格式  str_to_date(\u0026lsquo;日期字符串\u0026rsquo;,\u0026lsquo;日期格式\u0026rsquo;)      1  selectename,hiredatefromempwherehiredate=str_to_date(\u0026#39;12-17-1980\u0026#39;,\u0026#39;%m-%d-%Y\u0026#39;);   date_format  该函数的作用是:将日期类型date转换成剧有特定格式的日期字符串varchar date\u0026ndash;\u0026gt;varchar 该函数的运算结果是:varchar类型(具备特定格式) 该函数的语法格式:  date_format(日期类型数据,\u0026lsquo;日期格式\u0026rsquo;)      1  selectename,date_format(hiredate,\u0026#39;%m-%d-%Y\u0026#39;)ashiredatefromemp;    日期格式\n     notes.Java MySQL 说明     yyyy %Y 年   MM %m 月   dd %d 日   HH %H 时   mm %i 分   ss %s 秒   SSS  毫秒        分组函数/聚合函数/多行处理函数 (忽略空值)\n     函数 说明     count 取得记录值   sum 求和   avg 取平均   max 取最大值   min 取最小     分组函数不能直接用在where函数中    distinct 去重复\n 前面不能有字段    1  selectdistinctjobfromemp;  分组查询  分组查询涉及的两个子句:  group by 分组,优先执行(先分组,再where,再select再having) having 分组之后过滤   group by  若一条DQL语句中有group by子句,那么select关键字后面只能跟参与分组的字段和分组函数 求不同job的最大sal    1  selectmax(sal)fromempgroupbyjob;  求不同job的最大sal也显示job\n1  selectjob,max(sal)fromempgroupbyjob;  两个字段联合划分分组\n1  selectdeptno,job,max(sal)fromempgroupbyjob,deptno;  select: 分组前筛选 having: 分组后筛选\n1 2  selectjob,avg(sal)fromempgroupbyjobhavingavg(sal)\u0026gt;1500;   原则:  尽量在where中过滤,无法过滤的数据,通常需要先分组之后再过滤,这个时候可以选择用having.效率问题    总结 1 2 3 4 5 6 7 8 9 10 11 12 13  select...from...where...groupby...having...orderby...   顺序不能变 执行顺序  from 从某张表中查询出来 where 经过某条件进行过滤 group by 然后分组 having 分组之后不满意再过滤 select 查询出来 order by 排序输出    连接查询   什么是连接查询\n 查询的时候只从一张表检索数据,称为单表查询 在实际开发中,数据并不是存储在一张表中,是同时存储在多张表中,这些表和表之箭存在关系,我们在检索的时候通常是 需要将多张表联合起来取得有效数据,这种多表查询被称为连接查询或者叫做跨表查询    链接查询根据出现年代分类\n SQL92[1992] SQL00[1999:更新的语法,主要掌握这种]    连接查询根据连接方式可分为\n 内连接 :A表和B表能够完全匹配的记录查询出来,被称为内连接(inner可以省略)   等值连接\n SQL92语法:等值连接  1  selecte.ename,d.dnamefromempe,deptdwheree.deptno=d.deptno;  -SQL99语法:等值连接 join on - 表独立出来了,结构更清晰,对表连接不满意的话可以追加where过滤\n1  selecte.ename,d.dnamefromempejoindeptdone.deptno=d.deptno;    非等值连接\n SQL99: 1  selecte.ename,s.gradefromempe,salgradeswheree.salbetweens.losalandhisal;   SQL99: 1  selecte.ename,s.gradefromempejoinsalgradesone.salbetweens.losalandhisal;      自连接\n SQL99: 1  selecte.ename,m.enamefromempe,empmwherem.empno=e.mgr;   SQL99: 1  selecte.ename,m.enamefromempejoinempmonm.empno=e.mgr;       外连接 : (outer可以省略)   A表和B表能够完全匹配的记录查询出来之外,将其中一张表的记录无条件的完全查询出来. 对方没有匹配的记录,会自动模拟出null与之匹配,这种查询被称为外连接\n  外连接的查询结果条数\u0026gt;=内连接的查询结果条数\n  左外连接\n SQL99: 1  selecte.ename,d.dnamefromdeptdleftjoinempeone.deptno=d.deptno;      右外连接\n SQL99: 1  selecte.ename,d.dnamefromemperightjoindeptdone.deptno=d.deptno;      任何一个右外连接都可以写成左外连接,反之亦可\n   全连接     若两张表进行连接查询的时候没有任何条件限制,最终的查询结果总数是两张表记录的条数的乘积,这种现象被称为 笛卡尔积现象,为了避免笛卡尔积现象的发生,必须在进行表连接的时候添加限制条件  1  selecte.ename,d.dnamefromempe,deptd;   多张表连接的语法格式  1 2 3 4 5 6 7 8 9 10 11 12 13  selectxxxfromajoinbon条件joincon条件;  原理:a和b进行表连接之后,a再和c进行表连接\n 案例:找出每一个员工对应的部门名称,以及该员工的工资等级:  1  selecte.ename,d.dname,s.gradefromempejoindeptdone.deptno=d.deptnojoinsalgradesone.salbetweenlosalandhisal;  子查询:\n1  selecte.ename,e.dname,s.gradefrom(selecte.ename,e.sal,d.dnamefromempeleftjoindeptdone.deptno=d.deptno)eleftjoinsalgradesone.salbetweens.losalandhisal;  子查询  什么是子查询  select语句嵌套select语句   子查询可以出现在哪儿  select\u0026hellip;(select) from\u0026hellip;.(select) where\u0026hellip;.(select)    select后select\n1  selecte.ename,(selectd.dnamefromdeptdwheree.deptno=d.deptno)asdnamefromempe;   找出每个部门的平均薪水,并且要求显示平均薪水的薪水等级 from 后select  1  selectd.dname,s.gradefrom(selectd.dname,e.salfrom(selectdeptno,avg(sal)assalfromempgroupbydeptno)ejoindeptdond.deptno=e.deptno)djoinsalgradesond.salbetweenlosalandhisal;  union  连接两个表一同输出  1 2 3  selectxxxxxunionselectxxxxx  字段个数相同,(Oracle中数据类型也要相同)\nlimit  获取一张表中的某部分数据 只在MySQL数据库中存在,不通用,是MySQL数据库的特色  1  selectename,salfromemplimit5;  limit 5 代表,从表中记录下标0开始,取五条等同于下面的sql语句\n1  selectename,salfromemplimit0,5;  limit的语法: limit 起始下标,长度 - 起始坐标没有指定,默认从0开始,0表示表中的第一条ji\u0026rsquo;lu\n 找出公司中工资排名在前五的员工  1  selectename,salfromemporderbysaldesclimit5;  表  DDL  ","permalink":"http://blog.oxide.ink/posts/db/mysql/","summary":"介绍 数据是什么 如何存储 数据库引擎   innodb\n  myisam\n  memory\n  区别\n innodb存储引擎数据跟索引文件放在一个文件中,myisam分为不同文件 innodb支持事务,myisam不支持事务 innodb支持表锁和行锁,myisam支持表锁 innodb有外键,myisam没有外键    索引的分类  主键索引  主键索引是一种唯一性索引,但它必须指定为primary key,每个表只能有一个主见   唯一索引  索引的列所有值都只能出现一次,即必须唯一,值可以为空   普通索引  基本的索引类型,值可以为空,没有唯一性限制   全文索引  全文索引类型为FULLTEXT,全文索引可以在varchar,char,text类型的列上创建   组合索引  多列值组成一个索引,专门用于组合搜索    回表 最左匹配原则 索引覆盖 索引下推 select * from t1 where age=? and gender=? 先根据age字段从存储引擎层将数据拉取回server层,然后在server层进行gender筛选,再从存储引擎层拉去数据的 时候,就会直接根据age,gender一起筛选 ##准备\n数据库   云数据库","title":"MySQL"},{"content":"安装\u0026amp;启动 server  redis_6379 redis-server /etc/redis/6379.conf --loadmoudle  client 入门  无数据类型 默认16个库(分为16个独立的区域) redis-cli -p xxxx -n [指定库] 方法与类型绑定  type 获取值的类型   二进制安全  字节流 字符流   redis-cli \u0026ndash;raw 格式化 help keys * flushall flushdb  数据类型 help @String\n String  encoding-str  set  生存时间 nx - 不存在的时候赋值 xx - 存在的时候才能更新   get mset - 多个存 mget - 多个取 append - 追加 getrange [start] [end]  正反向索引   setrange 修改 strlen -\u0026gt; length msetnx 原子性多操作,一个失败就取消操作   encoding-int(省去之后计算的判断,本质还是字节流)  incr +1 incrby [value] n decr [value] 减1 incrbyfloat [value] n 加浮点数   bitmap  bitset 设置字节中的bit offset是指bit bitpos 第一个1 offset是指字节 bitcount offset是指字节 bitop     List  Lpush Rpush Lpop Rpop lrange Lindex Rindex Lrem Rrem llen blpop  阻塞队列,单播队列 先进先出   Ltrim   Hash map(k-v)  hset hget hgetall hincrby hincrybyfloat keys sean*   set  sadd scard 交集并集差集  sinter(store) sunion sdiff   sismember smembers srandmember spop   sorted_set  zadd zrange # zrevrange # zrangebyscore zscore zrank zincrby 实时维护 交集并集差集  zunionstore weights 聚合指令   zremovebyscore zremovebyrank  滑动窗口      进阶 管道  echo -n \u0026quot;set k1 99\\n incr k1 \\n get k1\u0026quot; | nc xxxx 6379  建立tcp通信就能跟redis对话    发布/订阅 事务  transaction  multi 开启事务 exec 执行事务 discard 取消事务 watch  乐观锁 cas  A  watch k1 multi get k1 keys *   B  muti keys * set k1 xxxxx exec Aexec  数据被b修改过 不执行事务           缓存穿透  module redisbloom  bloom过滤器 布谷鸟过滤器 counting bloom   查找没有的东西   缓存和数据库的区别 config  内存  回收策略  noeviction 不丢,做数据库用 lfu 碰了多少次 lru 多久没碰 random ttl       有效期  ttl 按存活时间来  ttl + key 存活时间 key的有效期,访问延长?no 发生写,会剔除过期时间(没设置新的时间?) expire 设置时间(多少秒)  expireat 指定时间(倒计时,且不能延长)     被动/主动    ","permalink":"http://blog.oxide.ink/posts/db/redis/","summary":"安装\u0026amp;启动 server  redis_6379 redis-server /etc/redis/6379.conf --loadmoudle  client 入门  无数据类型 默认16个库(分为16个独立的区域) redis-cli -p xxxx -n [指定库] 方法与类型绑定  type 获取值的类型   二进制安全  字节流 字符流   redis-cli \u0026ndash;raw 格式化 help keys * flushall flushdb  数据类型 help @String\n String  encoding-str  set  生存时间 nx - 不存在的时候赋值 xx - 存在的时候才能更新   get mset - 多个存 mget - 多个取 append - 追加 getrange [start] [end]  正反向索引   setrange 修改 strlen -\u0026gt; length msetnx 原子性多操作,一个失败就取消操作   encoding-int(省去之后计算的判断,本质还是字节流)  incr +1 incrby [value] n decr [value] 减1 incrbyfloat [value] n 加浮点数   bitmap  bitset 设置字节中的bit offset是指bit bitpos 第一个1 offset是指字节 bitcount offset是指字节 bitop     List  Lpush Rpush Lpop Rpop lrange Lindex Rindex Lrem Rrem llen blpop  阻塞队列,单播队列 先进先出   Ltrim   Hash map(k-v)  hset hget hgetall hincrby hincrybyfloat keys sean*   set  sadd scard 交集并集差集  sinter(store) sunion sdiff   sismember smembers srandmember spop   sorted_set  zadd zrange # zrevrange # zrangebyscore zscore zrank zincrby 实时维护 交集并集差集  zunionstore weights 聚合指令   zremovebyscore zremovebyrank  滑动窗口      进阶 管道  echo -n \u0026quot;set k1 99\\n incr k1 \\n get k1\u0026quot; | nc xxxx 6379  建立tcp通信就能跟redis对话    发布/订阅 事务  transaction  multi 开启事务 exec 执行事务 discard 取消事务 watch  乐观锁 cas  A  watch k1 multi get k1 keys *   B  muti keys * set k1 xxxxx exec Aexec  数据被b修改过 不执行事务           缓存穿透  module redisbloom  bloom过滤器 布谷鸟过滤器 counting bloom   查找没有的东西   缓存和数据库的区别 config  内存  回收策略  noeviction 不丢,做数据库用 lfu 碰了多少次 lru 多久没碰 random ttl       有效期  ttl 按存活时间来  ttl + key 存活时间 key的有效期,访问延长?","title":"Redis"}]